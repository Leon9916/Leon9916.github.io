{"pages":[{"title":"","text":"古力娜扎 迪丽热巴 马尔扎哈 李一桐 杨洋 图片搜集于互联网，如有侵权，请联系，立即处理。","link":"/album/index.html"},{"title":"","text":"个人简介 很喜欢的罗翔老师的一段话： “做你该做的事情，并接受事与愿违。许多事情不是看到了希望才坚持，而是坚持了才看到了希望。“ 人生啊充满着挑战，有很多有形无形的考试。很多时候呢，我们只能尽力而为，但是结果要选择角度，因为人生唯一确定的就是不确定的人生。在每一个人生的重要关头，我们只需要尽力而为，不留遗憾。 -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：企业应用软件/软件工程从事前端开发大专码畜一枚 ps：自考本科不算的话我欲乘风去，昔年化龙归 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。","link":"/about/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：爷ゝ本霸气っ 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }) gitalk.render('comment-container1')","link":"/self-talking/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"“这些站点也是大佬们辛辛苦苦搭建的，各位小伙伴觉得好用的话也可以请站长喝个冰阔乐。“","link":"/chat_brother/index.html"}],"posts":[{"title":"中华人民共和国劳动法","text":"《中华人民共和国劳动法》已由中华人民共和国第八届全国人民代表大会常务委员会第八次会议于１９９４年７月５日通过，现予公布，自１９９５年１月１日起施行。 中华人民共和国主席令 （第二十八号） 《中华人民共和国劳动法》已由中华人民共和国第八届全国人民代表大会常务委员会第八次会议于１９９４年７月５日通过，现予公布，自１９９５年１月１日起施行。 中华人民共和国主席 江泽民 １９９４年７月５日 中华人民共和国劳动法 （１９９４年７月５日第八届全国人民代表大会常务委员会第八次会议通过） 目录 第一章 总则 第二章 促进就业 第三章 劳动合同和集体合同 第四章 工作时间和休息休假 第五章 工资 第六章 劳动安全卫生 第七章 女职工和未成年工特殊保护 第八章 职业培训 第九章 社会保险和福利 第十章 劳动争议 第十一章 监督检查 第十二章 法律责任 第十三章 附则 第一章 总则 第一 为了保护劳动者的合法权益，调整劳动关系，建立和维护适应社会主义市场经济的劳动制度，促进经济发展和社会进步，根据宪法，制定本法。 第二 在中华人民共和国境内的企业、个体经济组织（以下统称用人单位）和与之形成劳动关系的劳动者，适用本法。 国家机关、事业组织、社会团体和与之建立劳动合同关系的劳动者，依照本法执行。 第三 劳动者享有平等就业和选择职业的权利、取得劳动报酬的权利、休息休假的权利、获得劳动安全卫生保护的权利、接受职业技能培训的权利、享受社会保险和福利的权利、提请劳动争议处理的权利以及法律规定的其他劳动权利。 劳动者应当完成劳动任务，提高职业技能，执行劳动安全卫生规程，遵守劳动纪律和职业道德。 第四 用人单位应当依法建立和完善规章制度，保障劳动者享有劳动权利和履行劳动义务。 第五 国家采取各种措施，促进劳动就业，发展职业教育，制定劳动标准，调节社会收入，完善社会保险，协调劳动关系，逐步提高劳动者的生活水平。 第六 国家提倡劳动者参加社会义务劳动，开展劳动竞赛和合理化建议活动，鼓励和保护劳动者进行科学研究、技术革新和发明创造，表彰和奖励劳动模范和先进工作者。 第七条 劳动者有权依法参加和组织工会。 工会代表和维护劳动者的合法权益，依法独立自主地开展活动。 第八 劳动者依照法律规定，通过职工大会、职工代表大会或者其他形式，参与民主管理或者就保护劳动者合法权益与用人单位进行平等协商。 第九条 国务院劳动行政部门主管全国劳动工作。 县级以上地方人民政府劳动行政部门主管本行政区域内的劳动工作。 第二章 促进就业 第十 国家通过促进经济和社会发展，创造就业条件，扩大就业机会。 国家鼓励企业、事业组织、社会团体在法律、行政法规规定的范围内兴办产业或者拓展经营，增加就业。 国家支持劳动者自愿组织起来就业和从事个体经营实现就业。 第十一 地方各级人民政府应当采取措施，发展多种类型的职业介绍机构，提供就业服务。 第十二 劳动者就业，不因民族、种族、性别、宗教信仰不同而受歧视。 第十三 妇女享有与男子平等的就业权利。在录用职工时，除国家规定的不适合妇女的工种或者岗位外，不得以性别为由拒绝录用妇女或者提高对妇女的录用标准。 第十四 残疾人、少数民族人员、退出现役的军人的就业，法律、法规有特别规定的，从其规定。 第十五条 禁止用人单位招用未满十六周岁的未成年人。 文艺、体育和特种工艺单位招用未满十六周岁的未成年人，必须依照国家有关规定，履行审批手续，并保障其接受义务教育的权利。 第三章 劳动合同和集体合同 第十六 劳动合同是劳动者与用人单位确立劳动关系、明确双方权利和义务的协议。 建立劳动关系应当订立劳动合同。 第十七 订立和变更劳动合同，应当遵循平等自愿、协商一致的原则，不得违反法律、行政法规的规定。 劳动合同依法订立即具有法律约束力，当事人必须履行劳动合同规定的义务。 第十八条 下列劳动合同无效： （一）违反法律、行政法规的劳动合同； （二）采取欺诈、威胁等手段订立的劳动合同。 无效的劳动合同，从订立的时候起，就没有法律约束力。确认劳动合同部分无效的，如果不影响其余部分的效力，其余部分仍然有效。 劳动合同的无效，由劳动争议仲裁委员会或者人民法院确认。 第十九条 劳动合同应当以书面形式订立，并具备以下条款： （一）劳动合同期限； （二）工作内容； （三）劳动保护和劳动条件； （四）劳动报酬； （五）劳动纪律； （六）劳动合同终止的条件； （七）违反劳动合同的责任。 劳动合同除前款规定的必备条款外，当事人可以协商约定其他内容。 第二十 劳动合同的期限分为有固定期限、无固定期限和以完成一定的工作为期限。 劳动者在同一用人单位连续工作满十年以上，当事人双方同意延续劳动合同的，如果劳动者提出订立无固定期限的劳动合同，应当订立无固定期限的劳动合同。 第二十一 劳动合同可以约定试用期。试用期最长不得超过六个月。 第二十二 劳动合同当事人可以在劳动合同中约定保守用人单位商业秘密的有关事项。 第二十三 劳动合同期满或者当事人约定的劳动合同终止条件出现，劳动合同即行终止。 第二十四条 经劳动合同当事人协商一致，劳动合同可以解除。 第二十五 劳动者有下列情形之一的，用人单位可以解除劳动合同： （一）在试用期间被证明不符合录用条件的； （二）严重违反劳动纪律或者用人单位规章制度的； （三）严重失职，营私舞弊，对用人单位利益造成重大损害的； （四）被依法追究刑事责任的。 第二十六 有下列情形之一的，用人单位可以解除劳动合同，但是应当提前三十日以书面形式通知劳动者本人： （一）劳动者患病或者非因工负伤，医疗期满后，不能从事原工作也不能从事由用人单位另行安排的工作的； （二）劳动者不能胜任工作，经过培训或者调整工作岗位，仍不能胜任工作的； （三）劳动合同订立时所依据的客观情况发生重大变化，致使原劳动合同无法履行，经当事人协商不能就变更劳动合同达成协议的。 第二十七 用人单位濒临破产进行法定整顿期间或者生产经营状况发生严重困难，确需裁减人员的，应当提前三十日向工会或者全体职工说明情况，听取工会或者职工的意见，经向劳动行政部门报告后，可以裁减人员。 用人单位依据本条规定裁减人员，在六个月内录用人员的，应当优先录用被裁减的人员。 第二十八 用人单位依据本法第二十四条、第二十六条、第二十七条的规定解除劳动合同的，应当依照国家有关规定给予经济补偿。 第二十九 劳动者有下列情形之一的，用人单位不得依据本法第二十六条、第二十七条的规定解除劳动合同： （一）患职业病或者因工负伤并被确认丧失或者部分丧失劳动能力的； （二）患病或者负伤，在规定的医疗期内的； （三）女职工在孕期、产假、哺乳期内的； （四）法律、行政法规规定的其他情形。 第三十 用人单位解除劳动合同，工会认为不适当的，有权提出意见。如果用人单位违反法律、法规或者劳动合同，工会有权要求重新处理；劳动者申请仲裁或者提起诉讼的，工会应当依法给予支持和帮助。 第三十一 劳动者解除劳动合同，应当提前三十日以书面形式通知用人单位。 第三十二 有下列情形之一的，劳动者可以随时通知用人单位解除劳动合同： （一）在试用期内的； （二）用人单位以暴力、威胁或者非法限制人身自由的手段强迫劳动的； （三）用人单位未按照劳动合同约定支付劳动报酬或者提供劳动条件的。 第三十三 企业职工一方与企业可以就劳动报酬、工作时间、休息休假、劳动安全卫生、保险福利等事项，签订集体合同。集体合同草案应当提交职工代表大会或者全体职工讨论通过。 集体合同由工会代表职工与企业签订；没有建立工会的企业，由职工推举的代表与企业签订。 第三十四 集体合同签订后应当报送劳动行政部门；劳动行政部门自收到集体合同文本之日起十五日内未提出异议的，集体合同即行生效。 第三十五 依法签订的集体合同对企业和企业全体职工具有约束力。职工个人与企业订立的劳动合同中劳动条件和劳动报酬等标准不得低于集体合同的规定。 第四章 工作时间和休息休假 第三十六 国家实行劳动者每日工作时间不超过八小时、平均每周工作时间不超过四十四小时的工时制度。 第三十七 对实行计件工作的劳动者，用人单位应当根据本法第三十六条规定的工时制度合理确定其劳动定额和计件报酬标准。 第三十八条 用人单位应当保证劳动者每周至少休息一日。 第三十九 企业因生产特点不能实行本法第三十六条、第三十八条规定的，经劳动行政部门批准，可以实行其他工作和休息办法。 第四十条 用人单位在下列节日期间应当依法安排劳动者休假： （一）元旦； （二）春节； （三）国际劳动节； （四）国庆节； （五）法律、法规规定的其他休假节日。 第四十一 用人单位由于生产经营需要，经与工会和劳动者协商后可以延长工作时间，一般每日不得超过一小时；因特殊原因需要延长工作时间的，在保障劳动者身体健康的条件下延长工作时间每日不得超过三小时，但是每月不得超过三十六小时。 第四十二 有下列情形之一的，延长工作时间不受本法第四十一条规定的限制： （一）发生自然灾害、事故或者因其他原因，威胁劳动者生命健康和财产安全，需要紧急处理的； （二）生产设备、交通运输线路、公共设施发生故障，影响生产和公众利益，必须及时抢修的； （三）法律、行政法规规定的其他情形。 第四十三条 用人单位不得违反本法规定延长劳动者的工作时间。 第四十四 有下列情形之一的，用人单位应当按照下列标准支付高于劳动者正常工作时间工资的工资报酬： （一）安排劳动者延长工作时间的，支付不低于工资的百分之一百五十的工资报酬； （二）休息日安排劳动者工作又不能安排补休的，支付不低于工资的百分之二百的工资报酬； （三）法定休假日安排劳动者工作的，支付不低于工资的百分之三百的工资报酬。 第四十五条 国家实行带薪年休假制度。 劳动者连续工作一年以上的，享受带薪年休假。具体办法由国务院规定。 第五章 工资 第四十六条 工资分配应当遵循按劳分配原则，实行同工同酬。 工资水平在经济发展的基础上逐步提高。国家对工资总量实行宏观调控。 第四十七 用人单位根据本单位的生产经营特点和经济效益，依法自主确定本单位的工资分配方式和工资水平。 第四十八 国家实行最低工资保障制度。最低工资的具体标准由省、自治区、直辖市人民政府规定，报国务院备案。 用人单位支付劳动者的工资不得低于当地最低工资标准。 第四十九条 确定和调整最低工资标准应当综合参考下列因素： （一）劳动者本人及平均赡养人口的最低生活费用； （二）社会平均工资水平； （三）劳动生产率； （四）就业状况； （五）地区之间经济发展水平的差异。 第五十 工资应当以货币形式按月支付给劳动者本人。不得克扣或者无故拖欠劳动者的工资。 第五十一 劳动者在法定休假日和婚丧假期间以及依法参加社会活动期间，用人单位应当依法支付工资。 第六章 劳动安全卫生 第五十二 用人单位必须建立、健全劳动安全卫生制度，严格执行国家劳动安全卫生规程和标准，对劳动者进行劳动安全卫生教育，防止劳动过程中的事故，减少职业危害。 第五十三条 劳动安全卫生设施必须符合国家规定的标准。 新建、改建、扩建工程的劳动安全卫生设施必须与主体工程同时设计、同时施工、同时投入生产和使用。 第五十四 用人单位必须为劳动者提供符合国家规定的劳动安全卫生条件和必要的劳动防护用品，对从事有职业危害作业的劳动者应当定期进行健康检查。 第五十五 从事特种作业的劳动者必须经过专门培训并取得特种作业资格。 第五十六条 劳动者在劳动过程中必须严格遵守安全操作规程。 劳动者对用人单位管理人员违章指挥、强令冒险作业，有权拒绝执行；对危害生命安全和身体健康的行为，有权提出批评、检举和控告。 第五十七 国家建立伤亡事故和职业病统计报告和处理制度。县级以上各级人民政府劳动行政部门、有关部门和用人单位应当依法对劳动者在劳动过程中发生的伤亡事故和劳动者的职业病状况，进行统计、报告和处理。 第七章 女职工和未成年工特殊保护 第五十八条 国家对女职工和未成年工实行特殊劳动保护。 未成年工是指年满十六周岁未满十八周岁的劳动者。 第五十九 禁止安排女职工从事矿山井下、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。 第六十 不得安排女职工在经期从事高处、低温、冷水作业和国家规定的第三级体力劳动强度的劳动。 第六十一 不得安排女职工在怀孕期间从事国家规定的第三级体力劳动强度的劳动和孕期禁忌从事的活动。对怀孕七个月以上的女职工，不得安排其延长工作时间和夜班劳动。 第六十二条 女职工生育享受不少于九十天的产假。 第六十三 不得安排女职工在哺乳未满一周岁的婴儿期间从事国家规定的第三级体力劳动强度的劳动和哺乳期禁忌从事的其他劳动，不得安排其延长工作时间和夜班劳动。 第六十四 不得安排未成年工从事矿山井下、有毒有害、国家规定的第四级体力劳动强度的劳动和其他禁忌从事的劳动。 第六十五条 用人单位应当对未成年工定期进行健康检查。 第八章 职业培训 第六十六 国家通过各种途径，采取各种措施，发展职业培训事业，开发劳动者的职业技能，提高劳动者素质，增强劳动者的就业能力和工作能力。 第六十七 各级人民政府应当把发展职业培训纳入社会经济发展的规划，鼓励和支持有条件的企业、事业组织、社会团体和个人进行各种形式的职业培训。 第六十八 用人单位应当建立职业培训制度，按照国家规定提取和使用职业培训经费，根据本单位实际，有计划地对劳动者进行职业培训。 从事技术工种的劳动者，上岗前必须经过培训。 第六十九 国家确定职业分类，对规定的职业制定职业技能标准，实行职业资格证书制度，由经过政府批准的考核鉴定机构负责对劳动者实施职业技能考核鉴定。 第九章 社会保险和福利 第七十 国家发展社会保险事业，建立社会保险制度，设立社会保险基金，使劳动者在年老、患病、工伤、失业、生育等情况下获得帮助和补偿。 第七十一 社会保险水平应当与社会经济发展水平和社会承受能力相适应。 第七十二 社会保险基金按照保险类型确定资金来源，逐步实行社会统筹。用人单位和劳动者必须依法参加社会保险，缴纳社会保险费。 第七十三条 劳动者在下列情形下，依法享受社会保险待遇： （一）退休； （二）患病、负伤； （三）因工伤残或者患职业病； （四）失业； （五）生育。 劳动者死亡后，其遗属依法享受遗属津贴。 劳动者享受社会保险待遇的条件和标准由法律、法规规定。 劳动者享受的社会保险金必须按时足额支付。 第七十四 社会保险基金经办机构依照法律规定收支、管理和运营社会保险基金，并负有使社会保险基金保值增值的责任。 社会保险基金监督机构依照法律规定，对社会保险基金的收支、管理和运营实施监督。 社会保险基金经办机构和社会保险基金监督机构的设立和职能由法律规定。 任何组织和个人不得挪用社会保险基金。 第七十五 国家鼓励用人单位根据本单位实际情况为劳动者建立补充保险。 国家提倡劳动者个人进行储蓄性保险。 第七十六 国家发展社会福利事业，兴建公共福利设施，为劳动者休息、休养和疗养提供条件。 用人单位应当创造条件，改善集体福利，提高劳动者的福利待遇。 第十章 劳动争议 第七十七 用人单位与劳动者发生劳动争议，当事人可以依法申请调解、仲裁、提起诉讼，也可以协商解决。 调解原则适用于仲裁和诉讼程序。 第七十八 解决劳动争议，应当根据合法、公正、及时处理的原则，依法维护劳动争议当事人的合法权益。 第七十九 劳动争议发生后，当事人可以向本单位劳动争议调解委员会申请调解；调解不成，当事人一方要求仲裁的，可以向劳动争议仲裁委员会申请仲裁。当事人一方也可以直接向劳动争议仲裁委员会申请仲裁。对仲裁裁决不服的，可以向人民法院提起诉讼。 第八十 在用人单位内，可以设立劳动争议调解委员会。劳动争议调解委员会由职工代表、用人单位代表和工会代表组成。劳动争议调解委员会主任由工会代表担任。 劳动争议经调解达成协议的，当事人应当履行。 第八十一 劳动争议仲裁委员会由劳动行政部门代表、同级工会代表、用人单位方面的代表组成。劳动争议仲裁委员会主任由劳动行政部门代表担任。 第八十二 提出仲裁要求的一方应当自劳动争议发生之日起六十日内向劳动争议仲裁委员会提出书面申请。仲裁裁决一般应在收到仲裁申请的六十日内作出。对仲裁裁决无异议的，当事人必须履行。 第八十三 劳动争议当事人对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。一方当事人在法定期限内不起诉又不履行仲裁裁决的，另一方当事人可以申请人民法院强制执行。 第八十四 因签订集体合同发生争议，当事人协商解决不成的，当地人民政府劳动行政部门可以组织有关各方协调处理。 因履行集体合同发生争议，当事人协商解决不成的，可以向劳动争议仲裁委员会申请仲裁；对仲裁裁决不服的，可以自收到仲裁裁决书之日起十五日内向人民法院提起诉讼。 第十一章 监督检查 第八十五 县级以上各级人民政府劳动行政部门依法对用人单位遵守劳动法律、法规的情况进行监督检查，对违反劳动法律、法规的行为有权制止，并责令改正。 第八十六 县级以上各级人民政府劳动行政部门监督检查人员执行公务，有权进入用人单位了解执行劳动法律、法规的情况，查阅必要的资料，并对劳动场所进行检查。 县级以上各级人民政府劳动行政部门监督检查人员执行公务，必须出示证件，秉公执法并遵守有关规定。 第八十七 县级以上各级人民政府有关部门在各自职责范围内，对用人单位遵守劳动法律、法规的情况进行监督。 第八十八 各级工会依法维护劳动者的合法权益，对用人单位遵守劳动法律、法规的情况进行监督。 任何组织和个人对于违反劳动法律、法规的行为有权检举和控告。 第十二章 法律责任 第八十九 用人单位制定的劳动规章制度违反法律、法规规定的，由劳动行政部门给予警告，责令改正；对劳动者造成损害的，应当承担赔偿责任。 第九十 用人单位违反本法规定，延长劳动者工作时间的，由劳动行政部门给予警告，责令改正，并可以处以罚款。 第九十一 用人单位有下列侵害劳动者合法权益情形之一的，由劳动行政部门责令支付劳动者的工资报酬、经济补偿，并可以责令支付赔偿金： （一）克扣或者无故拖欠劳动者工资的； （二）拒不支付劳动者延长工作时间工资报酬的； （三）低于当地最低工资标准支付劳动者工资的； （四）解除劳动合同后，未依照本法规定给予劳动者经济补偿的。 第九十二 用人单位的劳动安全设施和劳动卫生条件不符合国家规定或者未向劳动者提供必要的劳动防护用品和劳动保护设施的，由劳动行政部门或者有关部门责令改正，可以处以罚款；情节严重的，提请县级以上人民政府决定责令停产整顿；对事故隐患不采取措施，致使发生重大事故，造成劳动者生命和财产损失的，对责任人员比照刑法第一百八十七条的规定追究刑事责任。 第九十三 用人单位强令劳动者违章冒险作业，发生重大伤亡事故，造成严重后果的，对责任人员依法追究刑事责任。 第九十四 用人单位非法招用未满十六周岁的未成年人的，由劳动行政部门责令改正，处以罚款；情节严重的，由工商行政管理部门吊销营业执照。 第九十五 用人单位违反本法对女职工和未成年工的保护规定，侵害其合法权益的，由劳动行政部门责令改正，处以罚款；对女职工或者未成年工造成损害的，应当承担赔偿责任。 第九十六 用人单位有下列行为之一，由公安机关对责任人员处以十五日以下拘留、罚款或者警告；构成犯罪的，对责任人员依法追究刑事责任： （一）以暴力、威胁或者非法限制人身自由的手段强迫劳动的； （二）侮辱、体罚、殴打、非法搜查和拘禁劳动者的。 第九十七 由于用人单位的原因订立的无效合同，对劳动者造成损害的，应当承担赔偿责任。 第九十八 用人单位违反本法规定的条件解除劳动合同或者故意拖延不订立劳动合同的，由劳动行政部门责令改正；对劳动者造成损害的，应当承担赔偿责任。 第九十九 用人单位招用尚未解除劳动合同的劳动者，对原用人单位造成经济损失的，该用人单位应当依法承担连带赔偿责任。 第一百 用人单位无故不缴纳社会保险费的，由劳动行政部门责令其限期缴纳；逾期不缴的，可以加收滞纳金。 第一百零一 用人单位无理阻挠劳动行政部门、有关部门及其工作人员行使监督检查权，打击报复举报人员的，由劳动行政部门或者有关部门处以罚款；构成犯罪的，对责任人员依法追究刑事责任。 第一百零二 劳动者违反本法规定的条件解除劳动合同或者违反劳动合同中约定的保密事项，对用人单位造成经济损失的，应当依法承担赔偿责任。 第一百零三 劳动行政部门或者有关部门的工作人员滥用职权、玩忽职守、徇私舞弊，构成犯罪的，依法追究刑事责任；不构成犯罪的，给予行政处分。 第一百零四 国家工作人员和社会保险基金经办机构的工作人员挪用社会保险基金，构成犯罪的，依法追究刑事责任。 第一百零五 违反本法规定侵害劳动者合法权益，其他法律、行政法规已规定处罚的，依照该法律、行政法规的规定处罚。 第十三章 附则 第一百零六 省、自治区、直辖市人民政府根据本法和本地区的实际情况，规定劳动合同制度的实施步骤，报国务院备案。 第一百零七条 本法自１９９５年１月１日起施行","link":"/posts/2f621441/"},{"title":"中华人民共和国宪法","text":"基本信息 发文字号：全国人民代表大会公告第1号 效力级别：法律 时效性：现行有效 发布日期：2018-03-11 实施日期：2018-03-11 发布机关：全国人民代表大会 法律修订 1982年12月4日第五届全国人民代表大会第五次会议通过 1982年12月4日全国人民代表大会公告公布施行 根据1988年4月12日第七届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》、1993年3月29日第八届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》、1999年3月15日第九届全国人民代表大会第二次会议通过的《中华人民共和国宪法修正案》、2004年3月14日第十届全国人民代表大会第二次会议通过的《中华人民共和国宪法修正案》和2018年3月11日第十三届全国人民代表大会第一次会议通过的《中华人民共和国宪法修正案》修正 中华人民共和国宪法（2004修正） 中华人民共和国宪法（1999修正） 中华人民共和国宪法（1993修正） 中华人民共和国宪法（1982修正） 中华人民共和国宪法（1978修正） 中华人民共和国宪法（1975修正） 中华人民共和国宪法（1954修正） 正文 序 言中国是世界上历史最悠久的国家之一。中国各族人民共同创造了光辉灿烂的文化，具有光荣的革命传统。一八四〇年以后，封建的中国逐渐变成半殖民地、半封建的国家。中国人民为国家独立、民族解放和民主自由进行了前仆后继的英勇奋斗。二十世纪，中国发生了翻天覆地的伟大历史变革。一九一一年孙中山先生领导的辛亥革命，废除了封建帝制，创立了中华民国。但是，中国人民反对帝国主义和封建主义的历史任务还没有完成。一九四九年，以毛泽东主席为领袖的中国共产党领导中国各族人民，在经历了长期的艰难曲折的武装斗争和其他形式的斗争以后，终于推翻了帝国主义、封建主义和官僚资本主义的统治，取得了新民主主义革命的伟大胜利，建立了中华人民共和国。从此，中国人民掌握了国家的权力，成为国家的主人。中华人民共和国成立以后，我国社会逐步实现了由新民主主义到社会主义的过渡。生产资料私有制的社会主义改造已经完成，人剥削人的制度已经消灭，社会主义制度已经确立。工人阶级领导的、以工农联盟为基础的人民民主专政，实质上即无产阶级专政，得到巩固和发展。中国人民和中国人民解放军战胜了帝国主义、霸权主义的侵略、破坏和武装挑衅，维护了国家的独立和安全，增强了国防。经济建设取得了重大的成就，独立的、比较完整的社会主义工业体系已经基本形成，农业生产显著提高。教育、科学、文化等事业有了很大的发展，社会主义思想教育取得了明显的成效。广大人民的生活有了较大的改善。中国新民主主义革命的胜利和社会主义事业的成就，是中国共产党领导中国各族人民，在马克思列宁主义、毛泽东思想的指引下，坚持真理，修正错误，战胜许多艰难险阻而取得的。我国将长期处于社会主义初级阶段。国家的根本任务是，沿着中国特色社会主义道路，集中力量进行社会主义现代化建设。中国各族人民将继续在中国共产党领导下，在马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观、习近平新时代中国特色社会主义思想指引下，坚持人民民主专政，坚持社会主义道路，坚持改革开放，不断完善社会主义的各项制度，发展社会主义市场经济，发展社会主义民主，健全社会主义法治，贯彻新发展理念，自力更生，艰苦奋斗，逐步实现工业、农业、国防和科学技术的现代化，推动物质文明、政治文明、精神文明、社会文明、生态文明协调发展，把我国建设成为富强民主文明和谐美丽的社会主义现代化强国，实现中华民族伟大复兴。在我国，剥削阶级作为阶级已经消灭，但是阶级斗争还将在一定范围内长期存在。中国人民对敌视和破坏我国社会主义制度的国内外的敌对势力和敌对分子，必须进行斗争。台湾是中华人民共和国的神圣领土的一部分。完成统一祖国的大业是包括台湾同胞在内的全中国人民的神圣职责。社会主义的建设事业必须依靠工人、农民和知识分子，团结一切可以团结的力量。在长期的革命、建设、改革过程中，已经结成由中国共产党领导的，有各民主党派和各人民团体参加的，包括全体社会主义劳动者、社会主义事业的建设者、拥护社会主义的爱国者、拥护祖国统一和致力于中华民族伟大复兴的爱国者的广泛的爱国统一战线，这个统一战线将继续巩固和发展。中国人民政治协商会议是有广泛代表性的统一战线组织，过去发挥了重要的历史作用，今后在国家政治生活、社会生活和对外友好活动中，在进行社会主义现代化建设、维护国家的统一和团结的斗争中，将进一步发挥它的重要作用。中国共产党领导的多党合作和政治协商制度将长期存在和发展。中华人民共和国是全国各族人民共同缔造的统一的多民族国家。平等团结互助和谐的社会主义民族关系已经确立，并将继续加强。在维护民族团结的斗争中，要反对大民族主义，主要是大汉族主义，也要反对地方民族主义。国家尽一切努力，促进全国各民族的共同繁荣。中国革命、建设、改革的成就是同世界人民的支持分不开的。中国的前途是同世界的前途紧密地联系在一起的。中国坚持独立自主的对外政策，坚持互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处的五项原则，坚持和平发展道路，坚持互利共赢开放战略，发展同各国的外交关系和经济、文化交流，推动构建人类命运共同体；坚持反对帝国主义、霸权主义、殖民主义，加强同世界各国人民的团结，支持被压迫民族和发展中国家争取和维护民族独立、发展民族经济的正义斗争，为维护世界和平和促进人类进步事业而努力。本宪法以法律的形式确认了中国各族人民奋斗的成果，规定了国家的根本制度和根本任务，是国家的根本法，具有最高的法律效力。全国各族人民、一切国家机关和武装力量、各政党和各社会团体、各企业事业组织，都必须以宪法为根本的活动准则，并且负有维护宪法尊严、保证宪法实施的职责。 第一章 总 纲第一条 中华人民共和国是工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家。 社会主义制度是中华人民共和国的根本制度。中国共产党领导是中国特色社会主义最本质的特征。禁止任何组织或者个人破坏社会主义制度。 第二条 中华人民共和国的一切权力属于人民。 人民行使国家权力的机关是全国人民代表大会和地方各级人民代表大会。 人民依照法律规定，通过各种途径和形式，管理国家事务，管理经济和文化事业，管理社会事务。 第三条 中华人民共和国的国家机构实行民主集中制的原则。 全国人民代表大会和地方各级人民代表大会都由民主选举产生，对人民负责，受人民监督。 国家行政机关、监察机关、审判机关、检察机关都由人民代表大会产生，对它负责，受它监督。 中央和地方的国家机构职权的划分，遵循在中央的统一领导下，充分发挥地方的主动性、积极性的原则。 第四条 中华人民共和国各民族一律平等。国家保障各少数民族的合法的权利和利益，维护和发展各民族的平等团结互助和谐关系。禁止对任何民族的歧视和压迫，禁止破坏民族团结和制造民族分裂的行为。 国家根据各少数民族的特点和需要，帮助各少数民族地区加速经济和文化的发展。 各少数民族聚居的地方实行区域自治，设立自治机关，行使自治权。各民族自治地方都是中华人民共和国不可分离的部分。 各民族都有使用和发展自己的语言文字的自由，都有保持或者改革自己的风俗习惯的自由。 第五条 中华人民共和国实行依法治国，建设社会主义法治国家。 国家维护社会主义法制的统一和尊严。 一切法律、行政法规和地方性法规都不得同宪法相抵触。 一切国家机关和武装力量、各政党和各社会团体、各企业事业组织都必须遵守宪法和法律。一切违反宪法和法律的行为，必须予以追究。 任何组织或者个人都不得有超越宪法和法律的特权。 第六条 中华人民共和国的社会主义经济制度的基础是生产资料的社会主义公有制，即全民所有制和劳动群众集体所有制。社会主义公有制消灭人剥削人的制度，实行各尽所能、按劳分配的原则。 国家在社会主义初级阶段，坚持公有制为主体、多种所有制经济共同发展的基本经济制度，坚持按劳分配为主体、多种分配方式并存的分配制度。 第七条 国有经济，即社会主义全民所有制经济，是国民经济中的主导力量。国家保障国有经济的巩固和发展。 第八条 农村集体经济组织实行家庭承包经营为基础、统分结合的双层经营体制。农村中的生产、供销、信用、消费等各种形式的合作经济，是社会主义劳动群众集体所有制经济。参加农村集体经济组织的劳动者，有权在法律规定的范围内经营自留地、自留山、家庭副业和饲养自留畜。 城镇中的手工业、工业、建筑业、运输业、商业、服务业等行业的各种形式的合作经济，都是社会主义劳动群众集体所有制经济。 国家保护城乡集体经济组织的合法的权利和利益，鼓励、指导和帮助集体经济的发展。 第九条 矿藏、水流、森林、山岭、草原、荒地、滩涂等自然资源，都属于国家所有，即全民所有；由法律规定属于集体所有的森林和山岭、草原、荒地、滩涂除外。 国家保障自然资源的合理利用，保护珍贵的动物和植物。禁止任何组织或者个人用任何手段侵占或者破坏自然资源。 第十条 城市的土地属于国家所有。 农村和城市郊区的土地，除由法律规定属于国家所有的以外，属于集体所有；宅基地和自留地、自留山，也属于集体所有。 国家为了公共利益的需要，可以依照法律规定对土地实行征收或者征用并给予补偿。 任何组织或者个人不得侵占、买卖或者以其他形式非法转让土地。土地的使用权可以依照法律的规定转让。 一切使用土地的组织和个人必须合理地利用土地。 第十一条 在法律规定范围内的个体经济、私营经济等非公有制经济，是社会主义市场经济的重要组成部分。 国家保护个体经济、私营经济等非公有制经济的合法的权利和利益。国家鼓励、支持和引导非公有制经济的发展，并对非公有制经济依法实行监督和管理。 第十二条 社会主义的公共财产神圣不可侵犯。 国家保护社会主义的公共财产。禁止任何组织或者个人用任何手段侵占或者破坏国家的和集体的财产。 第十三条 公民的合法的私有财产不受侵犯。 国家依照法律规定保护公民的私有财产权和继承权。 国家为了公共利益的需要，可以依照法律规定对公民的私有财产实行征收或者征用并给予补偿。 第十四条 国家通过提高劳动者的积极性和技术水平，推广先进的科学技术，完善经济管理体制和企业经营管理制度，实行各种形式的社会主义责任制，改进劳动组织，以不断提高劳动生产率和经济效益，发展社会生产力。 国家厉行节约，反对浪费。 国家合理安排积累和消费，兼顾国家、集体和个人的利益，在发展生产的基础上，逐步改善人民的物质生活和文化生活。 国家建立健全同经济发展水平相适应的社会保障制度。 第十五条 国家实行社会主义市场经济。 国家加强经济立法，完善宏观调控。 国家依法禁止任何组织或者个人扰乱社会经济秩序。 第十六条 国有企业在法律规定的范围内有权自主经营。 国有企业依照法律规定，通过职工代表大会和其他形式，实行民主管理。 第十七条 集体经济组织在遵守有关法律的前提下，有独立进行经济活动的自主权。 集体经济组织实行民主管理，依照法律规定选举和罢免管理人员，决定经营管理的重大问题。 第十八条 中华人民共和国允许外国的企业和其他经济组织或者个人依照中华人民共和国法律的规定在中国投资，同中国的企业或者其他经济组织进行各种形式的经济合作。 在中国境内的外国企业和其他外国经济组织以及中外合资经营的企业，都必须遵守中华人民共和国的法律。它们的合法的权利和利益受中华人民共和国法律的保护。 第十九条 国家发展社会主义的教育事业，提高全国人民的科学文化水平。 国家举办各种学校，普及初等义务教育，发展中等教育、职业教育和高等教育，并且发展学前教育。 国家发展各种教育设施，扫除文盲，对工人、农民、国家工作人员和其他劳动者进行政治、文化、科学、技术、业务的教育，鼓励自学成才。 国家鼓励集体经济组织、国家企业事业组织和其他社会力量依照法律规定举办各种教育事业。 国家推广全国通用的普通话。 第二十条 国家发展自然科学和社会科学事业，普及科学和技术知识，奖励科学研究成果和技术发明创造。 第二十一条 国家发展医疗卫生事业，发展现代医药和我国传统医药，鼓励和支持农村集体经济组织、国家企业事业组织和街道组织举办各种医疗卫生设施，开展群众性的卫生活动，保护人民健康。 国家发展体育事业，开展群众性的体育活动，增强人民体质。 第二十二条 国家发展为人民服务、为社会主义服务的文学艺术事业、新闻广播电视事业、出版发行事业、图书馆博物馆文化馆和其他文化事业，开展群众性的文化活动。 国家保护名胜古迹、珍贵文物和其他重要历史文化遗产。 第二十三条 国家培养为社会主义服务的各种专业人才，扩大知识分子的队伍，创造条件，充分发挥他们在社会主义现代化建设中的作用。 第二十四条 国家通过普及理想教育、道德教育、文化教育、纪律和法制教育，通过在城乡不同范围的群众中制定和执行各种守则、公约，加强社会主义精神文明的建设。 国家倡导社会主义核心价值观，提倡爱祖国、爱人民、爱劳动、爱科学、爱社会主义的公德，在人民中进行爱国主义、集体主义和国际主义、共产主义的教育，进行辩证唯物主义和历史唯物主义的教育，反对资本主义的、封建主义的和其他的腐朽思想。 第二十五条 国家推行计划生育，使人口的增长同经济和社会发展计划相适应。 第二十六条 国家保护和改善生活环境和生态环境，防治污染和其他公害。 国家组织和鼓励植树造林，保护林木。 第二十七条 一切国家机关实行精简的原则，实行工作责任制，实行工作人员的培训和考核制度，不断提高工作质量和工作效率，反对官僚主义。 一切国家机关和国家工作人员必须依靠人民的支持，经常保持同人民的密切联系，倾听人民的意见和建议，接受人民的监督，努力为人民服务。 国家工作人员就职时应当依照法律规定公开进行宪法宣誓。 第二十八条 国家维护社会秩序，镇压叛国和其他危害国家安全的犯罪活动，制裁危害社会治安、破坏社会主义经济和其他犯罪的活动，惩办和改造犯罪分子。 第二十九条 中华人民共和国的武装力量属于人民。它的任务是巩固国防，抵抗侵略，保卫祖国，保卫人民的和平劳动，参加国家建设事业，努力为人民服务。 国家加强武装力量的革命化、现代化、正规化的建设，增强国防力量。 第三十条 中华人民共和国的行政区域划分如下： （一）全国分为省、自治区、直辖市； （二）省、自治区分为自治州、县、自治县、市； （三）县、自治县分为乡、民族乡、镇。 直辖市和较大的市分为区、县。自治州分为县、自治县、市。 自治区、自治州、自治县都是民族自治地方。 第三十一条 国家在必要时得设立特别行政区。在特别行政区内实行的制度按照具体情况由全国人民代表大会以法律规定。 第三十二条 中华人民共和国保护在中国境内的外国人的合法权利和利益，在中国境内的外国人必须遵守中华人民共和国的法律。 中华人民共和国对于因为政治原因要求避难的外国人，可以给予受庇护的权利。 第二章 公民的基本权利和义务第三十三条 凡具有中华人民共和国国籍的人都是中华人民共和国公民。 中华人民共和国公民在法律面前一律平等。 国家尊重和保障人权。 任何公民享有宪法和法律规定的权利，同时必须履行宪法和法律规定的义务。 第三十四条 中华人民共和国年满十八周岁的公民，不分民族、种族、性别、职业、家庭出身、宗教信仰、教育程度、财产状况、居住期限，都有选举权和被选举权；但是依照法律被剥夺政治权利的人除外。 第三十五条 中华人民共和国公民有言论、出版、集会、结社、游行、示威的自由。 第三十六条 中华人民共和国公民有宗教信仰自由。 任何国家机关、社会团体和个人不得强制公民信仰宗教或者不信仰宗教，不得歧视信仰宗教的公民和不信仰宗教的公民。 国家保护正常的宗教活动。任何人不得利用宗教进行破坏社会秩序、损害公民身体健康、妨碍国家教育制度的活动。 宗教团体和宗教事务不受外国势力的支配。 第三十七条 中华人民共和国公民的人身自由不受侵犯。 任何公民，非经人民检察院批准或者决定或者人民法院决定，并由公安机关执行，不受逮捕。 禁止非法拘禁和以其他方法非法剥夺或者限制公民的人身自由，禁止非法搜查公民的身体。 第三十八条 中华人民共和国公民的人格尊严不受侵犯。禁止用任何方法对公民进行侮辱、诽谤和诬告陷害。 第三十九条 中华人民共和国公民的住宅不受侵犯。禁止非法搜查或者非法侵入公民的住宅。 第四十条 中华人民共和国公民的通信自由和通信秘密受法律的保护。除因国家安全或者追查刑事犯罪的需要，由公安机关或者检察机关依照法律规定的程序对通信进行检查外，任何组织或者个人不得以任何理由侵犯公民的通信自由和通信秘密。 第四十一条 中华人民共和国公民对于任何国家机关和国家工作人员，有提出批评和建议的权利；对于任何国家机关和国家工作人员的违法失职行为，有向有关国家机关提出申诉、控告或者检举的权利，但是不得捏造或者歪曲事实进行诬告陷害。 对于公民的申诉、控告或者检举，有关国家机关必须查清事实，负责处理。任何人不得压制和打击报复。 由于国家机关和国家工作人员侵犯公民权利而受到损失的人，有依照法律规定取得赔偿的权利。 第四十二条 中华人民共和国公民有劳动的权利和义务。 国家通过各种途径，创造劳动就业条件，加强劳动保护，改善劳动条件，并在发展生产的基础上，提高劳动报酬和福利待遇。 劳动是一切有劳动能力的公民的光荣职责。国有企业和城乡集体经济组织的劳动者都应当以国家主人翁的态度对待自己的劳动。国家提倡社会主义劳动竞赛，奖励劳动模范和先进工作者。国家提倡公民从事义务劳动。 国家对就业前的公民进行必要的劳动就业训练。 第四十三条 中华人民共和国劳动者有休息的权利。 国家发展劳动者休息和休养的设施，规定职工的工作时间和休假制度。 第四十四条 国家依照法律规定实行企业事业组织的职工和国家机关工作人员的退休制度。退休人员的生活受到国家和社会的保障。 第四十五条 中华人民共和国公民在年老、疾病或者丧失劳动能力的情况下，有从国家和社会获得物质帮助的权利。国家发展为公民享受这些权利所需要的社会保险、社会救济和医疗卫生事业。 国家和社会保障残废军人的生活，抚恤烈士家属，优待军人家属。 国家和社会帮助安排盲、聋、哑和其他有残疾的公民的劳动、生活和教育。 第四十六条 中华人民共和国公民有受教育的权利和义务。 国家培养青年、少年、儿童在品德、智力、体质等方面全面发展。 第四十七条 中华人民共和国公民有进行科学研究、文学艺术创作和其他文化活动的自由。国家对于从事教育、科学、技术、文学、艺术和其他文化事业的公民的有益于人民的创造性工作，给以鼓励和帮助。 第四十八条 中华人民共和国妇女在政治的、经济的、文化的、社会的和家庭的生活等各方面享有同男子平等的权利。 国家保护妇女的权利和利益，实行男女同工同酬，培养和选拔妇女干部。 第四十九条 婚姻、家庭、母亲和儿童受国家的保护。 夫妻双方有实行计划生育的义务。 父母有抚养教育未成年子女的义务，成年子女有赡养扶助父母的义务。 禁止破坏婚姻自由，禁止虐待老人、妇女和儿童。 第五十条 中华人民共和国保护华侨的正当的权利和利益，保护归侨和侨眷的合法的权利和利益。 第五十一条 中华人民共和国公民在行使自由和权利的时候，不得损害国家的、社会的、集体的利益和其他公民的合法的自由和权利。 第五十二条 中华人民共和国公民有维护国家统一和全国各民族团结的义务。 第五十三条 中华人民共和国公民必须遵守宪法和法律，保守国家秘密，爱护公共财产，遵守劳动纪律，遵守公共秩序，尊重社会公德。 第五十四条 中华人民共和国公民有维护祖国的安全、荣誉和利益的义务，不得有危害祖国的安全、荣誉和利益的行为。 第五十五条 保卫祖国、抵抗侵略是中华人民共和国每一个公民的神圣职责。 依照法律服兵役和参加民兵组织是中华人民共和国公民的光荣义务。 第五十六条 中华人民共和国公民有依照法律纳税的义务。 第三章 国家机构第五十七条 中华人民共和国全国人民代表大会是最高国家权力机关。它的常设机关是全国人民代表大会常务委员会。 第五十八条 全国人民代表大会和全国人民代表大会常务委员会行使国家立法权。 第五十九条 全国人民代表大会由省、自治区、直辖市、特别行政区和军队选出的代表组成。各少数民族都应当有适当名额的代表。 全国人民代表大会代表的选举由全国人民代表大会常务委员会主持。 全国人民代表大会代表名额和代表产生办法由法律规定。 第六十条 全国人民代表大会每届任期五年。 全国人民代表大会任期届满的两个月以前，全国人民代表大会常务委员会必须完成下届全国人民代表大会代表的选举。如果遇到不能进行选举的非常情况，由全国人民代表大会常务委员会以全体组成人员的三分之二以上的多数通过，可以推迟选举，延长本届全国人民代表大会的任期。在非常情况结束后一年内，必须完成下届全国人民代表大会代表的选举。 第六十一条 全国人民代表大会会议每年举行一次，由全国人民代表大会常务委员会召集。如果全国人民代表大会常务委员会认为必要，或者有五分之一以上的全国人民代表大会代表提议，可以临时召集全国人民代表大会会议。 全国人民代表大会举行会议的时候，选举主席团主持会议。 第六十二条 全国人民代表大会行使下列职权： （一）修改宪法； （二）监督宪法的实施； （三）制定和修改刑事、民事、国家机构的和其他的基本法律； （四）选举中华人民共和国主席、副主席； （五）根据中华人民共和国主席的提名，决定国务院总理的人选；根据国务院总理的提名，决定国务院副总理、国务委员、各部部长、各委员会主任、审计长、秘书长的人选； （六）选举中央军事委员会主席；根据中央军事委员会主席的提名，决定中央军事委员会其他组成人员的人选； （七）选举国家监察委员会主任； （八）选举最高人民法院院长； （九）选举最高人民检察院检察长； （十）审查和批准国民经济和社会发展计划和计划执行情况的报告； （十一）审查和批准国家的预算和预算执行情况的报告； （十二）改变或者撤销全国人民代表大会常务委员会不适当的决定； （十三）批准省、自治区和直辖市的建置； （十四）决定特别行政区的设立及其制度； （十五）决定战争和和平的问题； （十六）应当由最高国家权力机关行使的其他职权。 第六十三条 全国人民代表大会有权罢免下列人员： （一）中华人民共和国主席、副主席； （二）国务院总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长； （三）中央军事委员会主席和中央军事委员会其他组成人员； （四）国家监察委员会主任； （五）最高人民法院院长； （六）最高人民检察院检察长。 第六十四条 宪法的修改，由全国人民代表大会常务委员会或者五分之一以上的全国人民代表大会代表提议，并由全国人民代表大会以全体代表的三分之二以上的多数通过。 法律和其他议案由全国人民代表大会以全体代表的过半数通过。 第六十五条 全国人民代表大会常务委员会由下列人员组成： 委员长， 副委员长若干人， 秘书长， 委员若干人。 全国人民代表大会常务委员会组成人员中，应当有适当名额的少数民族代表。 全国人民代表大会选举并有权罢免全国人民代表大会常务委员会的组成人员。 全国人民代表大会常务委员会的组成人员不得担任国家行政机关、监察机关、审判机关和检察机关的职务。 第六十六条 全国人民代表大会常务委员会每届任期同全国人民代表大会每届任期相同，它行使职权到下届全国人民代表大会选出新的常务委员会为止。 委员长、副委员长连续任职不得超过两届。 第六十七条 全国人民代表大会常务委员会行使下列职权： （一）解释宪法，监督宪法的实施； （二）制定和修改除应当由全国人民代表大会制定的法律以外的其他法律； （三）在全国人民代表大会闭会期间，对全国人民代表大会制定的法律进行部分补充和修改，但是不得同该法律的基本原则相抵触； （四）解释法律； （五）在全国人民代表大会闭会期间，审查和批准国民经济和社会发展计划、国家预算在执行过程中所必须作的部分调整方案； （六）监督国务院、中央军事委员会、国家监察委员会、最高人民法院和最高人民检察院的工作； （七）撤销国务院制定的同宪法、法律相抵触的行政法规、决定和命令； （八）撤销省、自治区、直辖市国家权力机关制定的同宪法、法律和行政法规相抵触的地方性法规和决议； （九）在全国人民代表大会闭会期间，根据国务院总理的提名，决定部长、委员会主任、审计长、秘书长的人选； （十）在全国人民代表大会闭会期间，根据中央军事委员会主席的提名，决定中央军事委员会其他组成人员的人选； （十一）根据国家监察委员会主任的提请，任免国家监察委员会副主任、委员； （十二）根据最高人民法院院长的提请，任免最高人民法院副院长、审判员、审判委员会委员和军事法院院长； （十三）根据最高人民检察院检察长的提请，任免最高人民检察院副检察长、检察员、检察委员会委员和军事检察院检察长，并且批准省、自治区、直辖市的人民检察院检察长的任免； （十四）决定驻外全权代表的任免； （十五）决定同外国缔结的条约和重要协定的批准和废除； （十六）规定军人和外交人员的衔级制度和其他专门衔级制度； （十七）规定和决定授予国家的勋章和荣誉称号； （十八）决定特赦； （十九）在全国人民代表大会闭会期间，如果遇到国家遭受武装侵犯或者必须履行国际间共同防止侵略的条约的情况，决定战争状态的宣布； （二十）决定全国总动员或者局部动员； （二十一）决定全国或者个别省、自治区、直辖市进入紧急状态； （二十二）全国人民代表大会授予的其他职权。 第六十八条 全国人民代表大会常务委员会委员长主持全国人民代表大会常务委员会的工作，召集全国人民代表大会常务委员会会议。副委员长、秘书长协助委员长工作。 委员长、副委员长、秘书长组成委员长会议，处理全国人民代表大会常务委员会的重要日常工作。 第六十九条 全国人民代表大会常务委员会对全国人民代表大会负责并报告工作。 第七十条 全国人民代表大会设立民族委员会、宪法和法律委员会、财政经济委员会、教育科学文化卫生委员会、外事委员会、华侨委员会和其他需要设立的专门委员会。在全国人民代表大会闭会期间，各专门委员会受全国人民代表大会常务委员会的领导。 各专门委员会在全国人民代表大会和全国人民代表大会常务委员会领导下，研究、审议和拟订有关议案。 第七十一条 全国人民代表大会和全国人民代表大会常务委员会认为必要的时候，可以组织关于特定问题的调查委员会，并且根据调查委员会的报告，作出相应的决议。 调查委员会进行调查的时候，一切有关的国家机关、社会团体和公民都有义务向它提供必要的材料。 第七十二条 全国人民代表大会代表和全国人民代表大会常务委员会组成人员，有权依照法律规定的程序分别提出属于全国人民代表大会和全国人民代表大会常务委员会职权范围内的议案。 第七十三条 全国人民代表大会代表在全国人民代表大会开会期间，全国人民代表大会常务委员会组成人员在常务委员会开会期间，有权依照法律规定的程序提出对国务院或者国务院各部、各委员会的质询案。受质询的机关必须负责答复。 第七十四条 全国人民代表大会代表，非经全国人民代表大会会议主席团许可，在全国人民代表大会闭会期间非经全国人民代表大会常务委员会许可，不受逮捕或者刑事审判。 第七十五条 全国人民代表大会代表在全国人民代表大会各种会议上的发言和表决，不受法律追究。 第七十六条 全国人民代表大会代表必须模范地遵守宪法和法律，保守国家秘密，并且在自己参加的生产、工作和社会活动中，协助宪法和法律的实施。 全国人民代表大会代表应当同原选举单位和人民保持密切的联系，听取和反映人民的意见和要求，努力为人民服务。 第七十七条 全国人民代表大会代表受原选举单位的监督。原选举单位有权依照法律规定的程序罢免本单位选出的代表。 第七十八条 全国人民代表大会和全国人民代表大会常务委员会的组织和工作程序由法律规定。 第七十九条 中华人民共和国主席、副主席由全国人民代表大会选举。 有选举权和被选举权的年满四十五周岁的中华人民共和国公民可以被选为中华人民共和国主席、副主席。 中华人民共和国主席、副主席每届任期同全国人民代表大会每届任期相同。 第八十条 中华人民共和国主席根据全国人民代表大会的决定和全国人民代表大会常务委员会的决定，公布法律，任免国务院总理、副总理、国务委员、各部部长、各委员会主任、审计长、秘书长，授予国家的勋章和荣誉称号，发布特赦令，宣布进入紧急状态，宣布战争状态，发布动员令。 第八十一条 中华人民共和国主席代表中华人民共和国，进行国事活动，接受外国使节；根据全国人民代表大会常务委员会的决定，派遣和召回驻外全权代表，批准和废除同外国缔结的条约和重要协定。 第八十二条 中华人民共和国副主席协助主席工作。 中华人民共和国副主席受主席的委托，可以代行主席的部分职权。 第八十三条 中华人民共和国主席、副主席行使职权到下届全国人民代表大会选出的主席、副主席就职为止。 第八十四条 中华人民共和国主席缺位的时候，由副主席继任主席的职位。 中华人民共和国副主席缺位的时候，由全国人民代表大会补选。 中华人民共和国主席、副主席都缺位的时候，由全国人民代表大会补选；在补选以前，由全国人民代表大会常务委员会委员长暂时代理主席职位。 第八十五条 中华人民共和国国务院，即中央人民政府，是最高国家权力机关的执行机关，是最高国家行政机关。 第八十六条 国务院由下列人员组成： 总理， 副总理若干人， 国务委员若干人， 各部部长， 各委员会主任， 审计长， 秘书长。 国务院实行总理负责制。各部、各委员会实行部长、主任负责制。 国务院的组织由法律规定。 第八十七条 国务院每届任期同全国人民代表大会每届任期相同。 总理、副总理、国务委员连续任职不得超过两届。 第八十八条 总理领导国务院的工作。副总理、国务委员协助总理工作。 总理、副总理、国务委员、秘书长组成国务院常务会议。 总理召集和主持国务院常务会议和国务院全体会议。 第八十九条 国务院行使下列职权： （一）根据宪法和法律，规定行政措施，制定行政法规，发布决定和命令； （二）向全国人民代表大会或者全国人民代表大会常务委员会提出议案； （三）规定各部和各委员会的任务和职责，统一领导各部和各委员会的工作，并且领导不属于各部和各委员会的全国性的行政工作； （四）统一领导全国地方各级国家行政机关的工作，规定中央和省、自治区、直辖市的国家行政机关的职权的具体划分； （五）编制和执行国民经济和社会发展计划和国家预算； （六）领导和管理经济工作和城乡建设、生态文明建设； （七）领导和管理教育、科学、文化、卫生、体育和计划生育工作； （八）领导和管理民政、公安、司法行政等工作； （九）管理对外事务，同外国缔结条约和协定； （十）领导和管理国防建设事业； （十一）领导和管理民族事务，保障少数民族的平等权利和民族自治地方的自治权利； （十二）保护华侨的正当的权利和利益，保护归侨和侨眷的合法的权利和利益； （十三）改变或者撤销各部、各委员会发布的不适当的命令、指示和规章； （十四）改变或者撤销地方各级国家行政机关的不适当的决定和命令； （十五）批准省、自治区、直辖市的区域划分，批准自治州、县、自治县、市的建置和区域划分； （十六）依照法律规定决定省、自治区、直辖市的范围内部分地区进入紧急状态； （十七）审定行政机构的编制，依照法律规定任免、培训、考核和奖惩行政人员； （十八）全国人民代表大会和全国人民代表大会常务委员会授予的其他职权。 第九十条 国务院各部部长、各委员会主任负责本部门的工作；召集和主持部务会议或者委员会会议、委务会议，讨论决定本部门工作的重大问题。 各部、各委员会根据法律和国务院的行政法规、决定、命令，在本部门的权限内，发布命令、指示和规章。 第九十一条 国务院设立审计机关，对国务院各部门和地方各级政府的财政收支，对国家的财政金融机构和企业事业组织的财务收支，进行审计监督。 审计机关在国务院总理领导下，依照法律规定独立行使审计监督权，不受其他行政机关、社会团体和个人的干涉。 第九十二条 国务院对全国人民代表大会负责并报告工作；在全国人民代表大会闭会期间，对全国人民代表大会常务委员会负责并报告工作。 第九十三条 中华人民共和国中央军事委员会领导全国武装力量。 中央军事委员会由下列人员组成： 主席， 副主席若干人， 委员若干人。 中央军事委员会实行主席负责制。 中央军事委员会每届任期同全国人民代表大会每届任期相同。 第九十四条 中央军事委员会主席对全国人民代表大会和全国人民代表大会常务委员会负责。 第九十五条 省、直辖市、县、市、市辖区、乡、民族乡、镇设立人民代表大会和人民政府。 地方各级人民代表大会和地方各级人民政府的组织由法律规定。 自治区、自治州、自治县设立自治机关。自治机关的组织和工作根据宪法第三章第五节、第六节规定的基本原则由法律规定。 第九十六条 地方各级人民代表大会是地方国家权力机关。 县级以上的地方各级人民代表大会设立常务委员会。 第九十七条 省、直辖市、设区的市的人民代表大会代表由下一级的人民代表大会选举；县、不设区的市、市辖区、乡、民族乡、镇的人民代表大会代表由选民直接选举。 地方各级人民代表大会代表名额和代表产生办法由法律规定。 第九十八条 地方各级人民代表大会每届任期五年。 第九十九条 地方各级人民代表大会在本行政区域内，保证宪法、法律、行政法规的遵守和执行；依照法律规定的权限，通过和发布决议，审查和决定地方的经济建设、文化建设和公共事业建设的计划。 县级以上的地方各级人民代表大会审查和批准本行政区域内的国民经济和社会发展计划、预算以及它们的执行情况的报告；有权改变或者撤销本级人民代表大会常务委员会不适当的决定。 民族乡的人民代表大会可以依照法律规定的权限采取适合民族特点的具体措施。 第一百条 省、直辖市的人民代表大会和它们的常务委员会，在不同宪法、法律、行政法规相抵触的前提下，可以制定地方性法规，报全国人民代表大会常务委员会备案。 设区的市的人民代表大会和它们的常务委员会，在不同宪法、法律、行政法规和本省、自治区的地方性法规相抵触的前提下，可以依照法律规定制定地方性法规，报本省、自治区人民代表大会常务委员会批准后施行。 第一百零一条 地方各级人民代表大会分别选举并且有权罢免本级人民政府的省长和副省长、市长和副市长、县长和副县长、区长和副区长、乡长和副乡长、镇长和副镇长。 县级以上的地方各级人民代表大会选举并且有权罢免本级监察委员会主任、本级人民法院院长和本级人民检察院检察长。选出或者罢免人民检察院检察长，须报上级人民检察院检察长提请该级人民代表大会常务委员会批准。 第一百零二条 省、直辖市、设区的市的人民代表大会代表受原选举单位的监督；县、不设区的市、市辖区、乡、民族乡、镇的人民代表大会代表受选民的监督。 地方各级人民代表大会代表的选举单位和选民有权依照法律规定的程序罢免由他们选出的代表。 第一百零三条 县级以上的地方各级人民代表大会常务委员会由主任、副主任若干人和委员若干人组成，对本级人民代表大会负责并报告工作。 县级以上的地方各级人民代表大会选举并有权罢免本级人民代表大会常务委员会的组成人员。 县级以上的地方各级人民代表大会常务委员会的组成人员不得担任国家行政机关、监察机关、审判机关和检察机关的职务。 第一百零四条 县级以上的地方各级人民代表大会常务委员会讨论、决定本行政区域内各方面工作的重大事项；监督本级人民政府、监察委员会、人民法院和人民检察院的工作；撤销本级人民政府的不适当的决定和命令；撤销下一级人民代表大会的不适当的决议；依照法律规定的权限决定国家机关工作人员的任免；在本级人民代表大会闭会期间，罢免和补选上一级人民代表大会的个别代表。 第一百零五条 地方各级人民政府是地方各级国家权力机关的执行机关，是地方各级国家行政机关。 地方各级人民政府实行省长、市长、县长、区长、乡长、镇长负责制。 第一百零六条 地方各级人民政府每届任期同本级人民代表大会每届任期相同。 第一百零七条 县级以上地方各级人民政府依照法律规定的权限，管理本行政区域内的经济、教育、科学、文化、卫生、体育事业、城乡建设事业和财政、民政、公安、民族事务、司法行政、计划生育等行政工作，发布决定和命令，任免、培训、考核和奖惩行政工作人员。 乡、民族乡、镇的人民政府执行本级人民代表大会的决议和上级国家行政机关的决定和命令，管理本行政区域内的行政工作。 省、直辖市的人民政府决定乡、民族乡、镇的建置和区域划分。 第一百零八条 县级以上的地方各级人民政府领导所属各工作部门和下级人民政府的工作，有权改变或者撤销所属各工作部门和下级人民政府的不适当的决定。 第一百零九条 县级以上的地方各级人民政府设立审计机关。地方各级审计机关依照法律规定独立行使审计监督权，对本级人民政府和上一级审计机关负责。 第一百一十条 地方各级人民政府对本级人民代表大会负责并报告工作。县级以上的地方各级人民政府在本级人民代表大会闭会期间，对本级人民代表大会常务委员会负责并报告工作。 地方各级人民政府对上一级国家行政机关负责并报告工作。全国地方各级人民政府都是国务院统一领导下的国家行政机关，都服从国务院。 第一百一十一条 城市和农村按居民居住地区设立的居民委员会或者村民委员会是基层群众性自治组织。居民委员会、村民委员会的主任、副主任和委员由居民选举。居民委员会、村民委员会同基层政权的相互关系由法律规定。 居民委员会、村民委员会设人民调解、治安保卫、公共卫生等委员会，办理本居住地区的公共事务和公益事业，调解民间纠纷，协助维护社会治安，并且向人民政府反映群众的意见、要求和提出建议。 第一百一十二条 民族自治地方的自治机关是自治区、自治州、自治县的人民代表大会和人民政府。 第一百一十三条 自治区、自治州、自治县的人民代表大会中，除实行区域自治的民族的代表外，其他居住在本行政区域内的民族也应当有适当名额的代表。 自治区、自治州、自治县的人民代表大会常务委员会中应当有实行区域自治的民族的公民担任主任或者副主任。 第一百一十四条 自治区主席、自治州州长、自治县县长由实行区域自治的民族的公民担任。 第一百一十五条 自治区、自治州、自治县的自治机关行使宪法第三章第五节规定的地方国家机关的职权，同时依照宪法、民族区域自治法和其他法律规定的权限行使自治权，根据本地方实际情况贯彻执行国家的法律、政策。 第一百一十六条 民族自治地方的人民代表大会有权依照当地民族的政治、经济和文化的特点，制定自治条例和单行条例。自治区的自治条例和单行条例，报全国人民代表大会常务委员会批准后生效。自治州、自治县的自治条例和单行条例，报省或者自治区的人民代表大会常务委员会批准后生效，并报全国人民代表大会常务委员会备案。 第一百一十七条 民族自治地方的自治机关有管理地方财政的自治权。凡是依照国家财政体制属于民族自治地方的财政收入，都应当由民族自治地方的自治机关自主地安排使用。 第一百一十八条 民族自治地方的自治机关在国家计划的指导下，自主地安排和管理地方性的经济建设事业。 国家在民族自治地方开发资源、建设企业的时候，应当照顾民族自治地方的利益。 第一百一十九条 民族自治地方的自治机关自主地管理本地方的教育、科学、文化、卫生、体育事业，保护和整理民族的文化遗产，发展和繁荣民族文化。 第一百二十条 民族自治地方的自治机关依照国家的军事制度和当地的实际需要，经国务院批准，可以组织本地方维护社会治安的公安部队。 第一百二十一条 民族自治地方的自治机关在执行职务的时候，依照本民族自治地方自治条例的规定，使用当地通用的一种或者几种语言文字。 第一百二十二条 国家从财政、物资、技术等方面帮助各少数民族加速发展经济建设和文化建设事业。 国家帮助民族自治地方从当地民族中大量培养各级干部、各种专业人才和技术工人。 第一百二十三条 中华人民共和国各级监察委员会是国家的监察机关。 第一百二十四条 中华人民共和国设立国家监察委员会和地方各级监察委员会。 监察委员会由下列人员组成： 主任， 副主任若干人， 委员若干人。 监察委员会主任每届任期同本级人民代表大会每届任期相同。国家监察委员会主任连续任职不得超过两届。 监察委员会的组织和职权由法律规定。 第一百二十五条 中华人民共和国国家监察委员会是最高监察机关。 国家监察委员会领导地方各级监察委员会的工作，上级监察委员会领导下级监察委员会的工作。 第一百二十六条 国家监察委员会对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级监察委员会对产生它的国家权力机关和上一级监察委员会负责。 第一百二十七条 监察委员会依照法律规定独立行使监察权，不受行政机关、社会团体和个人的干涉。 监察机关办理职务违法和职务犯罪案件，应当与审判机关、检察机关、执法部门互相配合，互相制约。 第一百二十八条 中华人民共和国人民法院是国家的审判机关。 第一百二十九条 中华人民共和国设立最高人民法院、地方各级人民法院和军事法院等专门人民法院。 最高人民法院院长每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。 人民法院的组织由法律规定。 第一百三十条 人民法院审理案件，除法律规定的特别情况外，一律公开进行。被告人有权获得辩护。 第一百三十一条 人民法院依照法律规定独立行使审判权，不受行政机关、社会团体和个人的干涉。 第一百三十二条 最高人民法院是最高审判机关。 最高人民法院监督地方各级人民法院和专门人民法院的审判工作，上级人民法院监督下级人民法院的审判工作。 第一百三十三条 最高人民法院对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级人民法院对产生它的国家权力机关负责。 第一百三十四条 中华人民共和国人民检察院是国家的法律监督机关。 第一百三十五条 中华人民共和国设立最高人民检察院、地方各级人民检察院和军事检察院等专门人民检察院。 最高人民检察院检察长每届任期同全国人民代表大会每届任期相同，连续任职不得超过两届。 人民检察院的组织由法律规定。 第一百三十六条 人民检察院依照法律规定独立行使检察权，不受行政机关、社会团体和个人的干涉。 第一百三十七条 最高人民检察院是最高检察机关。 最高人民检察院领导地方各级人民检察院和专门人民检察院的工作，上级人民检察院领导下级人民检察院的工作。 第一百三十八条 最高人民检察院对全国人民代表大会和全国人民代表大会常务委员会负责。地方各级人民检察院对产生它的国家权力机关和上级人民检察院负责。 第一百三十九条 各民族公民都有用本民族语言文字进行诉讼的权利。人民法院和人民检察院对于不通晓当地通用的语言文字的诉讼参与人，应当为他们翻译。 在少数民族聚居或者多民族共同居住的地区，应当用当地通用的语言进行审理；起诉书、判决书、布告和其他文书应当根据实际需要使用当地通用的一种或者几种文字。 第一百四十条 人民法院、人民检察院和公安机关办理刑事案件，应当分工负责，互相配合，互相制约，以保证准确有效地执行法律。 第四章 国旗、国歌、国徽、首都第一百四十一条 中华人民共和国国旗是五星红旗。 中华人民共和国国歌是《义勇军进行曲》。 第一百四十二条 中华人民共和国国徽，中间是五星照耀下的天安门，周围是谷穗和齿轮。 第一百四十三条 中华人民共和国首都是北京。","link":"/posts/bdeb1d7c/"},{"title":"中华人民共和国刑事诉讼法","text":"基本信息 发文字号：中华人民共和国主席令第十号 效力级别法律：时效性现行有效 发布日期：2018-10-26 实施日期：2018-10-26 发布机关：全国人大常委会 法律修订 1979年7月1日第五届全国人民代表大会第二次会议通过 根据1996年3月17日第八届全国人民代表大会第四次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第一次修正 根据2012年3月14日第十一届全国人民代表大会第五次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第二次修正 根据2018年10月26日第十三届全国人民代表大会常务委员会第六次会议《关于修改〈中华人民共和国刑事诉讼法〉的决定》第三次修正 中华人民共和国刑事诉讼法（2012修正） 中华人民共和国刑事诉讼法（1996修正） 中华人民共和国刑事诉讼法（1979修正） 正文 第一编 总 则第一章 任务和基本原则第一条 为了保证刑法的正确实施，惩罚犯罪，保护人民，保障国家安全和社会公共安全，维护社会主义社会秩序，根据宪法，制定本法。 第二条 中华人民共和国刑事诉讼法的任务，是保证准确、及时地查明犯罪事实，正确应用法律，惩罚犯罪分子，保障无罪的人不受刑事追究，教育公民自觉遵守法律，积极同犯罪行为作斗争，维护社会主义法制，尊重和保障人权，保护公民的人身权利、财产权利、民主权利和其他权利，保障社会主义建设事业的顺利进行。 第三条 对刑事案件的侦查、拘留、执行逮捕、预审，由公安机关负责。检察、批准逮捕、检察机关直接受理的案件的侦查、提起公诉，由人民检察院负责。审判由人民法院负责。除法律特别规定的以外，其他任何机关、团体和个人都无权行使这些权力。 人民法院、人民检察院和公安机关进行刑事诉讼，必须严格遵守本法和其他法律的有关规定。 第四条 国家安全机关依照法律规定，办理危害国家安全的刑事案件，行使与公安机关相同的职权。 第五条 人民法院依照法律规定独立行使审判权，人民检察院依照法律规定独立行使检察权，不受行政机关、社会团体和个人的干涉。 第六条 人民法院、人民检察院和公安机关进行刑事诉讼，必须依靠群众，必须以事实为根据，以法律为准绳。对于一切公民，在适用法律上一律平等，在法律面前，不允许有任何特权。 第七条 人民法院、人民检察院和公安机关进行刑事诉讼，应当分工负责，互相配合，互相制约，以保证准确有效地执行法律。 第八条 人民检察院依法对刑事诉讼实行法律监督。 第九条 各民族公民都有用本民族语言文字进行诉讼的权利。人民法院、人民检察院和公安机关对于不通晓当地通用的语言文字的诉讼参与人，应当为他们翻译。 在少数民族聚居或者多民族杂居的地区，应当用当地通用的语言进行审讯，用当地通用的文字发布判决书、布告和其他文件。 第十条 人民法院审判案件，实行两审终审制。 第十一条 人民法院审判案件，除本法另有规定的以外，一律公开进行。被告人有权获得辩护，人民法院有义务保证被告人获得辩护。 第十二条 未经人民法院依法判决，对任何人都不得确定有罪。 第十三条 人民法院审判案件，依照本法实行人民陪审员陪审的制度。 第十四条 人民法院、人民检察院和公安机关应当保障犯罪嫌疑人、被告人和其他诉讼参与人依法享有的辩护权和其他诉讼权利。 诉讼参与人对于审判人员、检察人员和侦查人员侵犯公民诉讼权利和人身侮辱的行为，有权提出控告。 第十五条 犯罪嫌疑人、被告人自愿如实供述自己的罪行，承认指控的犯罪事实，愿意接受处罚的，可以依法从宽处理。 第十六条 有下列情形之一的，不追究刑事责任，已经追究的，应当撤销案件，或者不起诉，或者终止审理，或者宣告无罪： （一）情节显著轻微、危害不大，不认为是犯罪的； （二）犯罪已过追诉时效期限的； （三）经特赦令免除刑罚的； （四）依照刑法告诉才处理的犯罪，没有告诉或者撤回告诉的； （五）犯罪嫌疑人、被告人死亡的； （六）其他法律规定免予追究刑事责任的。 第十七条 对于外国人犯罪应当追究刑事责任的，适用本法的规定。 对于享有外交特权和豁免权的外国人犯罪应当追究刑事责任的，通过外交途径解决。 第十八条 根据中华人民共和国缔结或者参加的国际条约，或者按照互惠原则，我国司法机关和外国司法机关可以相互请求刑事司法协助。 第二章 管 辖第十九条 刑事案件的侦查由公安机关进行，法律另有规定的除外。 人民检察院在对诉讼活动实行法律监督中发现的司法工作人员利用职权实施的非法拘禁、刑讯逼供、非法搜查等侵犯公民权利、损害司法公正的犯罪，可以由人民检察院立案侦查。对于公安机关管辖的国家机关工作人员利用职权实施的重大犯罪案件，需要由人民检察院直接受理的时候，经省级以上人民检察院决定，可以由人民检察院立案侦查。 自诉案件，由人民法院直接受理。 第二十条 基层人民法院管辖第一审普通刑事案件，但是依照本法由上级人民法院管辖的除外。 第二十一条 中级人民法院管辖下列第一审刑事案件： （一）危害国家安全、恐怖活动案件； （二）可能判处无期徒刑、死刑的案件。 第二十二条 高级人民法院管辖的第一审刑事案件，是全省（自治区、直辖市）性的重大刑事案件。 第二十三条 最高人民法院管辖的第一审刑事案件，是全国性的重大刑事案件。 第二十四条 上级人民法院在必要的时候，可以审判下级人民法院管辖的第一审刑事案件；下级人民法院认为案情重大、复杂需要由上级人民法院审判的第一审刑事案件，可以请求移送上一级人民法院审判。 第二十五条 刑事案件由犯罪地的人民法院管辖。如果由被告人居住地的人民法院审判更为适宜的，可以由被告人居住地的人民法院管辖。 第二十六条 几个同级人民法院都有权管辖的案件，由最初受理的人民法院审判。在必要的时候，可以移送主要犯罪地的人民法院审判。 第二十七条 上级人民法院可以指定下级人民法院审判管辖不明的案件，也可以指定下级人民法院将案件移送其他人民法院审判。 第二十八条 专门人民法院案件的管辖另行规定。 第三章 回 避第二十九条 审判人员、检察人员、侦查人员有下列情形之一的，应当自行回避，当事人及其法定代理人也有权要求他们回避： （一）是本案的当事人或者是当事人的近亲属的； （二）本人或者他的近亲属和本案有利害关系的； （三）担任过本案的证人、鉴定人、辩护人、诉讼代理人的； （四）与本案当事人有其他关系，可能影响公正处理案件的。 第三十条 审判人员、检察人员、侦查人员不得接受当事人及其委托的人的请客送礼，不得违反规定会见当事人及其委托的人。 审判人员、检察人员、侦查人员违反前款规定的，应当依法追究法律责任。当事人及其法定代理人有权要求他们回避。 第三十一条 审判人员、检察人员、侦查人员的回避，应当分别由院长、检察长、公安机关负责人决定；院长的回避，由本院审判委员会决定；检察长和公安机关负责人的回避，由同级人民检察院检察委员会决定。 对侦查人员的回避作出决定前，侦查人员不能停止对案件的侦查。 对驳回申请回避的决定，当事人及其法定代理人可以申请复议一次。 第三十二条 本章关于回避的规定适用于书记员、翻译人员和鉴定人。 辩护人、诉讼代理人可以依照本章的规定要求回避、申请复议。 第四章 辩护与代理第三十三条 犯罪嫌疑人、被告人除自己行使辩护权以外，还可以委托一至二人作为辩护人。下列的人可以被委托为辩护人： （一）律师； （二）人民团体或者犯罪嫌疑人、被告人所在单位推荐的人； （三）犯罪嫌疑人、被告人的监护人、亲友。 正在被执行刑罚或者依法被剥夺、限制人身自由的人，不得担任辩护人。 被开除公职和被吊销律师、公证员执业证书的人，不得担任辩护人，但系犯罪嫌疑人、被告人的监护人、近亲属的除外。 第三十四条 犯罪嫌疑人自被侦查机关第一次讯问或者采取强制措施之日起，有权委托辩护人；在侦查期间，只能委托律师作为辩护人。被告人有权随时委托辩护人。 侦查机关在第一次讯问犯罪嫌疑人或者对犯罪嫌疑人采取强制措施的时候，应当告知犯罪嫌疑人有权委托辩护人。人民检察院自收到移送审查起诉的案件材料之日起三日以内，应当告知犯罪嫌疑人有权委托辩护人。人民法院自受理案件之日起三日以内，应当告知被告人有权委托辩护人。犯罪嫌疑人、被告人在押期间要求委托辩护人的，人民法院、人民检察院和公安机关应当及时转达其要求。 犯罪嫌疑人、被告人在押的，也可以由其监护人、近亲属代为委托辩护人。 辩护人接受犯罪嫌疑人、被告人委托后，应当及时告知办理案件的机关。 第三十五条 犯罪嫌疑人、被告人因经济困难或者其他原因没有委托辩护人的，本人及其近亲属可以向法律援助机构提出申请。对符合法律援助条件的，法律援助机构应当指派律师为其提供辩护。 犯罪嫌疑人、被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人，没有委托辩护人的，人民法院、人民检察院和公安机关应当通知法律援助机构指派律师为其提供辩护。 犯罪嫌疑人、被告人可能被判处无期徒刑、死刑，没有委托辩护人的，人民法院、人民检察院和公安机关应当通知法律援助机构指派律师为其提供辩护。 第三十六条 法律援助机构可以在人民法院、看守所等场所派驻值班律师。犯罪嫌疑人、被告人没有委托辩护人，法律援助机构没有指派律师为其提供辩护的，由值班律师为犯罪嫌疑人、被告人提供法律咨询、程序选择建议、申请变更强制措施、对案件处理提出意见等法律帮助。 人民法院、人民检察院、看守所应当告知犯罪嫌疑人、被告人有权约见值班律师，并为犯罪嫌疑人、被告人约见值班律师提供便利。 第三十七条 辩护人的责任是根据事实和法律，提出犯罪嫌疑人、被告人无罪、罪轻或者减轻、免除其刑事责任的材料和意见，维护犯罪嫌疑人、被告人的诉讼权利和其他合法权益。 第三十八条 辩护律师在侦查期间可以为犯罪嫌疑人提供法律帮助；代理申诉、控告；申请变更强制措施；向侦查机关了解犯罪嫌疑人涉嫌的罪名和案件有关情况，提出意见。 第三十九条 辩护律师可以同在押的犯罪嫌疑人、被告人会见和通信。其他辩护人经人民法院、人民检察院许可，也可以同在押的犯罪嫌疑人、被告人会见和通信。 辩护律师持律师执业证书、律师事务所证明和委托书或者法律援助公函要求会见在押的犯罪嫌疑人、被告人的，看守所应当及时安排会见，至迟不得超过四十八小时。 危害国家安全犯罪、恐怖活动犯罪案件，在侦查期间辩护律师会见在押的犯罪嫌疑人，应当经侦查机关许可。上述案件，侦查机关应当事先通知看守所。 辩护律师会见在押的犯罪嫌疑人、被告人，可以了解案件有关情况，提供法律咨询等；自案件移送审查起诉之日起，可以向犯罪嫌疑人、被告人核实有关证据。辩护律师会见犯罪嫌疑人、被告人时不被监听。 辩护律师同被监视居住的犯罪嫌疑人、被告人会见、通信，适用第一款、第三款、第四款的规定。 第四十条 辩护律师自人民检察院对案件审查起诉之日起，可以查阅、摘抄、复制本案的案卷材料。其他辩护人经人民法院、人民检察院许可，也可以查阅、摘抄、复制上述材料。 第四十一条 辩护人认为在侦查、审查起诉期间公安机关、人民检察院收集的证明犯罪嫌疑人、被告人无罪或者罪轻的证据材料未提交的，有权申请人民检察院、人民法院调取。 第四十二条 辩护人收集的有关犯罪嫌疑人不在犯罪现场、未达到刑事责任年龄、属于依法不负刑事责任的精神病人的证据，应当及时告知公安机关、人民检察院。 第四十三条 辩护律师经证人或者其他有关单位和个人同意，可以向他们收集与本案有关的材料，也可以申请人民检察院、人民法院收集、调取证据，或者申请人民法院通知证人出庭作证。 辩护律师经人民检察院或者人民法院许可，并且经被害人或者其近亲属、被害人提供的证人同意，可以向他们收集与本案有关的材料。 第四十四条 辩护人或者其他任何人，不得帮助犯罪嫌疑人、被告人隐匿、毁灭、伪造证据或者串供，不得威胁、引诱证人作伪证以及进行其他干扰司法机关诉讼活动的行为。 违反前款规定的，应当依法追究法律责任，辩护人涉嫌犯罪的，应当由办理辩护人所承办案件的侦查机关以外的侦查机关办理。辩护人是律师的，应当及时通知其所在的律师事务所或者所属的律师协会。 第四十五条 在审判过程中，被告人可以拒绝辩护人继续为他辩护，也可以另行委托辩护人辩护。 第四十六条 公诉案件的被害人及其法定代理人或者近亲属，附带民事诉讼的当事人及其法定代理人，自案件移送审查起诉之日起，有权委托诉讼代理人。自诉案件的自诉人及其法定代理人，附带民事诉讼的当事人及其法定代理人，有权随时委托诉讼代理人。 人民检察院自收到移送审查起诉的案件材料之日起三日以内，应当告知被害人及其法定代理人或者其近亲属、附带民事诉讼的当事人及其法定代理人有权委托诉讼代理人。人民法院自受理自诉案件之日起三日以内，应当告知自诉人及其法定代理人、附带民事诉讼的当事人及其法定代理人有权委托诉讼代理人。 第四十七条 委托诉讼代理人，参照本法第三十三条的规定执行。 第四十八条 辩护律师对在执业活动中知悉的委托人的有关情况和信息，有权予以保密。但是，辩护律师在执业活动中知悉委托人或者其他人，准备或者正在实施危害国家安全、公共安全以及严重危害他人人身安全的犯罪的，应当及时告知司法机关。 第四十九条 辩护人、诉讼代理人认为公安机关、人民检察院、人民法院及其工作人员阻碍其依法行使诉讼权利的，有权向同级或者上一级人民检察院申诉或者控告。人民检察院对申诉或者控告应当及时进行审查，情况属实的，通知有关机关予以纠正。 第五章 证 据第五十条 可以用于证明案件事实的材料，都是证据。 证据包括： （一）物证； （二）书证； （三）证人证言； （四）被害人陈述； （五）犯罪嫌疑人、被告人供述和辩解； （六）鉴定意见； （七）勘验、检查、辨认、侦查实验等笔录； （八）视听资料、电子数据。 证据必须经过查证属实，才能作为定案的根据。 第五十一条 公诉案件中被告人有罪的举证责任由人民检察院承担，自诉案件中被告人有罪的举证责任由自诉人承担。 第五十二条 审判人员、检察人员、侦查人员必须依照法定程序，收集能够证实犯罪嫌疑人、被告人有罪或者无罪、犯罪情节轻重的各种证据。严禁刑讯逼供和以威胁、引诱、欺骗以及其他非法方法收集证据，不得强迫任何人证实自己有罪。必须保证一切与案件有关或者了解案情的公民，有客观地充分地提供证据的条件，除特殊情况外，可以吸收他们协助调查。 第五十三条 公安机关提请批准逮捕书、人民检察院起诉书、人民法院判决书，必须忠实于事实真象。故意隐瞒事实真象的，应当追究责任。 第五十四条 人民法院、人民检察院和公安机关有权向有关单位和个人收集、调取证据。有关单位和个人应当如实提供证据。 行政机关在行政执法和查办案件过程中收集的物证、书证、视听资料、电子数据等证据材料，在刑事诉讼中可以作为证据使用。 对涉及国家秘密、商业秘密、个人隐私的证据，应当保密。 凡是伪造证据、隐匿证据或者毁灭证据的，无论属于何方，必须受法律追究。 第五十五条 对一切案件的判处都要重证据，重调查研究，不轻信口供。只有被告人供述，没有其他证据的，不能认定被告人有罪和处以刑罚；没有被告人供述，证据确实、充分的，可以认定被告人有罪和处以刑罚。 证据确实、充分，应当符合以下条件： （一）定罪量刑的事实都有证据证明； （二）据以定案的证据均经法定程序查证属实； （三）综合全案证据，对所认定事实已排除合理怀疑。 第五十六条 采用刑讯逼供等非法方法收集的犯罪嫌疑人、被告人供述和采用暴力、威胁等非法方法收集的证人证言、被害人陈述，应当予以排除。收集物证、书证不符合法定程序，可能严重影响司法公正的，应当予以补正或者作出合理解释；不能补正或者作出合理解释的，对该证据应当予以排除。 在侦查、审查起诉、审判时发现有应当排除的证据的，应当依法予以排除，不得作为起诉意见、起诉决定和判决的依据。 第五十七条 人民检察院接到报案、控告、举报或者发现侦查人员以非法方法收集证据的，应当进行调查核实。对于确有以非法方法收集证据情形的，应当提出纠正意见；构成犯罪的，依法追究刑事责任。 第五十八条 法庭审理过程中，审判人员认为可能存在本法第五十六条规定的以非法方法收集证据情形的，应当对证据收集的合法性进行法庭调查。 当事人及其辩护人、诉讼代理人有权申请人民法院对以非法方法收集的证据依法予以排除。申请排除以非法方法收集的证据的，应当提供相关线索或者材料。 第五十九条 在对证据收集的合法性进行法庭调查的过程中，人民检察院应当对证据收集的合法性加以证明。 现有证据材料不能证明证据收集的合法性的，人民检察院可以提请人民法院通知有关侦查人员或者其他人员出庭说明情况；人民法院可以通知有关侦查人员或者其他人员出庭说明情况。有关侦查人员或者其他人员也可以要求出庭说明情况。经人民法院通知，有关人员应当出庭。 第六十条 对于经过法庭审理，确认或者不能排除存在本法第五十六条规定的以非法方法收集证据情形的，对有关证据应当予以排除。 第六十一条 证人证言必须在法庭上经过公诉人、被害人和被告人、辩护人双方质证并且查实以后，才能作为定案的根据。法庭查明证人有意作伪证或者隐匿罪证的时候，应当依法处理。 第六十二条 凡是知道案件情况的人，都有作证的义务。 生理上、精神上有缺陷或者年幼，不能辨别是非、不能正确表达的人，不能作证人。 第六十三条 人民法院、人民检察院和公安机关应当保障证人及其近亲属的安全。 对证人及其近亲属进行威胁、侮辱、殴打或者打击报复，构成犯罪的，依法追究刑事责任；尚不够刑事处罚的，依法给予治安管理处罚。 第六十四条 对于危害国家安全犯罪、恐怖活动犯罪、黑社会性质的组织犯罪、毒品犯罪等案件，证人、鉴定人、被害人因在诉讼中作证，本人或者其近亲属的人身安全面临危险的，人民法院、人民检察院和公安机关应当采取以下一项或者多项保护措施： （一）不公开真实姓名、住址和工作单位等个人信息； （二）采取不暴露外貌、真实声音等出庭作证措施； （三）禁止特定的人员接触证人、鉴定人、被害人及其近亲属； （四）对人身和住宅采取专门性保护措施； （五）其他必要的保护措施。 证人、鉴定人、被害人认为因在诉讼中作证，本人或者其近亲属的人身安全面临危险的，可以向人民法院、人民检察院、公安机关请求予以保护。 人民法院、人民检察院、公安机关依法采取保护措施，有关单位和个人应当配合。 第六十五条 证人因履行作证义务而支出的交通、住宿、就餐等费用，应当给予补助。证人作证的补助列入司法机关业务经费，由同级政府财政予以保障。 有工作单位的证人作证，所在单位不得克扣或者变相克扣其工资、奖金及其他福利待遇。 第六章 强制措施第六十六条 人民法院、人民检察院和公安机关根据案件情况，对犯罪嫌疑人、被告人可以拘传、取保候审或者监视居住。 第六十七条 人民法院、人民检察院和公安机关对有下列情形之一的犯罪嫌疑人、被告人，可以取保候审： （一）可能判处管制、拘役或者独立适用附加刑的； （二）可能判处有期徒刑以上刑罚，采取取保候审不致发生社会危险性的； （三）患有严重疾病、生活不能自理，怀孕或者正在哺乳自己婴儿的妇女，采取取保候审不致发生社会危险性的； （四）羁押期限届满，案件尚未办结，需要采取取保候审的。 取保候审由公安机关执行。 第六十八条 人民法院、人民检察院和公安机关决定对犯罪嫌疑人、被告人取保候审，应当责令犯罪嫌疑人、被告人提出保证人或者交纳保证金。 第六十九条 保证人必须符合下列条件： （一）与本案无牵连； （二）有能力履行保证义务； （三）享有政治权利，人身自由未受到限制； （四）有固定的住处和收入。 第七十条 保证人应当履行以下义务： （一）监督被保证人遵守本法第七十一条的规定； （二）发现被保证人可能发生或者已经发生违反本法第七十一条规定的行为的，应当及时向执行机关报告。 被保证人有违反本法第七十一条规定的行为，保证人未履行保证义务的，对保证人处以罚款，构成犯罪的，依法追究刑事责任。 第七十一条 被取保候审的犯罪嫌疑人、被告人应当遵守以下规定： （一）未经执行机关批准不得离开所居住的市、县； （二）住址、工作单位和联系方式发生变动的，在二十四小时以内向执行机关报告； （三）在传讯的时候及时到案； （四）不得以任何形式干扰证人作证； （五）不得毁灭、伪造证据或者串供。 人民法院、人民检察院和公安机关可以根据案件情况，责令被取保候审的犯嫌疑人、被告人遵守以下一项或者多项规定： （一）不得进入特定的场所； （二）不得与特定的人员会见或者通信； （三）不得从事特定的活动； （四）将护照等出入境证件、驾驶证件交执行机关保存。 被取保候审的犯罪嫌疑人、被告人违反前两款规定，已交纳保证金的，没收部分或者全部保证金，并且区别情形，责令犯罪嫌疑人、被告人具结悔过，重新交纳保证金、提出保证人，或者监视居住、予以逮捕。 对违反取保候审规定，需要予以逮捕的，可以对犯罪嫌疑人、被告人先行拘留。 第七十二条 取保候审的决定机关应当综合考虑保证诉讼活动正常进行的需要，被取保候审人的社会危险性，案件的性质、情节，可能判处刑罚的轻重，被取保候审人的经济状况等情况，确定保证金的数额。 提供保证金的人应当将保证金存入执行机关指定银行的专门账户。 第七十三条 犯罪嫌疑人、被告人在取保候审期间未违反本法第七十一条规定的，取保候审结束的时候，凭解除取保候审的通知或者有关法律文书到银行领取退还的保证金。 第七十四条 人民法院、人民检察院和公安机关对符合逮捕条件，有下列情形之一的犯罪嫌疑人、被告人，可以监视居住： （一）患有严重疾病、生活不能自理的； （二）怀孕或者正在哺乳自己婴儿的妇女； （三）系生活不能自理的人的唯一扶养人； （四）因为案件的特殊情况或者办理案件的需要，采取监视居住措施更为适宜的； （五）羁押期限届满，案件尚未办结，需要采取监视居住措施的。 对符合取保候审条件，但犯罪嫌疑人、被告人不能提出保证人，也不交纳保证金的，可以监视居住。 监视居住由公安机关执行。 第七十五条 监视居住应当在犯罪嫌疑人、被告人的住处执行；无固定住处的，可以在指定的居所执行。对于涉嫌危害国家安全犯罪、恐怖活动犯罪，在住处执行可能有碍侦查的，经上一级公安机关批准，也可以在指定的居所执行。但是，不得在羁押场所、专门的办案场所执行。 指定居所监视居住的，除无法通知的以外，应当在执行监视居住后二十四小时以内，通知被监视居住人的家属。 被监视居住的犯罪嫌疑人、被告人委托辩护人，适用本法第三十四条的规定。 人民检察院对指定居所监视居住的决定和执行是否合法实行监督。 第七十六条 指定居所监视居住的期限应当折抵刑期。被判处管制的，监视居住一日折抵刑期一日；被判处拘役、有期徒刑的，监视居住二日折抵刑期一日。 第七十七条 被监视居住的犯罪嫌疑人、被告人应当遵守以下规定： （一）未经执行机关批准不得离开执行监视居住的处所； （二）未经执行机关批准不得会见他人或者通信； （三）在传讯的时候及时到案； （四）不得以任何形式干扰证人作证； （五）不得毁灭、伪造证据或者串供； （六）将护照等出入境证件、身份证件、驾驶证件交执行机关保存。 被监视居住的犯罪嫌疑人、被告人违反前款规定，情节严重的，可以予以逮捕；需要予以逮捕的，可以对犯罪嫌疑人、被告人先行拘留。 第七十八条 执行机关对被监视居住的犯罪嫌疑人、被告人，可以采取电子监控、不定期检查等监视方法对其遵守监视居住规定的情况进行监督；在侦查期间，可以对被监视居住的犯罪嫌疑人的通信进行监控。 第七十九条 人民法院、人民检察院和公安机关对犯罪嫌疑人、被告人取保候审最长不得超过十二个月，监视居住最长不得超过六个月。 在取保候审、监视居住期间，不得中断对案件的侦查、起诉和审理。对于发现不应当追究刑事责任或者取保候审、监视居住期限届满的，应当及时解除取保候审、监视居住。解除取保候审、监视居住，应当及时通知被取保候审、监视居住人和有关单位。 第八十条 逮捕犯罪嫌疑人、被告人，必须经过人民检察院批准或者人民法院决定，由公安机关执行。 第八十一条 对有证据证明有犯罪事实，可能判处徒刑以上刑罚的犯罪嫌疑人、被告人，采取取保候审尚不足以防止发生下列社会危险性的，应当予以逮捕： （一）可能实施新的犯罪的； （二）有危害国家安全、公共安全或者社会秩序的现实危险的； （三）可能毁灭、伪造证据，干扰证人作证或者串供的； （四）可能对被害人、举报人、控告人实施打击报复的； （五）企图自杀或者逃跑的。 批准或者决定逮捕，应当将犯罪嫌疑人、被告人涉嫌犯罪的性质、情节，认罪认罚等情况，作为是否可能发生社会危险性的考虑因素。 对有证据证明有犯罪事实，可能判处十年有期徒刑以上刑罚的，或者有证据证明有犯罪事实，可能判处徒刑以上刑罚，曾经故意犯罪或者身份不明的，应当予以逮捕。 被取保候审、监视居住的犯罪嫌疑人、被告人违反取保候审、监视居住规定，情节严重的，可以予以逮捕。 第八十二条 公安机关对于现行犯或者重大嫌疑分子，如果有下列情形之一的，可以先行拘留： （一）正在预备犯罪、实行犯罪或者在犯罪后即时被发觉的； （二）被害人或者在场亲眼看见的人指认他犯罪的； （三）在身边或者住处发现有犯罪证据的； （四）犯罪后企图自杀、逃跑或者在逃的； （五）有毁灭、伪造证据或者串供可能的； （六）不讲真实姓名、住址，身份不明的； （七）有流窜作案、多次作案、结伙作案重大嫌疑的。 第八十三条 公安机关在异地执行拘留、逮捕的时候，应当通知被拘留、逮捕人所在地的公安机关，被拘留、逮捕人所在地的公安机关应当予以配合。 第八十四条 对于有下列情形的人，任何公民都可以立即扭送公安机关、人民检察院或者人民法院处理： （一）正在实行犯罪或者在犯罪后即时被发觉的； （二）通缉在案的； （三）越狱逃跑的； （四）正在被追捕的。 第八十五条 公安机关拘留人的时候，必须出示拘留证。 拘留后，应当立即将被拘留人送看守所羁押，至迟不得超过二十四小时。除无法通知或者涉嫌危害国家安全犯罪、恐怖活动犯罪通知可能有碍侦查的情形以外，应当在拘留后二十四小时以内，通知被拘留人的家属。有碍侦查的情形消失以后，应当立即通知被拘留人的家属。 第八十六条 公安机关对被拘留的人，应当在拘留后的二十四小时以内进行讯问。在发现不应当拘留的时候，必须立即释放，发给释放证明。 第八十七条 公安机关要求逮捕犯罪嫌疑人的时候，应当写出提请批准逮捕书，连同案卷材料、证据，一并移送同级人民检察院审查批准。必要的时候，人民检察院可以派人参加公安机关对于重大案件的讨论。 第八十八条 人民检察院审查批准逮捕，可以讯问犯罪嫌疑人；有下列情形之一的，应当讯问犯罪嫌疑人： （一）对是否符合逮捕条件有疑问的； （二）犯罪嫌疑人要求向检察人员当面陈述的； （三）侦查活动可能有重大违法行为的。 人民检察院审查批准逮捕，可以询问证人等诉讼参与人，听取辩护律师的意见；辩护律师提出要求的，应当听取辩护律师的意见。 第八十九条 人民检察院审查批准逮捕犯罪嫌疑人由检察长决定。重大案件应当提交检察委员会讨论决定。 第九十条 人民检察院对于公安机关提请批准逮捕的案件进行审查后，应当根据情况分别作出批准逮捕或者不批准逮捕的决定。对于批准逮捕的决定，公安机关应当立即执行，并且将执行情况及时通知人民检察院。对于不批准逮捕的，人民检察院应当说明理由，需要补充侦查的，应当同时通知公安机关。 第九十一条 公安机关对被拘留的人，认为需要逮捕的，应当在拘留后的三日以内，提请人民检察院审查批准。在特殊情况下，提请审查批准的时间可以延长一日至四日。 对于流窜作案、多次作案、结伙作案的重大嫌疑分子，提请审查批准的时间可以延长至三十日。 人民检察院应当自接到公安机关提请批准逮捕书后的七日以内，作出批准逮捕或者不批准逮捕的决定。人民检察院不批准逮捕的，公安机关应当在接到通知后立即释放，并且将执行情况及时通知人民检察院。对于需要继续侦查，并且符合取保候审、监视居住条件的，依法取保候审或者监视居住。 第九十二条 公安机关对人民检察院不批准逮捕的决定，认为有错误的时候，可以要求复议，但是必须将被拘留的人立即释放。如果意见不被接受，可以向上一级人民检察院提请复核。上级人民检察院应当立即复核，作出是否变更的决定，通知下级人民检察院和公安机关执行。 第九十三条 公安机关逮捕人的时候，必须出示逮捕证。 逮捕后，应当立即将被逮捕人送看守所羁押。除无法通知的以外，应当在逮捕后二十四小时以内，通知被逮捕人的家属。 第九十四条 人民法院、人民检察院对于各自决定逮捕的人，公安机关对于经人民检察院批准逮捕的人，都必须在逮捕后的二十四小时以内进行讯问。在发现不应当逮捕的时候，必须立即释放，发给释放证明。 第九十五条 犯罪嫌疑人、被告人被逮捕后，人民检察院仍应当对羁押的必要性进行审查。对不需要继续羁押的，应当建议予以释放或者变更强制措施。有关机关应当在十日以内将处理情况通知人民检察院。 第九十六条 人民法院、人民检察院和公安机关如果发现对犯罪嫌疑人、被告人采取强制措施不当的，应当及时撤销或者变更。公安机关释放被逮捕的人或者变更逮捕措施的，应当通知原批准的人民检察院。 第九十七条 犯罪嫌疑人、被告人及其法定代理人、近亲属或者辩护人有权申请变更强制措施。人民法院、人民检察院和公安机关收到申请后，应当在三日以内作出决定；不同意变更强制措施的，应当告知申请人，并说明不同意的理由。 第九十八条 犯罪嫌疑人、被告人被羁押的案件，不能在本法规定的侦查羁押、审查起诉、一审、二审期限内办结的，对犯罪嫌疑人、被告人应当予以释放；需要继续查证、审理的，对犯罪嫌疑人、被告人可以取保候审或者监视居住。 第九十九条 人民法院、人民检察院或者公安机关对被采取强制措施法定期限届满的犯罪嫌疑人、被告人，应当予以释放、解除取保候审、监视居住或者依法变更强制措施。犯罪嫌疑人、被告人及其法定代理人、近亲属或者辩护人对于人民法院、人民检察院或者公安机关采取强制措施法定期限届满的，有权要求解除强制措施。 第一百条 人民检察院在审查批准逮捕工作中，如果发现公安机关的侦查活动有违法情况，应当通知公安机关予以纠正，公安机关应当将纠正情况通知人民检察院。 第七章 附带民事诉讼第一百零一条 被害人由于被告人的犯罪行为而遭受物质损失的，在刑事诉讼过程中，有权提起附带民事诉讼。被害人死亡或者丧失行为能力的，被害人的法定代理人、近亲属有权提起附带民事诉讼。 如果是国家财产、集体财产遭受损失的，人民检察院在提起公诉的时候，可以提起附带民事诉讼。 第一百零二条 人民法院在必要的时候，可以采取保全措施，查封、扣押或者冻结被告人的财产。附带民事诉讼原告人或者人民检察院可以申请人民法院采取保全措施。人民法院采取保全措施，适用民事诉讼法的有关规定。 第一百零三条 人民法院审理附带民事诉讼案件，可以进行调解，或者根据物质损失情况作出判决、裁定。 第一百零四条 附带民事诉讼应当同刑事案件一并审判，只有为了防止刑事案件审判的过分迟延，才可以在刑事案件审判后，由同一审判组织继续审理附带民事诉讼。 第八章 期间、送达第一百零五条 期间以时、日、月计算。 期间开始的时和日不算在期间以内。 法定期间不包括路途上的时间。上诉状或者其他文件在期满前已经交邮的，不算过期。 期间的最后一日为节假日的，以节假日后的第一日为期满日期，但犯罪嫌疑人、被告人或者罪犯在押期间，应当至期满之日为止，不得因节假日而延长。 第一百零六条 当事人由于不能抗拒的原因或者有其他正当理由而耽误期限的，在障碍消除后五日以内，可以申请继续进行应当在期满以前完成的诉讼活动。 前款申请是否准许，由人民法院裁定。 第一百零七条 送达传票、通知书和其他诉讼文件应当交给收件人本人；如果本人不在，可以交给他的成年家属或者所在单位的负责人员代收。 收件人本人或者代收人拒绝接收或者拒绝签名、盖章的时候，送达人可以邀请他的邻居或者其他见证人到场，说明情况，把文件留在他的住处，在送达证上记明拒绝的事由、送达的日期，由送达人签名，即认为已经送达。 第九章 其他规定第一百零八条 本法下列用语的含意是： （一）“侦查”是指公安机关、人民检察院对于刑事案件，依照法律进行的收集证据、查明案情的工作和有关的强制性措施； （二）“当事人”是指被害人、自诉人、犯罪嫌疑人、被告人、附带民事诉讼的原告人和被告人； （三）“法定代理人”是指被代理人的父母、养父母、监护人和负有保护责任的机关、团体的代表； （四）“诉讼参与人”是指当事人、法定代理人、诉讼代理人、辩护人、证人、鉴定人和翻译人员； （五）“诉讼代理人”是指公诉案件的被害人及其法定代理人或者近亲属、自诉案件的自诉人及其法定代理人委托代为参加诉讼的人和附带民事诉讼的当事人及其法定代理人委托代为参加诉讼的人； （六）“近亲属”是指夫、妻、父、母、子、女、同胞兄弟姊妹。 第二编 立案、侦查和提起公诉第一章 立案第一百零九条 公安机关或者人民检察院发现犯罪事实或者犯罪嫌疑人，应当按照管辖范围，立案侦查。 第一百一十条 任何单位和个人发现有犯罪事实或者犯罪嫌疑人，有权利也有义务向公安机关、人民检察院或者人民法院报案或者举报。 被害人对侵犯其人身、财产权利的犯罪事实或者犯罪嫌疑人，有权向公安机关、人民检察院或者人民法院报案或者控告。 公安机关、人民检察院或者人民法院对于报案、控告、举报，都应当接受。对于不属于自己管辖的，应当移送主管机关处理，并且通知报案人、控告人、举报人；对于不属于自己管辖而又必须采取紧急措施的，应当先采取紧急措施，然后移送主管机关。 犯罪人向公安机关、人民检察院或者人民法院自首的，适用第三款规定。 第一百一十一条 报案、控告、举报可以用书面或者口头提出。接受口头报案、控告、举报的工作人员，应当写成笔录，经宣读无误后，由报案人、控告人、举报人签名或者盖章。 接受控告、举报的工作人员，应当向控告人、举报人说明诬告应负的法律责任。但是，只要不是捏造事实，伪造证据，即使控告、举报的事实有出入，甚至是错告的，也要和诬告严格加以区别。 公安机关、人民检察院或者人民法院应当保障报案人、控告人、举报人及其近亲属的安全。报案人、控告人、举报人如果不愿公开自己的姓名和报案、控告、举报的行为，应当为他保守秘密。 第一百一十二条 人民法院、人民检察院或者公安机关对于报案、控告、举报和自首的材料，应当按照管辖范围，迅速进行审查，认为有犯罪事实需要追究刑事责任的时候，应当立案；认为没有犯罪事实，或者犯罪事实显著轻微，不需要追究刑事责任的时候，不予立案，并且将不立案的原因通知控告人。控告人如果不服，可以申请复议。 第一百一十三条 人民检察院认为公安机关对应当立案侦查的案件而不立案侦查的，或者被害人认为公安机关对应当立案侦查的案件而不立案侦查，向人民检察院提出的，人民检察院应当要求公安机关说明不立案的理由。人民检察院认为公安机关不立案理由不能成立的，应当通知公安机关立案，公安机关接到通知后应当立案。 第一百一十四条 对于自诉案件，被害人有权向人民法院直接起诉。被害人死亡或者丧失行为能力的，被害人的法定代理人、近亲属有权向人民法院起诉。人民法院应当依法受理。 第二章 侦查第一百一十五条 公安机关对已经立案的刑事案件，应当进行侦查，收集、调取犯罪嫌疑人有罪或者无罪、罪轻或者罪重的证据材料。对现行犯或者重大嫌疑分子可以依法先行拘留，对符合逮捕条件的犯罪嫌疑人，应当依法逮捕。 第一百一十六条 公安机关经过侦查，对有证据证明有犯罪事实的案件，应当进行预审，对收集、调取的证据材料予以核实。 第一百一十七条 当事人和辩护人、诉讼代理人、利害关系人对于司法机关及其工作人员有下列行为之一的，有权向该机关申诉或者控告 （一）采取强制措施法定期限届满，不予以释放、解除或者变更的； （二）应当退还取保候审保证金不退还的； （三）对与案件无关的财物采取查封、扣押、冻结措施的； （四）应当解除查封、扣押、冻结不解除的； （五）贪污、挪用、私分、调换、违反规定使用查封、扣押、冻结的财物的。 受理申诉或者控告的机关应当及时处理。对处理不服的，可以向同级人民检察院申诉；人民检察院直接受理的案件，可以向上一级人民检察院申诉。人民检察院对申诉应当及时进行审查，情况属实的，通知有关机关予以纠正。 第一百一十八条 讯问犯罪嫌疑人必须由人民检察院或者公安机关的侦查人员负责进行。讯问的时候，侦查人员不得少于二人。 犯罪嫌疑人被送交看守所羁押以后，侦查人员对其进行讯问，应当在看守所内进行。 第一百一十九条 对不需要逮捕、拘留的犯罪嫌疑人，可以传唤到犯罪嫌疑人所在市、县内的指定地点或者到他的住处进行讯问，但是应当出示人民检察院或者公安机关的证明文件。对在现场发现的犯罪嫌疑人，经出示工作证件，可以口头传唤，但应当在讯问笔录中注明。 传唤、拘传持续的时间不得超过十二小时；案情特别重大、复杂，需要采取拘留、逮捕措施的，传唤、拘传持续的时间不得超过二十四小时。 不得以连续传唤、拘传的形式变相拘禁犯罪嫌疑人。传唤、拘传犯罪嫌疑人，应当保证犯罪嫌疑人的饮食和必要的休息时间。 第一百二十条 侦查人员在讯问犯罪嫌疑人的时候，应当首先讯问犯罪嫌疑人是否有犯罪行为，让他陈述有罪的情节或者无罪的辩解，然后向他提出问题。犯罪嫌疑人对侦查人员的提问，应当如实回答。但是对与本案无关的问题，有拒绝回答的权利。 侦查人员在讯问犯罪嫌疑人的时候，应当告知犯罪嫌疑人享有的诉讼权利，如实供述自己罪行可以从宽处理和认罪认罚的法律规定。 第一百二十一条 讯问聋、哑的犯罪嫌疑人，应当有通晓聋、哑手势的人参加，并且将这种情况记明笔录。 第一百二十二条 讯问笔录应当交犯罪嫌疑人核对，对于没有阅读能力的，应当向他宣读。如果记载有遗漏或者差错，犯罪嫌疑人可以提出补充或者改正。犯罪嫌疑人承认笔录没有错误后，应当签名或者盖章。侦查人员也应当在笔录上签名。犯罪嫌疑人请求自行书写供述的，应当准许。必要的时候，侦查人员也可以要犯罪嫌疑人亲笔书写供词。 第一百二十三条 侦查人员在讯问犯罪嫌疑人的时候，可以对讯问过程进行录音或者录像；对于可能判处无期徒刑、死刑的案件或者其他重大犯罪案件，应当对讯问过程进行录音或者录像。 录音或者录像应当全程进行，保持完整性。 第一百二十四条 侦查人员询问证人，可以在现场进行，也可以到证人所在单位、住处或者证人提出的地点进行，在必要的时候，可以通知证人到人民检察院或者公安机关提供证言。在现场询问证人，应当出示工作证件，到证人所在单位、住处或者证人提出的地点询问证人，应当出示人民检察院或者公安机关的证明文件。 询问证人应当个别进行。 第一百二十五条 询问证人，应当告知他应当如实地提供证据、证言和有意作伪证或者隐匿罪证要负的法律责任。 第一百二十六条 本法第一百二十二条的规定，也适用于询问证人。 第一百二十七条 询问被害人，适用本节各条规定。 第一百二十八条 侦查人员对于与犯罪有关的场所、物品、人身、尸体应当进行勘验或者检查。在必要的时候，可以指派或者聘请具有专门知识的人，在侦查人员的主持下进行勘验、检查。 第一百二十九条 任何单位和个人，都有义务保护犯罪现场，并且立即通知公安机关派员勘验。 第一百三十条 侦查人员执行勘验、检查，必须持有人民检察院或者公安机关的证明文件。 第一百三十一条 对于死因不明的尸体，公安机关有权决定解剖，并且通知死者家属到场。 第一百三十二条 为了确定被害人、犯罪嫌疑人的某些特征、伤害情况或者生理状态，可以对人身进行检查，可以提取指纹信息，采集血液、尿液等生物样本。 犯罪嫌疑人如果拒绝检查，侦查人员认为必要的时候，可以强制检查。 检查妇女的身体，应当由女工作人员或者医师进行。 第一百三十三条 勘验、检查的情况应当写成笔录，由参加勘验、检查的人和见证人签名或者盖章。 第一百三十四条 人民检察院审查案件的时候，对公安机关的勘验、检查，认为需要复验、复查时，可以要求公安机关复验、复查，并且可以派检察人员参加。 第一百三十五条 为了查明案情，在必要的时候，经公安机关负责人批准，可以进行侦查实验。 侦查实验的情况应当写成笔录，由参加实验的人签名或者盖章。 侦查实验，禁止一切足以造成危险、侮辱人格或者有伤风化的行为。 第一百三十六条 为了收集犯罪证据、查获犯罪人，侦查人员可以对犯罪嫌疑人以及可能隐藏罪犯或者犯罪证据的人的身体、物品、住处和其他有关的地方进行搜查。 第一百三十七条 任何单位和个人，有义务按照人民检察院和公安机关的要求，交出可以证明犯罪嫌疑人有罪或者无罪的物证、书证、视听资料等证据。 第一百三十八条 进行搜查，必须向被搜查人出示搜查证。 在执行逮捕、拘留的时候，遇有紧急情况，不另用搜查证也可以进行搜查。 第一百三十九条 在搜查的时候，应当有被搜查人或者他的家属，邻居或者其他见证人在场。 搜查妇女的身体，应当由女工作人员进行。 第一百四十条 搜查的情况应当写成笔录，由侦查人员和被搜查人或者他的家属，邻居或者其他见证人签名或者盖章。如果被搜查人或者他的家属在逃或者拒绝签名、盖章，应当在笔录上注明。 第一百四十一条 在侦查活动中发现的可用以证明犯罪嫌疑人有罪或者无罪的各种财物、文件，应当查封、扣押；与案件无关的财物、文件，不得查封、扣押。 对查封、扣押的财物、文件，要妥善保管或者封存，不得使用、调换或者损毁。 第一百四十二条 对查封、扣押的财物、文件，应当会同在场见证人和被查封、扣押财物、文件持有人查点清楚，当场开列清单一式二份，由侦查人员、见证人和持有人签名或者盖章，一份交给持有人，另一份附卷备查。 第一百四十三条 侦查人员认为需要扣押犯罪嫌疑人的邮件、电报的时候，经公安机关或者人民检察院批准，即可通知邮电机关将有关的邮件、电报检交扣押。 不需要继续扣押的时候，应即通知邮电机关。 第一百四十四条 人民检察院、公安机关根据侦查犯罪的需要，可以依照规定查询、冻结犯罪嫌疑人的存款、汇款、债券、股票、基金份额等财产。有关单位和个人应当配合。 犯罪嫌疑人的存款、汇款、债券、股票、基金份额等财产已被冻结的，不得重复冻结。 第一百四十五条 对查封、扣押的财物、文件、邮件、电报或者冻结的存款、汇款、债券、股票、基金份额等财产，经查明确实与案件无关的，应当在三日以内解除查封、扣押、冻结，予以退还。 第一百四十六条 为了查明案情，需要解决案件中某些专门性问题的时候，应当指派、聘请有专门知识的人进行鉴定。 第一百四十七条 鉴定人进行鉴定后，应当写出鉴定意见，并且签名。 鉴定人故意作虚假鉴定的，应当承担法律责任。 第一百四十八条 侦查机关应当将用作证据的鉴定意见告知犯罪嫌疑人、被害人。如果犯罪嫌疑人、被害人提出申请，可以补充鉴定或者重新鉴定。 第一百四十九条 对犯罪嫌疑人作精神病鉴定的期间不计入办案期限。 第一百五十条 公安机关在立案后，对于危害国家安全犯罪、恐怖活动犯罪、黑社会性质的组织犯罪、重大毒品犯罪或者其他严重危害社会的犯罪案件，根据侦查犯罪的需要，经过严格的批准手续，可以采取技术侦查措施。 人民检察院在立案后，对于利用职权实施的严重侵犯公民人身权利的重大犯罪案件，根据侦查犯罪的需要，经过严格的批准手续，可以采取技术侦查措施，按照规定交有关机关执行。 追捕被通缉或者批准、决定逮捕的在逃的犯罪嫌疑人、被告人，经过批准，可以采取追捕所必需的技术侦查措施。 第一百五十一条 批准决定应当根据侦查犯罪的需要，确定采取技术侦查措施的种类和适用对象。批准决定自签发之日起三个月以内有效。对于不需要继续采取技术侦查措施的，应当及时解除；对于复杂、疑难案件，期限届满仍有必要继续采取技术侦查措施的，经过批准，有效期可以延长，每次不得超过三个月。 第一百五十二条 采取技术侦查措施，必须严格按照批准的措施种类、适用对象和期限执行。 侦查人员对采取技术侦查措施过程中知悉的国家秘密、商业秘密和个人隐私，应当保密；对采取技术侦查措施获取的与案件无关的材料，必须及时销毁。 采取技术侦查措施获取的材料，只能用于对犯罪的侦查、起诉和审判，不得用于其他用途。 公安机关依法采取技术侦查措施，有关单位和个人应当配合，并对有关情况予以保密。 第一百五十三条 为了查明案情，在必要的时候，经公安机关负责人决定，可以由有关人员隐匿其身份实施侦查。但是，不得诱使他人犯罪，不得采用可能危害公共安全或者发生重大人身危险的方法。 对涉及给付毒品等违禁品或者财物的犯罪活动，公安机关根据侦查犯罪的需要，可以依照规定实施控制下交付。 第一百五十四条 依照本节规定采取侦查措施收集的材料在刑事诉讼中可以作为证据使用。如果使用该证据可能危及有关人员的人身安全，或者可能产生其他严重后果的，应当采取不暴露有关人员身份、技术方法等保护措施，必要的时候，可以由审判人员在庭外对证据进行核实。 第一百五十五条 应当逮捕的犯罪嫌疑人如果在逃，公安机关可以发布通缉令，采取有效措施，追捕归案。 各级公安机关在自己管辖的地区以内，可以直接发布通缉令；超出自己管辖的地区，应当报请有权决定的上级机关发布。 第一百五十六条 对犯罪嫌疑人逮捕后的侦查羁押期限不得超过二个月。案情复杂、期限届满不能终结的案件，可以经上一级人民检察院批准延长一个月。 第一百五十七条 因为特殊原因，在较长时间内不宜交付审判的特别重大复杂的案件，由最高人民检察院报请全国人民代表大会常务委员会批准延期审理。 第一百五十八条 下列案件在本法第一百五十六条规定的期限届满不能侦查终结的，经省、自治区、直辖市人民检察院批准或者决定，可以延长二个月： （一）交通十分不便的边远地区的重大复杂案件； （二）重大的犯罪集团案件； （三）流窜作案的重大复杂案件； （四）犯罪涉及面广，取证困难的重大复杂案件。 第一百五十九条 对犯罪嫌疑人可能判处十年有期徒刑以上刑罚，依照本法第一百五十八条规定延长期限届满，仍不能侦查终结的，经省、自治区、直辖市人民检察院批准或者决定，可以再延长二个月。 第一百六十条 在侦查期间，发现犯罪嫌疑人另有重要罪行的，自发现之日起依照本法第一百五十六条的规定重新计算侦查羁押期限。 犯罪嫌疑人不讲真实姓名、住址，身份不明的，应当对其身份进行调查，侦查羁押期限自查清其身份之日起计算，但是不得停止对其犯罪行为的侦查取证。对于犯罪事实清楚，证据确实、充分，确实无法查明其身份的，也可以按其自报的姓名起诉、审判。 第一百六十一条 在案件侦查终结前，辩护律师提出要求的，侦查机关应当听取辩护律师的意见，并记录在案。辩护律师提出书面意见的，应当附卷。 第一百六十二条 公安机关侦查终结的案件，应当做到犯罪事实清楚，证据确实、充分，并且写出起诉意见书，连同案卷材料、证据一并移送同级人民检察院审查决定；同时将案件移送情况告知犯罪嫌疑人及其辩护律师。 犯罪嫌疑人自愿认罪的，应当记录在案，随案移送，并在起诉意见书中写明有关情况。 第一百六十三条 在侦查过程中，发现不应对犯罪嫌疑人追究刑事责任的，应当撤销案件；犯罪嫌疑人已被逮捕的，应当立即释放，发给释放证明，并且通知原批准逮捕的人民检察院。 第一百六十四条 人民检察院对直接受理的案件的侦查适用本章规定。 第一百六十五条 人民检察院直接受理的案件中符合本法第八十一条、第八十二条第四项、第五项规定情形，需要逮捕、拘留犯罪嫌疑人的，由人民检察院作出决定，由公安机关执行。 第一百六十六条 人民检察院对直接受理的案件中被拘留的人，应当在拘留后的二十四小时以内进行讯问。在发现不应当拘留的时候，必须立即释放，发给释放证明。 第一百六十七条 人民检察院对直接受理的案件中被拘留的人，认为需要逮捕的，应当在十四日以内作出决定。在特殊情况下，决定逮捕的时间可以延长一日至三日。对不需要逮捕的，应当立即释放；对需要继续侦查，并且符合取保候审、监视居住条件的，依法取保候审或者监视居住。 第一百六十八条 人民检察院侦查终结的案件，应当作出提起公诉、不起诉或者撤销案件的决定。 第三章 提起公诉第一百六十九条 凡需要提起公诉的案件，一律由人民检察院审查决定。 第一百七十条 人民检察院对于监察机关移送起诉的案件，依照本法和监察法的有关规定进行审查。人民检察院经审查，认为需要补充核实的，应当退回监察机关补充调查，必要时可以自行补充侦查。 对于监察机关移送起诉的已采取留置措施的案件，人民检察院应当对犯罪嫌疑人先行拘留，留置措施自动解除。人民检察院应当在拘留后的十日以内作出是否逮捕、取保候审或者监视居住的决定。在特殊情况下，决定的时间可以延长一日至四日。人民检察院决定采取强制措施的期间不计入审查起诉期限。 第一百七十一条 人民检察院审查案件的时候，必须查明： （一）犯罪事实、情节是否清楚，证据是否确实、充分，犯罪性质和罪名的认定是否正确； （二）有无遗漏罪行和其他应当追究刑事责任的人； （三）是否属于不应追究刑事责任的； （四）有无附带民事诉讼； （五）侦查活动是否合法。 第一百七十二条 人民检察院对于监察机关、公安机关移送起诉的案件，应当在一个月以内作出决定，重大、复杂的案件，可以延长十五日；犯罪嫌疑人认罪认罚，符合速裁程序适用条件的，应当在十日以内作出决定，对可能判处的有期徒刑超过一年的，可以延长至十五日。 人民检察院审查起诉的案件，改变管辖的，从改变后的人民检察院收到案件之日起计算审查起诉期限。 第一百七十三条 人民检察院审查案件，应当讯问犯罪嫌疑人，听取辩护人或者值班律师、被害人及其诉讼代理人的意见，并记录在案。辩护人或者值班律师、被害人及其诉讼代理人提出书面意见的，应当附卷。 犯罪嫌疑人认罪认罚的，人民检察院应当告知其享有的诉讼权利和认罪认罚的法律规定，听取犯罪嫌疑人、辩护人或者值班律师、被害人及其诉讼代理人对下列事项的意见，并记录在案： （一）涉嫌的犯罪事实、罪名及适用的法律规定； （二）从轻、减轻或者免除处罚等从宽处罚的建议； （三）认罪认罚后案件审理适用的程序； （四）其他需要听取意见的事项。 人民检察院依照前两款规定听取值班律师意见的，应当提前为值班律师了解案件有关情况提供必要的便利。 第一百七十四条 犯罪嫌疑人自愿认罪，同意量刑建议和程序适用的，应当在辩护人或者值班律师在场的情况下签署认罪认罚具结书。 犯罪嫌疑人认罪认罚，有下列情形之一的，不需要签署认罪认罚具结书： （一）犯罪嫌疑人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的； （二）未成年犯罪嫌疑人的法定代理人、辩护人对未成年人认罪认罚有异议的； （三）其他不需要签署认罪认罚具结书的情形。 第一百七十五条 人民检察院审查案件，可以要求公安机关提供法庭审判所必需的证据材料；认为可能存在本法第五十六条规定的以非法方法收集证据情形的，可以要求其对证据收集的合法性作出说明。 人民检察院审查案件，对于需要补充侦查的，可以退回公安机关补充侦查，也可以自行侦查。 对于补充侦查的案件，应当在一个月以内补充侦查完毕。补充侦查以二次为限。补充侦查完毕移送人民检察院后，人民检察院重新计算审查起诉期限。 对于二次补充侦查的案件，人民检察院仍然认为证据不足，不符合起诉条件的，应当作出不起诉的决定。 第一百七十六条 人民检察院认为犯罪嫌疑人的犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，应当作出起诉决定，按照审判管辖的规定，向人民法院提起公诉，并将案卷材料、证据移送人民法院。 犯罪嫌疑人认罪认罚的，人民检察院应当就主刑、附加刑、是否适用缓刑等提出量刑建议，并随案移送认罪认罚具结书等材料。 第一百七十七条 犯罪嫌疑人没有犯罪事实，或者有本法第十六条规定的情形之一的，人民检察院应当作出不起诉决定。 对于犯罪情节轻微，依照刑法规定不需要判处刑罚或者免除刑罚的，人民检察院可以作出不起诉决定。 人民检察院决定不起诉的案件，应当同时对侦查中查封、扣押、冻结的财物解除查封、扣押、冻结。对被不起诉人需要给予行政处罚、处分或者需要没收其违法所得的，人民检察院应当提出检察意见，移送有关主管机关处理。有关主管机关应当将处理结果及时通知人民检察院。 第一百七十八条 不起诉的决定，应当公开宣布，并且将不起诉决定书送达被不起诉人和他的所在单位。如果被不起诉人在押，应当立即释放。 第一百七十九条 对于公安机关移送起诉的案件，人民检察院决定不起诉的，应当将不起诉决定书送达公安机关。公安机关认为不起诉的决定有错误的时候，可以要求复议，如果意见不被接受，可以向上一级人民检察院提请复核。 第一百八十条 对于有被害人的案件，决定不起诉的，人民检察院应当将不起诉决定书送达被害人。被害人如果不服，可以自收到决定书后七日以内向上一级人民检察院申诉，请求提起公诉。人民检察院应当将复查决定告知被害人。对人民检察院维持不起诉决定的，被害人可以向人民法院起诉。被害人也可以不经申诉，直接向人民法院起诉。人民法院受理案件后，人民检察院应当将有关案件材料移送人民法院。 第一百八十一条 对于人民检察院依照本法第一百七十七条第二款规定作出的不起诉决定，被不起诉人如果不服，可以自收到决定书后七日以内向人民检察院申诉。人民检察院应当作出复查决定，通知被不起诉的人，同时抄送公安机关。 第一百八十二条 犯罪嫌疑人自愿如实供述涉嫌犯罪的事实，有重大立功或者案件涉及国家重大利益的，经最高人民检察院核准，公安机关可以撤销案件，人民检察院可以作出不起诉决定，也可以对涉嫌数罪中的一项或者多项不起诉。 根据前款规定不起诉或者撤销案件的，人民检察院、公安机关应当及时对查封、扣押、冻结的财物及其孳息作出处理。 第三编 审 判第一章 审判组织第一百八十三条 基层人民法院、中级人民法院审判第一审案件，应当由审判员三人或者由审判员和人民陪审员共三人或者七人组成合议庭进行，但是基层人民法院适用简易程序、速裁程序的案件可以由审判员一人独任审判。 高级人民法院审判第一审案件，应当由审判员三人至七人或者由审判员和人民陪审员共三人或者七人组成合议庭进行。 最高人民法院审判第一审案件，应当由审判员三人至七人组成合议庭进行。 人民法院审判上诉和抗诉案件，由审判员三人或者五人组成合议庭进行。 合议庭的成员人数应当是单数。 第一百八十四条 合议庭进行评议的时候，如果意见分歧，应当按多数人的意见作出决定，但是少数人的意见应当写入笔录。评议笔录由合议庭的组成人员签名。 第一百八十五条 合议庭开庭审理并且评议后，应当作出判决。对于疑难、复杂、重大的案件，合议庭认为难以作出决定的，由合议庭提请院长决定提交审判委员会讨论决定。审判委员会的决定，合议庭应当执行。 第二章 第一审程序第一百八十六条 人民法院对提起公诉的案件进行审查后，对于起诉书中有明确的指控犯罪事实的，应当决定开庭审判。 第一百八十七条 人民法院决定开庭审判后，应当确定合议庭的组成人员，将人民检察院的起诉书副本至迟在开庭十日以前送达被告人及其辩护人。 在开庭以前，审判人员可以召集公诉人、当事人和辩护人、诉讼代理人，对回避、出庭证人名单、非法证据排除等与审判相关的问题，了解情况，听取意见。 人民法院确定开庭日期后，应当将开庭的时间、地点通知人民检察院，传唤当事人，通知辩护人、诉讼代理人、证人、鉴定人和翻译人员，传票和通知书至迟在开庭三日以前送达。公开审判的案件，应当在开庭三日以前先期公布案由、被告人姓名、开庭时间和地点。 上述活动情形应当写入笔录，由审判人员和书记员签名。 第一百八十八条 人民法院审判第一审案件应当公开进行。但是有关国家秘密或者个人隐私的案件，不公开审理；涉及商业秘密的案件，当事人申请不公开审理的，可以不公开审理。 不公开审理的案件，应当当庭宣布不公开审理的理由。 第一百八十九条 人民法院审判公诉案件，人民检察院应当派员出席法庭支持公诉。 第一百九十条 开庭的时候，审判长查明当事人是否到庭，宣布案由；宣布合议庭的组成人员、书记员、公诉人、辩护人、诉讼代理人、鉴定人和翻译人员的名单；告知当事人有权对合议庭组成人员、书记员、公诉人、鉴定人和翻译人员申请回避；告知被告人享有辩护权利。 被告人认罪认罚的，审判长应当告知被告人享有的诉讼权利和认罪认罚的法律规定，审查认罪认罚的自愿性和认罪认罚具结书内容的真实性、合法性。 第一百九十一条 公诉人在法庭上宣读起诉书后，被告人、被害人可以就起诉书指控的犯罪进行陈述，公诉人可以讯问被告人。 被害人、附带民事诉讼的原告人和辩护人、诉讼代理人，经审判长许可，可以向被告人发问。 审判人员可以讯问被告人。 第一百九十二条 公诉人、当事人或者辩护人、诉讼代理人对证人证言有异议，且该证人证言对案件定罪量刑有重大影响，人民法院认为证人有必要出庭作证的，证人应当出庭作证。 人民警察就其执行职务时目击的犯罪情况作为证人出庭作证，适用前款规定。 公诉人、当事人或者辩护人、诉讼代理人对鉴定意见有异议，人民法院认为鉴定人有必要出庭的，鉴定人应当出庭作证。经人民法院通知，鉴定人拒不出庭作证的，鉴定意见不得作为定案的根据。 第一百九十三条 经人民法院通知，证人没有正当理由不出庭作证的，人民法院可以强制其到庭，但是被告人的配偶、父母、子女除外。 证人没有正当理由拒绝出庭或者出庭后拒绝作证的，予以训诫，情节严重的，经院长批准，处以十日以下的拘留。被处罚人对拘留决定不服的，可以向上一级人民法院申请复议。复议期间不停止执行。 第一百九十四条 证人作证，审判人员应当告知他要如实地提供证言和有意作伪证或者隐匿罪证要负的法律责任。公诉人、当事人和辩护人、诉讼代理人经审判长许可，可以对证人、鉴定人发问。审判长认为发问的内容与案件无关的时候，应当制止。 审判人员可以询问证人、鉴定人。 第一百九十五条 公诉人、辩护人应当向法庭出示物证，让当事人辨认，对未到庭的证人的证言笔录、鉴定人的鉴定意见、勘验笔录和其他作为证据的文书，应当当庭宣读。审判人员应当听取公诉人、当事人和辩护人、诉讼代理人的意见。 第一百九十六条 法庭审理过程中，合议庭对证据有疑问的，可以宣布休庭，对证据进行调查核实。 人民法院调查核实证据，可以进行勘验、检查、查封、扣押、鉴定和查询、冻结。 第一百九十七条 法庭审理过程中，当事人和辩护人、诉讼代理人有权申请通知新的证人到庭，调取新的物证，申请重新鉴定或者勘验。 公诉人、当事人和辩护人、诉讼代理人可以申请法庭通知有专门知识的人出庭，就鉴定人作出的鉴定意见提出意见。 法庭对于上述申请，应当作出是否同意的决定。 第二款规定的有专门知识的人出庭，适用鉴定人的有关规定。 第一百九十八条 法庭审理过程中，对与定罪、量刑有关的事实、证据都应当进行调查、辩论。 经审判长许可，公诉人、当事人和辩护人、诉讼代理人可以对证据和案件情况发表意见并且可以互相辩论。 审判长在宣布辩论终结后，被告人有最后陈述的权利。 第一百九十九条 在法庭审判过程中，如果诉讼参与人或者旁听人员违反法庭秩序，审判长应当警告制止。对不听制止的，可以强行带出法庭；情节严重的，处以一千元以下的罚款或者十五日以下的拘留。罚款、拘留必须经院长批准。被处罚人对罚款、拘留的决定不服的，可以向上一级人民法院申请复议。复议期间不停止执行。 对聚众哄闹、冲击法庭或者侮辱、诽谤、威胁、殴打司法工作人员或者诉讼参与人，严重扰乱法庭秩序，构成犯罪的，依法追究刑事责任。 第二百条 在被告人最后陈述后，审判长宣布休庭，合议庭进行评议，根据已经查明的事实、证据和有关的法律规定，分别作出以下判决： （一）案件事实清楚，证据确实、充分，依据法律认定被告人有罪的，应当作出有罪判决； （二）依据法律认定被告人无罪的，应当作出无罪判决； （三）证据不足，不能认定被告人有罪的，应当作出证据不足、指控的犯罪不能成立的无罪判决。 第二百零一条 对于认罪认罚案件，人民法院依法作出判决时，一般应当采纳人民检察院指控的罪名和量刑建议，但有下列情形的除外： （一）被告人的行为不构成犯罪或者不应当追究其刑事责任的； （二）被告人违背意愿认罪认罚的； （三）被告人否认指控的犯罪事实的； （四）起诉指控的罪名与审理认定的罪名不一致的； （五）其他可能影响公正审判的情形。 人民法院经审理认为量刑建议明显不当，或者被告人、辩护人对量刑建议提出异议的，人民检察院可以调整量刑建议。人民检察院不调整量刑建议或者调整量刑建议后仍然明显不当的，人民法院应当依法作出判决。 第二百零二条 宣告判决，一律公开进行。 当庭宣告判决的，应当在五日以内将判决书送达当事人和提起公诉的人民检察院；定期宣告判决的，应当在宣告后立即将判决书送达当事人和提起公诉的人民检察院。判决书应当同时送达辩护人、诉讼代理人。 第二百零三条 判决书应当由审判人员和书记员署名，并且写明上诉的期限和上诉的法院。 第二百零四条 在法庭审判过程中，遇有下列情形之一，影响审判进行的，可以延期审理： （一）需要通知新的证人到庭，调取新的物证，重新鉴定或者勘验的； （二）检察人员发现提起公诉的案件需要补充侦查，提出建议的； （三）由于申请回避而不能进行审判的。 第二百零五条 依照本法第二百零四条第二项的规定延期审理的案件，人民检察院应当在一个月以内补充侦查完毕。 第二百零六条 在审判过程中，有下列情形之一，致使案件在较长时间内无法继续审理的，可以中止审理： （一）被告人患有严重疾病，无法出庭的； （二）被告人脱逃的； （三）自诉人患有严重疾病，无法出庭，未委托诉讼代理人出庭的； （四）由于不能抗拒的原因。 中止审理的原因消失后，应当恢复审理。中止审理的期间不计入审理期限。 第二百零七条 法庭审判的全部活动，应当由书记员写成笔录，经审判长审阅后，由审判长和书记员签名。 法庭笔录中的证人证言部分，应当当庭宣读或者交给证人阅读。证人在承认没有错误后，应当签名或者盖章。 法庭笔录应当交给当事人阅读或者向他宣读。当事人认为记载有遗漏或者差错的，可以请求补充或者改正。当事人承认没有错误后，应当签名或者盖章。 第二百零八条 人民法院审理公诉案件，应当在受理后二个月以内宣判，至迟不得超过三个月。对于可能判处死刑的案件或者附带民事诉讼的案件，以及有本法第一百五十八条规定情形之一的，经上一级人民法院批准，可以延长三个月；因特殊情况还需要延长的，报请最高人民法院批准。 人民法院改变管辖的案件，从改变后的人民法院收到案件之日起计算审理期限。 人民检察院补充侦查的案件，补充侦查完毕移送人民法院后，人民法院重新计算审理期限。 第二百零九条 人民检察院发现人民法院审理案件违反法律规定的诉讼程序，有权向人民法院提出纠正意见。 第二百一十条 自诉案件包括下列案件： （一）告诉才处理的案件； （二）被害人有证据证明的轻微刑事案件； （三）被害人有证据证明对被告人侵犯自己人身、财产权利的行为应当依法追究刑事责任，而公安机关或者人民检察院不予追究被告人刑事责任的案件。 第二百一十一条 人民法院对于自诉案件进行审查后，按照下列情形分别处理： （一）犯罪事实清楚，有足够证据的案件，应当开庭审判； （二）缺乏罪证的自诉案件，如果自诉人提不出补充证据，应当说服自诉人撤回自诉，或者裁定驳回。 自诉人经两次依法传唤，无正当理由拒不到庭的，或者未经法庭许可中途退庭的，按撤诉处理。 法庭审理过程中，审判人员对证据有疑问，需要调查核实的，适用本法第一百九十六条的规定。 第二百一十二条 人民法院对自诉案件，可以进行调解；自诉人在宣告判决前，可以同被告人自行和解或者撤回自诉。本法第二百一十条第三项规定的案件不适用调解。 人民法院审理自诉案件的期限，被告人被羁押的，适用本法第二百零八条第一款、第二款的规定；未被羁押的，应当在受理后六个月以内宣判。 第二百一十三条 自诉案件的被告人在诉讼过程中，可以对自诉人提起反诉。反诉适用自诉的规定。 第二百一十四条 基层人民法院管辖的案件，符合下列条件的，可以适用简易程序审判： （一）案件事实清楚、证据充分的； （二）被告人承认自己所犯罪行，对指控的犯罪事实没有异议的； （三）被告人对适用简易程序没有异议的。 人民检察院在提起公诉的时候，可以建议人民法院适用简易程序。 第二百一十五条 有下列情形之一的，不适用简易程序： （一）被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的； （二）有重大社会影响的； （三）共同犯罪案件中部分被告人不认罪或者对适用简易程序有异议的； （四）其他不宜适用简易程序审理的。 第二百一十六条 适用简易程序审理案件，对可能判处三年有期徒刑以下刑罚的，可以组成合议庭进行审判，也可以由审判员一人独任审判；对可能判处的有期徒刑超过三年的，应当组成合议庭进行审判。 适用简易程序审理公诉案件，人民检察院应当派员出席法庭。 第二百一十七条 适用简易程序审理案件，审判人员应当询问被告人对指控的犯罪事实的意见，告知被告人适用简易程序审理的法律规定，确认被告人是否同意适用简易程序审理。 第二百一十八条 适用简易程序审理案件，经审判人员许可，被告人及其辩护人可以同公诉人、自诉人及其诉讼代理人互相辩论。 第二百一十九条 适用简易程序审理案件，不受本章第一节关于送达期限、讯问被告人、询问证人、鉴定人、出示证据、法庭辩论程序规定的限制。但在判决宣告前应当听取被告人的最后陈述意见。 第二百二十条 适用简易程序审理案件，人民法院应当在受理后二十日以内审结；对可能判处的有期徒刑超过三年的，可以延长至一个半月。 第二百二十一条 人民法院在审理过程中，发现不宜适用简易程序的，应当按照本章第一节或者第二节的规定重新审理。 第二百二十二条 基层人民法院管辖的可能判处三年有期徒刑以下刑罚的案件，案件事实清楚，证据确实、充分，被告人认罪认罚并同意适用速裁程序的，可以适用速裁程序，由审判员一人独任审判。 人民检察院在提起公诉的时候，可以建议人民法院适用速裁程序。 第二百二十三条 有下列情形之一的，不适用速裁程序： （一）被告人是盲、聋、哑人，或者是尚未完全丧失辨认或者控制自己行为能力的精神病人的； （二）被告人是未成年人的； （三）案件有重大社会影响的； （四）共同犯罪案件中部分被告人对指控的犯罪事实、罪名、量刑建议或者适用速裁程序有异议的； （五）被告人与被害人或者其法定代理人没有就附带民事诉讼赔偿等事项达成调解或者和解协议的； （六）其他不宜适用速裁程序审理的。 第二百二十四条 适用速裁程序审理案件，不受本章第一节规定的送达期限的限制，一般不进行法庭调查、法庭辩论，但在判决宣告前应当听取辩护人的意见和被告人的最后陈述意见。 适用速裁程序审理案件，应当当庭宣判。 第二百二十五条 适用速裁程序审理案件，人民法院应当在受理后十日以内审结；对可能判处的有期徒刑超过一年的，可以延长至十五日。 第二百二十六条 人民法院在审理过程中，发现有被告人的行为不构成犯罪或者不应当追究其刑事责任、被告人违背意愿认罪认罚、被告人否认指控的犯罪事实或者其他不宜适用速裁程序审理的情形的，应当按照本章第一节或者第三节的规定重新审理。 第三章 第二审程序第二百二十七条 被告人、自诉人和他们的法定代理人，不服地方各级人民法院第一审的判决、裁定，有权用书状或者口头向上一级人民法院上诉。被告人的辩护人和近亲属，经被告人同意，可以提出上诉。 附带民事诉讼的当事人和他们的法定代理人，可以对地方各级人民法院第一审的判决、裁定中的附带民事诉讼部分，提出上诉。 对被告人的上诉权，不得以任何借口加以剥夺。 第二百二十八条 地方各级人民检察院认为本级人民法院第一审的判决、裁定确有错误的时候，应当向上一级人民法院提出抗诉。 第二百二十九条 被害人及其法定代理人不服地方各级人民法院第一审的判决的，自收到判决书后五日以内，有权请求人民检察院提出抗诉。人民检察院自收到被害人及其法定代理人的请求后五日以内，应当作出是否抗诉的决定并且答复请求人。 第二百三十条 不服判决的上诉和抗诉的期限为十日，不服裁定的上诉和抗诉的期限为五日，从接到判决书、裁定书的第二日起算。 第二百三十一条 被告人、自诉人、附带民事诉讼的原告人和被告人通过原审人民法院提出上诉的，原审人民法院应当在三日以内将上诉状连同案卷、证据移送上一级人民法院，同时将上诉状副本送交同级人民检察院和对方当事人。 被告人、自诉人、附带民事诉讼的原告人和被告人直接向第二审人民法院提出上诉的，第二审人民法院应当在三日以内将上诉状交原审人民法院送交同级人民检察院和对方当事人。 第二百三十二条 地方各级人民检察院对同级人民法院第一审判决、裁定的抗诉，应当通过原审人民法院提出抗诉书，并且将抗诉书抄送上一级人民检察院。原审人民法院应当将抗诉书连同案卷、证据移送上一级人民法院，并且将抗诉书副本送交当事人。 上级人民检察院如果认为抗诉不当，可以向同级人民法院撤回抗诉，并且通知下级人民检察院。 第二百三十三条 第二审人民法院应当就第一审判决认定的事实和适用法律进行全面审查，不受上诉或者抗诉范围的限制。 共同犯罪的案件只有部分被告人上诉的，应当对全案进行审查，一并处理。 第二百三十四条 第二审人民法院对于下列案件，应当组成合议庭，开庭审理： （一）被告人、自诉人及其法定代理人对第一审认定的事实、证据提出异议，可能影响定罪量刑的上诉案件； （二）被告人被判处死刑的上诉案件； （三）人民检察院抗诉的案件； （四）其他应当开庭审理的案件。 第二审人民法院决定不开庭审理的，应当讯问被告人，听取其他当事人、辩护人、诉讼代理人的意见。 第二审人民法院开庭审理上诉、抗诉案件，可以到案件发生地或者原审人民法院所在地进行。 第二百三十五条 人民检察院提出抗诉的案件或者第二审人民法院开庭审理的公诉案件，同级人民检察院都应当派员出席法庭。第二审人民法院应当在决定开庭审理后及时通知人民检察院查阅案卷。人民检察院应当在一个月以内查阅完毕。人民检察院查阅案卷的时间不计入审理期限。 第二百三十六条 第二审人民法院对不服第一审判决的上诉、抗诉案件，经过审理后，应当按照下列情形分别处理： （一）原判决认定事实和适用法律正确、量刑适当的，应当裁定驳回上诉或者抗诉，维持原判； （二）原判决认定事实没有错误，但适用法律有错误，或者量刑不当的，应当改判； （三）原判决事实不清楚或者证据不足的，可以在查清事实后改判；也可以裁定撤销原判，发回原审人民法院重新审判。 原审人民法院对于依照前款第三项规定发回重新审判的案件作出判决后，被告人提出上诉或者人民检察院提出抗诉的，第二审人民法院应当依法作出判决或者裁定，不得再发回原审人民法院重新审判。 第二百三十七条 第二审人民法院审理被告人或者他的法定代理人、辩护人、近亲属上诉的案件，不得加重被告人的刑罚。第二审人民法院发回原审人民法院重新审判的案件，除有新的犯罪事实，人民检察院补充起诉的以外，原审人民法院也不得加重被告人的刑罚。 人民检察院提出抗诉或者自诉人提出上诉的，不受前款规定的限制。 第二百三十八条 第二审人民法院发现第一审人民法院的审理有下列违反法律规定的诉讼程序的情形之一的，应当裁定撤销原判，发回原审人民法院重新审判： （一）违反本法有关公开审判的规定的； （二）违反回避制度的； （三）剥夺或者限制了当事人的法定诉讼权利，可能影响公正审判的； （四）审判组织的组成不合法的； （五）其他违反法律规定的诉讼程序，可能影响公正审判的。 第二百三十九条 原审人民法院对于发回重新审判的案件，应当另行组成合议庭，依照第一审程序进行审判。对于重新审判后的判决，依照本法第二百二十七条、第二百二十八条、第二百二十九条的规定可以上诉、抗诉。 第二百四十条 第二审人民法院对不服第一审裁定的上诉或者抗诉，经过审查后，应当参照本法第二百三十六条、第二百三十八条和第二百三十九条的规定，分别情形用裁定驳回上诉、抗诉，或者撤销、变更原裁定。 第二百四十一条 第二审人民法院发回原审人民法院重新审判的案件，原审人民法院从收到发回的案件之日起，重新计算审理期限。 第二百四十二条 第二审人民法院审判上诉或者抗诉案件的程序，除本章已有规定的以外，参照第一审程序的规定进行。 第二百四十三条 第二审人民法院受理上诉、抗诉案件，应当在二个月以内审结。对于可能判处死刑的案件或者附带民事诉讼的案件，以及有本法第一百五十八条规定情形之一的，经省、自治区、直辖市高级人民法院批准或者决定，可以延长二个月；因特殊情况还需要延长的，报请最高人民法院批准。 最高人民法院受理上诉、抗诉案件的审理期限，由最高人民法院决定。 第二百四十四条 第二审的判决、裁定和最高人民法院的判决、裁定，都是终审的判决、裁定。 第二百四十五条 公安机关、人民检察院和人民法院对查封、扣押、冻结的犯罪嫌疑人、被告人的财物及其孳息，应当妥善保管，以供核查，并制作清单，随案移送。任何单位和个人不得挪用或者自行处理。对被害人的合法财产，应当及时返还。对违禁品或者不宜长期保存的物品，应当依照国家有关规定处理。 对作为证据使用的实物应当随案移送，对不宜移送的，应当将其清单、照片或者其他证明文件随案移送。 人民法院作出的判决，应当对查封、扣押、冻结的财物及其孳息作出处理。 人民法院作出的判决生效以后，有关机关应当根据判决对查封、扣押、冻结的财物及其孳息进行处理。对查封、扣押、冻结的赃款赃物及其孳息，除依法返还被害人的以外，一律上缴国库。 司法工作人员贪污、挪用或者私自处理查封、扣押、冻结的财物及其孳息的，依法追究刑事责任；不构成犯罪的，给予处分。 第四章 死刑复核程序第二百四十六条 死刑由最高人民法院核准。 第二百四十七条 中级人民法院判处死刑的第一审案件，被告人不上诉的，应当由高级人民法院复核后，报请最高人民法院核准。高级人民法院不同意判处死刑的，可以提审或者发回重新审判。 高级人民法院判处死刑的第一审案件被告人不上诉的，和判处死刑的第二审案件，都应当报请最高人民法院核准。 第二百四十八条 中级人民法院判处死刑缓期二年执行的案件，由高级人民法院核准。 第二百四十九条 最高人民法院复核死刑案件，高级人民法院复核死刑缓期执行的案件，应当由审判员三人组成合议庭进行。 第二百五十条 最高人民法院复核死刑案件，应当作出核准或者不核准死刑的裁定。对于不核准死刑的，最高人民法院可以发回重新审判或者予以改判。 第二百五十一条 最高人民法院复核死刑案件，应当讯问被告人，辩护律师提出要求的，应当听取辩护律师的意见。 在复核死刑案件过程中，最高人民检察院可以向最高人民法院提出意见。最高人民法院应当将死刑复核结果通报最高人民检察院。 第五章 审判监督程序第二百五十二条 当事人及其法定代理人、近亲属，对已经发生法律效力的判决、裁定，可以向人民法院或者人民检察院提出申诉，但是不能停止判决、裁定的执行。 第二百五十三条 当事人及其法定代理人、近亲属的申诉符合下列情形之一的，人民法院应当重新审判： （一）有新的证据证明原判决、裁定认定的事实确有错误，可能影响定罪量刑的； （二）据以定罪量刑的证据不确实、不充分、依法应当予以排除，或者证明案件事实的主要证据之间存在矛盾的； （三）原判决、裁定适用法律确有错误的； （四）违反法律规定的诉讼程序，可能影响公正审判的； （五）审判人员在审理该案件的时候，有贪污受贿，徇私舞弊，枉法裁判行为的。 第二百五十四条 各级人民法院院长对本院已经发生法律效力的判决和裁定，如果发现在认定事实上或者在适用法律上确有错误，必须提交审判委员会处理。 最高人民法院对各级人民法院已经发生法律效力的判决和裁定，上级人民法院对下级人民法院已经发生法律效力的判决和裁定，如果发现确有错误，有权提审或者指令下级人民法院再审。 最高人民检察院对各级人民法院已经发生法律效力的判决和裁定，上级人民检察院对下级人民法院已经发生法律效力的判决和裁定，如果发现确有错误，有权按照审判监督程序向同级人民法院提出抗诉。 人民检察院抗诉的案件，接受抗诉的人民法院应当组成合议庭重新审理，对于原判决事实不清楚或者证据不足的，可以指令下级人民法院再审。 第二百五十五条 上级人民法院指令下级人民法院再审的，应当指令原审人民法院以外的下级人民法院审理；由原审人民法院审理更为适宜的，也可以指令原审人民法院审理。 第二百五十六条 人民法院按照审判监督程序重新审判的案件，由原审人民法院审理的，应当另行组成合议庭进行。如果原来是第一审案件，应当依照第一审程序进行审判，所作的判决、裁定，可以上诉、抗诉；如果原来是第二审案件，或者是上级人民法院提审的案件，应当依照第二审程序进行审判，所作的判决、裁定，是终审的判决、裁定。 人民法院开庭审理的再审案件，同级人民检察院应当派员出席法庭。 第二百五十七条 人民法院决定再审的案件，需要对被告人采取强制措施的，由人民法院依法决定；人民检察院提出抗诉的再审案件，需要对被告人采取强制措施的，由人民检察院依法决定。 人民法院按照审判监督程序审判的案件，可以决定中止原判决、裁定的执行。 第二百五十八条 人民法院按照审判监督程序重新审判的案件，应当在作出提审、再审决定之日起三个月以内审结，需要延长期限的，不得超过六个月。 接受抗诉的人民法院按照审判监督程序审判抗诉的案件，审理期限适用前款规定；对需要指令下级人民法院再审的，应当自接受抗诉之日起一个月以内作出决定，下级人民法院审理案件的期限适用前款规定。 第四编 执 行第二百五十九条 判决和裁定在发生法律效力后执行。 下列判决和裁定是发生法律效力的判决和裁定： （一）已过法定期限没有上诉、抗诉的判决和裁定； （二）终审的判决和裁定； （三）最高人民法院核准的死刑的判决和高级人民法院核准的死刑缓期二年执行的判决。 第二百六十条 第一审人民法院判决被告人无罪、免除刑事处罚的，如果被告人在押，在宣判后应当立即释放。 第二百六十一条 最高人民法院判处和核准的死刑立即执行的判决，应当由最高人民法院院长签发执行死刑的命令。 被判处死刑缓期二年执行的罪犯，在死刑缓期执行期间，如果没有故意犯罪，死刑缓期执行期满，应当予以减刑的，由执行机关提出书面意见，报请高级人民法院裁定；如果故意犯罪，情节恶劣，查证属实，应当执行死刑的，由高级人民法院报请最高人民法院核准；对于故意犯罪未执行死刑的，死刑缓期执行的期间重新计算，并报最高人民法院备案。 第二百六十二条 下级人民法院接到最高人民法院执行死刑的命令后，应当在七日以内交付执行。但是发现有下列情形之一的，应当停止执行，并且立即报告最高人民法院，由最高人民法院作出裁定： （一）在执行前发现判决可能有错误的； （二）在执行前罪犯揭发重大犯罪事实或者有其他重大立功表现，可能需要改判的； （三）罪犯正在怀孕。 前款第一项、第二项停止执行的原因消失后，必须报请最高人民法院院长再签发执行死刑的命令才能执行；由于前款第三项原因停止执行的，应当报请最高人民法院依法改判。 第二百六十三条 人民法院在交付执行死刑前，应当通知同级人民检察院派员临场监督。 死刑采用枪决或者注射等方法执行。 死刑可以在刑场或者指定的羁押场所内执行。 指挥执行的审判人员，对罪犯应当验明正身，讯问有无遗言、信札，然后交付执行人员执行死刑。在执行前，如果发现可能有错误，应当暂停执行，报请最高人民法院裁定。 执行死刑应当公布，不应示众。 执行死刑后，在场书记员应当写成笔录。交付执行的人民法院应当将执行死刑情况报告最高人民法院。 执行死刑后，交付执行的人民法院应当通知罪犯家属。 第二百六十四条 罪犯被交付执行刑罚的时候，应当由交付执行的人民法院在判决生效后十日以内将有关的法律文书送达公安机关、监狱或者其他执行机关。 对被判处死刑缓期二年执行、无期徒刑、有期徒刑的罪犯，由公安机关依法将该罪犯送交监狱执行刑罚。对被判处有期徒刑的罪犯，在被交付执行刑罚前，剩余刑期在三个月以下的，由看守所代为执行。对被判处拘役的罪犯，由公安机关执行。 对未成年犯应当在未成年犯管教所执行刑罚。 执行机关应当将罪犯及时收押，并且通知罪犯家属。 判处有期徒刑、拘役的罪犯，执行期满，应当由执行机关发给释放证明书。 第二百六十五条 对被判处有期徒刑或者拘役的罪犯，有下列情形之一的，可以暂予监外执行： （一）有严重疾病需要保外就医的； （二）怀孕或者正在哺乳自己婴儿的妇女； （三）生活不能自理，适用暂予监外执行不致危害社会的。 对被判处无期徒刑的罪犯，有前款第二项规定情形的，可以暂予监外执行。 对适用保外就医可能有社会危险性的罪犯，或者自伤自残的罪犯，不得保外就医。 对罪犯确有严重疾病，必须保外就医的，由省级人民政府指定的医院诊断并开具证明文件。 在交付执行前，暂予监外执行由交付执行的人民法院决定；在交付执行后，暂予监外执行由监狱或者看守所提出书面意见，报省级以上监狱管理机关或者设区的市一级以上公安机关批准。 第二百六十六条 监狱、看守所提出暂予监外执行的书面意见的，应当将书面意见的副本抄送人民检察院。人民检察院可以向决定或者批准机关提出书面意见。 第二百六十七条 决定或者批准暂予监外执行的机关应当将暂予监外执行决定抄送人民检察院。人民检察院认为暂予监外执行不当的，应当自接到通知之日起一个月以内将书面意见送交决定或者批准暂予监外执行的机关，决定或者批准暂予监外执行的机关接到人民检察院的书面意见后，应当立即对该决定进行重新核查。 第二百六十八条 对暂予监外执行的罪犯，有下列情形之一的，应当及时收监： （一）发现不符合暂予监外执行条件的； （二）严重违反有关暂予监外执行监督管理规定的； （三）暂予监外执行的情形消失后，罪犯刑期未满的。 对于人民法院决定暂予监外执行的罪犯应当予以收监的，由人民法院作出决定，将有关的法律文书送达公安机关、监狱或者其他执行机关。 不符合暂予监外执行条件的罪犯通过贿赂等非法手段被暂予监外执行的，在监外执行的期间不计入执行刑期。罪犯在暂予监外执行期间脱逃的，脱逃的期间不计入执行刑期。 罪犯在暂予监外执行期间死亡的，执行机关应当及时通知监狱或者看守所。 第二百六十九条 对被判处管制、宣告缓刑、假释或者暂予监外执行的罪犯，依法实行社区矫正，由社区矫正机构负责执行。 第二百七十条 对被判处剥夺政治权利的罪犯，由公安机关执行。执行期满，应当由执行机关书面通知本人及其所在单位、居住地基层组织。 第二百七十一条 被判处罚金的罪犯，期满不缴纳的，人民法院应当强制缴纳；如果由于遭遇不能抗拒的灾祸等原因缴纳确实有困难的，经人民法院裁定，可以延期缴纳、酌情减少或者免除。 第二百七十二条 没收财产的判决，无论附加适用或者独立适用，都由人民法院执行；在必要的时候，可以会同公安机关执行。 第二百七十三条 罪犯在服刑期间又犯罪的，或者发现了判决的时候所没有发现的罪行，由执行机关移送人民检察院处理。 被判处管制、拘役、有期徒刑或者无期徒刑的罪犯，在执行期间确有悔改或者立功表现，应当依法予以减刑、假释的时候，由执行机关提出建议书，报请人民法院审核裁定，并将建议书副本抄送人民检察院。人民检察院可以向人民法院提出书面意见。 第二百七十四条 人民检察院认为人民法院减刑、假释的裁定不当，应当在收到裁定书副本后二十日以内，向人民法院提出书面纠正意见。人民法院应当在收到纠正意见后一个月以内重新组成合议庭进行审理，作出最终裁定。 第二百七十五条 监狱和其他执行机关在刑罚执行中，如果认为判决有错误或者罪犯提出申诉，应当转请人民检察院或者原判人民法院处理。 第二百七十六条 人民检察院对执行机关执行刑罚的活动是否合法实行监督。如果发现有违法的情况，应当通知执行机关纠正。 第五编 特别程序第一章 未成年人刑事案件诉讼程序第二百七十七条 对犯罪的未成年人实行教育、感化、挽救的方针，坚持教育为主、惩罚为辅的原则。 人民法院、人民检察院和公安机关办理未成年人刑事案件，应当保障未成年人行使其诉讼权利，保障未成年人得到法律帮助，并由熟悉未成年人身心特点的审判人员、检察人员、侦查人员承办。 第二百七十八条 未成年犯罪嫌疑人、被告人没有委托辩护人的，人民法院、人民检察院、公安机关应当通知法律援助机构指派律师为其提供辩护。 第二百七十九条 公安机关、人民检察院、人民法院办理未成年人刑事案件，根据情况可以对未成年犯罪嫌疑人、被告人的成长经历、犯罪原因、监护教育等情况进行调查。 第二百八十条 对未成年犯罪嫌疑人、被告人应当严格限制适用逮捕措施。人民检察院审查批准逮捕和人民法院决定逮捕，应当讯问未成年犯罪嫌疑人、被告人，听取辩护律师的意见。 对被拘留、逮捕和执行刑罚的未成年人与成年人应当分别关押、分别管理、分别教育。 第二百八十一条 对于未成年人刑事案件，在讯问和审判的时候，应当通知未成年犯罪嫌疑人、被告人的法定代理人到场。无法通知、法定代理人不能到场或者法定代理人是共犯的，也可以通知未成年犯罪嫌疑人、被告人的其他成年亲属，所在学校、单位、居住地基层组织或者未成年人保护组织的代表到场，并将有关情况记录在案。到场的法定代理人可以代为行使未成年犯罪嫌疑人、被告人的诉讼权利。 到场的法定代理人或者其他人员认为办案人员在讯问、审判中侵犯未成年人合法权益的，可以提出意见。讯问笔录、法庭笔录应当交给到场的法定代理人或者其他人员阅读或者向他宣读。 讯问女性未成年犯罪嫌疑人，应当有女工作人员在场。 审判未成年人刑事案件，未成年被告人最后陈述后，其法定代理人可以进行补充陈述。 询问未成年被害人、证人，适用第一款、第二款、第三款的规定。 第二百八十二条 对于未成年人涉嫌刑法分则第四章、第五章、第六章规定的犯罪，可能判处一年有期徒刑以下刑罚，符合起诉条件，但有悔罪表现的，人民检察院可以作出附条件不起诉的决定。人民检察院在作出附条件不起诉的决定以前，应当听取公安机关、被害人的意见。 对附条件不起诉的决定，公安机关要求复议、提请复核或者被害人申诉的，适用本法第一百七十九条、第一百八十条的规定。 未成年犯罪嫌疑人及其法定代理人对人民检察院决定附条件不起诉有异议的，人民检察院应当作出起诉的决定。 第二百八十三条 在附条件不起诉的考验期内，由人民检察院对被附条件不起诉的未成年犯罪嫌疑人进行监督考察。未成年犯罪嫌疑人的监护人，应当对未成年犯罪嫌疑人加强管教，配合人民检察院做好监督考察工作。 附条件不起诉的考验期为六个月以上一年以下，从人民检察院作出附条件不起诉的决定之日起计算。 被附条件不起诉的未成年犯罪嫌疑人，应当遵守下列规定： （一）遵守法律法规，服从监督； （二）按照考察机关的规定报告自己的活动情况； （三）离开所居住的市、县或者迁居，应当报经考察机关批准； （四）按照考察机关的要求接受矫治和教育。 第二百八十四条 被附条件不起诉的未成年犯罪嫌疑人，在考验期内有下列情形之一的，人民检察院应当撤销附条件不起诉的决定，提起公诉： （一）实施新的犯罪或者发现决定附条件不起诉以前还有其他犯罪需要追诉的； （二）违反治安管理规定或者考察机关有关附条件不起诉的监督管理规定，情节严重的。 被附条件不起诉的未成年犯罪嫌疑人，在考验期内没有上述情形，考验期满的，人民检察院应当作出不起诉的决定。 第二百八十五条 审判的时候被告人不满十八周岁的案件，不公开审理。但是，经未成年被告人及其法定代理人同意，未成年被告人所在学校和未成年人保护组织可以派代表到场。 第二百八十六条 犯罪的时候不满十八周岁，被判处五年有期徒刑以下刑罚的，应当对相关犯罪记录予以封存。 犯罪记录被封存的，不得向任何单位和个人提供，但司法机关为办案需要或者有关单位根据国家规定进行查询的除外。依法进行查询的单位，应当对被封存的犯罪记录的情况予以保密。 第二百八十七条 办理未成年人刑事案件，除本章已有规定的以外，按照本法的其他规定进行。 第二章 当事人和解的公诉案件诉讼程序第二百八十八条 下列公诉案件，犯罪嫌疑人、被告人真诚悔罪，通过向被害人赔偿损失、赔礼道歉等方式获得被害人谅解，被害人自愿和解的，双方当事人可以和解： （一）因民间纠纷引起，涉嫌刑法分则第四章、第五章规定的犯罪案件，可能判处三年有期徒刑以下刑罚的； （二）除渎职犯罪以外的可能判处七年有期徒刑以下刑罚的过失犯罪案件。 犯罪嫌疑人、被告人在五年以内曾经故意犯罪的，不适用本章规定的程序。 第二百八十九条 双方当事人和解的，公安机关、人民检察院、人民法院应当听取当事人和其他有关人员的意见，对和解的自愿性、合法性进行审查，并主持制作和解协议书。 第二百九十条 对于达成和解协议的案件，公安机关可以向人民检察院提出从宽处理的建议。人民检察院可以向人民法院提出从宽处罚的建议；对于犯罪情节轻微，不需要判处刑罚的，可以作出不起诉的决定。人民法院可以依法对被告人从宽处罚。 第三章 缺席审判程序第二百九十一条 对于贪污贿赂犯罪案件，以及需要及时进行审判，经最高人民检察院核准的严重危害国家安全犯罪、恐怖活动犯罪案件，犯罪嫌疑人、被告人在境外，监察机关、公安机关移送起诉，人民检察院认为犯罪事实已经查清，证据确实、充分，依法应当追究刑事责任的，可以向人民法院提起公诉。人民法院进行审查后，对于起诉书中有明确的指控犯罪事实，符合缺席审判程序适用条件的，应当决定开庭审判。 前款案件，由犯罪地、被告人离境前居住地或者最高人民法院指定的中级人民法院组成合议庭进行审理。 第二百九十二条 人民法院应当通过有关国际条约规定的或者外交途径提出的司法协助方式，或者被告人所在地法律允许的其他方式，将传票和人民检察院的起诉书副本送达被告人。传票和起诉书副本送达后，被告人未按要求到案的，人民法院应当开庭审理，依法作出判决，并对违法所得及其他涉案财产作出处理。 第二百九十三条 人民法院缺席审判案件，被告人有权委托辩护人，被告人的近亲属可以代为委托辩护人。被告人及其近亲属没有委托辩护人的，人民法院应当通知法律援助机构指派律师为其提供辩护。 第二百九十四条 人民法院应当将判决书送达被告人及其近亲属、辩护人。被告人或者其近亲属不服判决的，有权向上一级人民法院上诉。辩护人经被告人或者其近亲属同意，可以提出上诉。 人民检察院认为人民法院的判决确有错误的，应当向上一级人民法院提出抗诉。 第二百九十五条 在审理过程中，被告人自动投案或者被抓获的，人民法院应当重新审理。 罪犯在判决、裁定发生法律效力后到案的，人民法院应当将罪犯交付执行刑罚。交付执行刑罚前，人民法院应当告知罪犯有权对判决、裁定提出异议。罪犯对判决、裁定提出异议的，人民法院应当重新审理。 依照生效判决、裁定对罪犯的财产进行的处理确有错误的，应当予以返还、赔偿。 第二百九十六条 因被告人患有严重疾病无法出庭，中止审理超过六个月，被告人仍无法出庭，被告人及其法定代理人、近亲属申请或者同意恢复审理的，人民法院可以在被告人不出庭的情况下缺席审理，依法作出判决。 第二百九十七条 被告人死亡的，人民法院应当裁定终止审理，但有证据证明被告人无罪，人民法院经缺席审理确认无罪的，应当依法作出判决。 人民法院按照审判监督程序重新审判的案件，被告人死亡的，人民法院可以缺席审理，依法作出判决。 第四章 犯罪嫌疑人、被告人逃匿、死亡案件违法所得的没收程序第二百九十八条 对于贪污贿赂犯罪、恐怖活动犯罪等重大犯罪案件，犯罪嫌疑人、被告人逃匿，在通缉一年后不能到案，或者犯罪嫌疑人、被告人死亡，依照刑法规定应当追缴其违法所得及其他涉案财产的，人民检察院可以向人民法院提出没收违法所得的申请。 公安机关认为有前款规定情形的，应当写出没收违法所得意见书，移送人民检察院。 没收违法所得的申请应当提供与犯罪事实、违法所得相关的证据材料，并列明财产的种类、数量、所在地及查封、扣押、冻结的情况。 人民法院在必要的时候，可以查封、扣押、冻结申请没收的财产。 第二百九十九条 没收违法所得的申请，由犯罪地或者犯罪嫌疑人、被告人居住地的中级人民法院组成合议庭进行审理。 人民法院受理没收违法所得的申请后，应当发出公告。公告期间为六个月。犯罪嫌疑人、被告人的近亲属和其他利害关系人有权申请参加诉讼，也可以委托诉讼代理人参加诉讼。 人民法院在公告期满后对没收违法所得的申请进行审理。利害关系人参加诉讼的，人民法院应当开庭审理。 第三百条 人民法院经审理，对经查证属于违法所得及其他涉案财产，除依法返还被害人的以外，应当裁定予以没收；对不属于应当追缴的财产的，应当裁定驳回申请，解除查封、扣押、冻结措施。 对于人民法院依照前款规定作出的裁定，犯罪嫌疑人、被告人的近亲属和其他利害关系人或者人民检察院可以提出上诉、抗诉。 第三百零一条 在审理过程中，在逃的犯罪嫌疑人、被告人自动投案或者被抓获的，人民法院应当终止审理。 没收犯罪嫌疑人、被告人财产确有错误的，应当予以返还、赔偿。 第五章 依法不负刑事责任的精神病人的强制医疗程序第三百零二条 实施暴力行为，危害公共安全或者严重危害公民人身安全，经法定程序鉴定依法不负刑事责任的精神病人，有继续危害社会可能的，可以予以强制医疗。 第三百零三条 根据本章规定对精神病人强制医疗的，由人民法院决定。 公安机关发现精神病人符合强制医疗条件的，应当写出强制医疗意见书，移送人民检察院。对于公安机关移送的或者在审查起诉过程中发现的精神病人符合强制医疗条件的，人民检察院应当向人民法院提出强制医疗的申请。人民法院在审理案件过程中发现被告人符合强制医疗条件的，可以作出强制医疗的决定。 对实施暴力行为的精神病人，在人民法院决定强制医疗前，公安机关可以采取临时的保护性约束措施。 第三百零四条 人民法院受理强制医疗的申请后，应当组成合议庭进行审理。 人民法院审理强制医疗案件，应当通知被申请人或者被告人的法定代理人到场。被申请人或者被告人没有委托诉讼代理人的，人民法院应当通知法律援助机构指派律师为其提供法律帮助。 第三百零五条 人民法院经审理，对于被申请人或者被告人符合强制医疗条件的，应当在一个月以内作出强制医疗的决定。 被决定强制医疗的人、被害人及其法定代理人、近亲属对强制医疗决定不服的，可以向上一级人民法院申请复议。 第三百零六条 强制医疗机构应当定期对被强制医疗的人进行诊断评估。对于已不具有人身危险性，不需要继续强制医疗的，应当及时提出解除意见，报决定强制医疗的人民法院批准。 被强制医疗的人及其近亲属有权申请解除强制医疗。 第三百零七条 人民检察院对强制医疗的决定和执行实行监督。 附则第三百零八条 军队保卫部门对军队内部发生的刑事案件行使侦查权。 中国海警局履行海上维权执法职责，对海上发生的刑事案件行使侦查权。 对罪犯在监狱内犯罪的案件由监狱进行侦查。 军队保卫部门、中国海警局、监狱办理刑事案件，适用本法的有关规定。","link":"/posts/a49f841a/"},{"title":"中华人民共和国国旗法","text":"基本信息 发文字号：主席令第18号 效力级别：法律 时效性：现行有效 发布日期：2009-08-27 实施日期：2009-08-27 发布机关：全国人大常委会 法律修订 1990年6月28日第七届全国人民代表大会常务委员会第十四次会议通过 1990年6月28日中华人民共和国主席令第28号公布 自1990年10月1日起施行 根据2009年8月27日第十一届全国人民代表大会常务委员会第十次会议通过的《全国人民代表大会常务委员会关于修改部分法律的决定》修正 中华人民共和国国旗法（1990修正） 正文 第一条 为了维护国旗的尊严，增强公民的国家观念，发扬爱国主义精神，根据宪法，制定本法。 第二条 中华人民共和国国旗是五星红旗。 中华人民共和国国旗按照中国人民政治协商会议第一届全体会议主席团公布的国旗制法说明制作。 第三条 中华人民共和国国旗是中华人民共和国的象征和标志。 每个公民和组织，都应当尊重和爱护国旗。 第四条 地方各级人民政府对本行政区域内国旗的升挂和使用，实施监督管理。 外交部、国务院交通主管部门、中国人民解放军总政治部对各自管辖范围内国旗的升挂和使用，实施监督管理。 国旗由省、自治区、直辖市的人民政府指定的企业制作。 第五条 下列场所或者机构所在地，应当每日升挂国旗： （一）北京天安门广场、新华门； （二）全国人民代表大会常务委员会，国务院，中央军事委员会，最高人民法院，最高人民检察院； 中国人民政治协商会议全国委员会； （三）外交部； （四）出境入境的机场、港口、火车站和其他边境口岸，边防海防哨所。 第六条 国务院各部门，地方各级人民代表大会常务委员会、人民政府、人民法院、人民检察院，中国人民政治协商会议地方各级委员会，应当在工作日升挂国旗。 全日制学校，除寒假、暑假和星期日外，应当每日升挂国旗。 第七条 国庆节、国际劳动节、元旦和春节，各级国家机关和各人民团体应当升挂国旗；企业事业组织，村民委员会、居民委员会，城镇居民院（楼）以及广场、公园等公共活动场所，有条件的可以升挂国旗。 不以春节为传统节日的少数民族地区，春节是否升挂国旗，由民族自治地方的自治机关规定。 民族自治地方在民族自治地方成立纪念日和主要传统民族节日，可以升挂国旗。 第八条 举行重大庆祝、纪念活动，大型文化、体育活动，大型展览会，可以升挂国旗。 第九条 外交活动以及国家驻外使馆领馆和其他外交代表机构升挂、使用国旗的办法，由外交部规定。 第十条 军事机关、军队营区、军用舰船，按照中央军事委员会的有关规定升挂国旗。 第十一条 民用船舶和进入中国领水的外国船舶升挂国旗的办法，由国务院交通主管部门规定。 公安部门执行边防、治安、消防任务的船舶升挂国旗的办法，由国务院公安部门规定。 第十二条 依照本法第五条、第六条、第七条的规定升挂国旗的，应当早晨升起，傍晚降下。 依照本法规定应当升挂国旗的，遇有恶劣天气，可以不升挂。 第十三条 升挂国旗时，可以举行升旗仪式。 举行升旗仪式时，在国旗升起的过程中，参加者应当面向国旗肃立致敬，并可以奏国歌或者唱国歌。 全日制中学小学，除假期外，每周举行一次升旗仪式。 第十四条 下列人士逝世，下半旗志哀： （一）中华人民共和国主席、全国人民代表大会常务委员会委员长、国务院总理、中央军事委员会主席； （二）中国人民政治协商会议全国委员会主席； （三）对中华人民共和国作出杰出贡献的人； （四）对世界和平或者人类进步事业作出杰出贡献的人。 发生特别重大伤亡的不幸事件或者严重自然灾害造成重大伤亡时，可以下半旗志哀。 依照本条第一款（三）、（四）项和第二款的规定下半旗，由国务院决定。 依照本条规定下半旗的日期和场所，由国家成立的治丧机构或者国务院决定。 第十五条 升挂国旗，应当将国旗置于显著的位置。 列队举持国旗和其他旗帜行进时，国旗应当在其他旗帜之前。 国旗与其他旗帜同时升挂时，应当将国旗置于中心、较高或者突出的位置。 在外事活动中同时升挂两个以上国家的国旗时，应当按照外交部的规定或者国际惯例升挂。 第十六条 在直立的旗杆上升降国旗，应当徐徐升降。升起时，必须将国旗升至杆顶；降下时，不得使国旗落地。 下半旗时，应当先将国旗升至杆顶，然后降至旗顶与杆顶之间的距离为旗杆全长的三分之一处；降下时，应当先将国旗升至杆顶，然后再降下。 第十七条 不得升挂破损、污损、褪色或者不合规格的国旗。 第十八条 国旗及其图案不得用作商标和广告，不得用于私人丧事活动。 第十九条 在公共场合故意以焚烧、毁损、涂划、玷污、践踏等方式侮辱中华人民共和国国旗的，依法追究刑事责任；情节较轻的，由公安机关处以十五日以下拘留。 第二十条 本法自1990年10月1日起施行。","link":"/posts/79e097c3/"},{"title":"中华人民共和国婚姻法","text":"基本信息 效力级别法律：时效性现行有效 发布日期：2001-04-28 实施日期：2001-04-28 发布机关：全国人大常委会 法律修订 １９８０年９月１０日第五届全国人民代表大会第三次会议通过 根据２００１年４月２８日第九届全国人民代表大会常务委员会第二十一次会议《关于修改〈中华人民共和国婚姻法〉的决定》修正 中华人民共和国婚姻法（1980修正） 中华人民共和国婚姻法（1950修正） 正文 第一章 总则第一条 立法目的 本法是婚姻家庭关系的基本准则。 第二条 婚姻制度 实行婚姻自由、一夫一妻、男女平等的婚姻制度。 保护妇女、儿童和老人的合法权益。 实行计划生育。 第三条 禁止的婚姻行为 禁止包办、买卖婚姻和其他干涉婚姻自由的行为。禁止借婚姻索取财物。 禁止重婚。禁止有配偶者与他人同居。禁止家庭暴力。禁止家庭成员间的虐待和遗弃。 第四条 家庭关系 夫妻应当互相忠实，互相尊重；家庭成员间应当敬老爱幼，互相帮助，维护平等、和睦、文明的婚姻家庭关系。 第二章 结婚第五条 结婚自愿 结婚必须男女双方完全自愿，不许任何一方对他方加以强迫或任何第三者加以干涉。 第六条 法定婚龄 结婚年龄，男不得早于二十二周岁，女不得早于二十周岁。晚婚晚育应予鼓励。 第七条 禁止结婚 有下列情形之一的，禁止结婚： （一）直系血亲和三代以内的旁系血亲； （二）患有医学上认为不应当结婚的疾病。 第八条 结婚登记 要求结婚的男女双方必须亲自到婚姻登记机关进行结婚登记。符合本法规定的，予以登记，发给结婚证。取得结婚证，即确立夫妻关系。未办理结婚登记的，应当补办登记。 第九条 互为家庭成员 登记结婚后，根据男女双方约定，女方可以成为男方家庭的成员，男方可以成为女方家庭的成员。 第十条 婚姻无效 有下列情形之一的，婚姻无效： （一）重婚的； （二）有禁止结婚的亲属关系的； （三）婚前患有医学上认为不应当结婚的疾病，婚后尚未治愈的； （四）未到法定婚龄的。 第十一条 胁迫结婚 因胁迫结婚的，受胁迫的一方可以向婚姻登记机关或人民法院请求撤销该婚姻。受胁迫的一方撤销婚姻的请求，应当自结婚登记之日起一年内提出。被非法限制人身自由的当事人请求撤销婚姻的，应当自恢复人身自由之日起一年内提出。 第十二条 婚姻的无效 无效或被撤销的婚姻，自始无效。当事人不具有夫妻的权利和义务。同居期间所得的财产，由当事人协议处理；协议不成时，由人民法院根据照顾无过错方的原则判决。对重婚导致的婚姻无效的财产处理，不得侵害合法婚姻当事人的财产权益。当事人所生的子女，适用本法有关父母子女的规定。 第三章 家庭关系第十三条 夫妻平等 夫妻在家庭中地位平等。 第十四条 夫妻姓名权 夫妻双方都有各用自己姓名的权利。 第十五条 夫妻的自由 夫妻双方都有参加生产、工作、学习和社会活动的自由，一方不得对他方加以限制或干涉。 第十六条 计划生育义务 夫妻双方都有实行计划生育的义务。 第十七条 夫妻共有财产 夫妻在婚姻关系存续期间所得的下列财产，归夫妻共同所有： （一）工资、奖金； （二）生产、经营的收益； （三）知识产权的收益； （四）继承或赠与所得的财产，但本法第十八条第三项规定的除外； （五）其他应当归共同所有的财产。 夫妻对共同所有的财产，有平等的处理权。 第十八条 夫妻一方的财产 有下列情形之一的，为夫妻一方的财产： （一）一方的婚前财产； （二）一方因身体受到伤害获得的医疗费、残疾人生活补助费等费用； （三）遗嘱或赠与合同中确定只归夫或妻一方的财产； （四）一方专用的生活用品； （五）其他应当归一方的财产。 第十九条 夫妻财产约定 夫妻可以约定婚姻关系存续期间所得的财产以及婚前财产归各自所有、共同所有或部分各自所有、部分共同所有。约定应当采用书面形式。没有约定或约定不明确的，适用本法第十七条、第十八条的规定。 夫妻对婚姻关系存续期间所得的财产以及婚前财产的约定，对双方具有约束力。 夫妻对婚姻关系存续期间所得的财产约定归各自所有的，夫或妻一方对外所负的债务，第三人知道该约定的，以夫或妻一方所有的财产清偿。 第二十条 夫妻扶养义务 夫妻有互相扶养的义务。 一方不履行扶养义务时，需要扶养的一方，有要求对方付给扶养费的权利。 第二十一条 父母与子女 父母对子女有抚养教育的义务；子女对父母有赡养扶助的义务。 父母不履行抚养义务时，未成年的或不能独立生活的子女，有要求父母付给抚养费的权利。 子女不履行赡养义务时，无劳动能力的或生活困难的父母，有要求子女付给赡养费的权利。 禁止溺婴、弃婴和其他残害婴儿的行为。 第二十二条 子女的姓 子女可以随父姓，可以随母姓。 第二十三条 父母对子女的保护和教育 父母有保护和教育未成年子女的权利和义务。在未成年子女对国家、集体或他人造成损害时，父母有承担民事责任的义务。 第二十四条 继承遗产 夫妻有相互继承遗产的权利。 父母和子女有相互继承遗产的权利。 第二十五条 非婚生子女 非婚生子女享有与婚生子女同等的权利，任何人不得加以危害和歧视。 不直接抚养非婚生子女的生父或生母，应当负担子女的生活费和教育费，直至子女能独立生活为止。 第二十六条 收养关系 国家保护合法的收养关系。养父母和养子女间的权利和义务，适用本法对父母子女关系的有关规定。 养子女和生父母间的权利和义务，因收养关系的成立而消除。 第二十七条 继父母与继子女 继父母与继子女间，不得虐待或歧视。 继父或继母和受其抚养教育的继子女间的权利和义务，适用本法对父母子女关系的有关规定。 第二十八条 祖与孙 有负担能力的祖父母、外祖父母，对于父母已经死亡或父母无力抚养的未成年的孙子女、外孙子女，有抚养的义务。有负担能力的孙子女、外孙子女，对于子女已经死亡或子女无力赡养的祖父母、外祖父母，有赡养的义务。 第二十九条 兄姐与弟妹 有负担能力的兄、姐，对于父母已经死亡或父母无力抚养的未成年的弟、妹，有扶养的义务。由兄、姐扶养长大的有负担能力的弟、妹，对于缺乏劳动能力又缺乏生活来源的兄、姐，有扶养的义务。 第三十条 尊重父母婚姻 子女应当尊重父母的婚姻权利，不得干涉父母再婚以及婚后的生活。子女对父母的赡养义务，不因父母的婚姻关系变化而终止。 第四章 离婚第三十一条 自愿离婚 男女双方自愿离婚的，准予离婚。双方必须到婚姻登记机关申请离婚。婚姻登记机关查明双方确实是自愿并对子女和财产问题已有适当处理时，发给离婚证。 第三十二条 离婚诉讼 男女一方要求离婚的，可由有关部门进行调解或直接向人民法院提出离婚诉讼。 人民法院审理离婚案件，应当进行调解；如感情确已破裂，调解无效，应准予离婚。 有下列情形之一，调解无效的，应准予离婚： （一）重婚或有配偶者与他人同居的； （二）实施家庭暴力或虐待、遗弃家庭成员的； （三）有赌博、吸毒等恶习屡教不改的； （四）因感情不和分居满二年的； （五）其他导致夫妻感情破裂的情形。 一方被宣告失踪，另一方提出离婚诉讼的，应准予离婚。 第三十三条 军人配偶要求离婚 现役军人的配偶要求离婚，须得军人同意，但军人一方有重大过错的除外。 第三十四条 不得提出离婚 女方在怀孕期间、分娩后一年内或中止妊娠后六个月内，男方不得提出离婚。女方提出离婚的，或人民法院认为确有必要受理男方离婚请求的，不在此限。 第三十五条 复婚 离婚后，男女双方自愿恢复夫妻关系的，必须到婚姻登记机关进行复婚登记。 第三十六条 离婚与子女 父母与子女间的关系，不因父母离婚而消除。离婚后，子女无论由父或母直接抚养，仍是父母双方的子女。 离婚后，父母对于子女仍有抚养和教育的权利和义务。 离婚后，哺乳期内的子女，以随哺乳的母亲抚养为原则。哺乳期后的子女，如双方因抚养问题发生争执不能达成协议时，由人民法院根据子女的权益和双方的具体情况判决。 第三十七条 离婚后的子女抚养 离婚后，一方抚养的子女，另一方应负担必要的生活费和教育费的一部或全部，负担费用的多少和期限的长短，由双方协议；协议不成时，由人民法院判决。 关于子女生活费和教育费的协议或判决，不妨碍子女在必要时向父母任何一方提出超过协议或判决原定数额的合理要求。 第三十八条 离婚后的子女探望 离婚后，不直接抚养子女的父或母，有探望子女的权利，另一方有协助的义务。 行使探望权利的方式、时间由当事人协议；协议不成时，由人民法院判决。 父或母探望子女，不利于子女身心健康的，由人民法院依法中止探望的权利；中止的事由消失后，应当恢复探望的权利。 第三十九条 夫妻共同财产的离婚处理 离婚时，夫妻的共同财产由双方协议处理；协议不成时，由人民法院根据财产的具体情况，照顾子女和女方权益的原则判决。 夫或妻在家庭土地承包经营中享有的权益等，应当依法予以保护。 第四十条 补偿 夫妻书面约定婚姻关系存续期间所得的财产归各自所有，一方因抚育子女、照料老人、协助另一方工作等付出较多义务的，离婚时有权向另一方请求补偿，另一方应当予以补偿。 第四十一条 共同债务 离婚时，原为夫妻共同生活所负的债务，应当共同偿还。共同财产不足清偿的，或财产归各自所有的，由双方协议清偿；协议不成时，由人民法院判决。 第四十二条 适当帮助 离婚时，如一方生活困难，另一方应从其住房等个人财产中给予适当帮助。具体办法由双方协议；协议不成时，由人民法院判决。 第五章 救助措施与法律责任第四十三条 家庭暴力与虐待 实施家庭暴力或虐待家庭成员，受害人有权提出请求，居民委员会、村民委员会以及所在单位应当予以劝阻、调解。 对正在实施的家庭暴力，受害人有权提出请求，居民委员会、村民委员会应当予以劝阻；公安机关应当予以制止。 实施家庭暴力或虐待家庭成员，受害人提出请求的，公安机关应当依照治安管理处罚的法律规定予以行政处罚。 第四十四条 遗弃 对遗弃家庭成员，受害人有权提出请求，居民委员会、村民委员会以及所在单位应当予以劝阻、调解。 对遗弃家庭成员，受害人提出请求的，人民法院应当依法作出支付扶养费、抚养费、赡养费的判决。 第四十五条 家庭暴力、虐待、遗弃犯罪 对重婚的，对实施家庭暴力或虐待、遗弃家庭成员构成犯罪的，依法追究刑事责任。受害人可以依照刑事诉讼法的有关规定，向人民法院自诉；公安机关应当依法侦查，人民检察院应当依法提起公诉。 第四十六条 损害赔偿 有下列情形之一，导致离婚的，无过错方有权请求损害赔偿： （一）重婚的； （二）有配偶者与他人同居的； （三）实施家庭暴力的； （四）虐待、遗弃家庭成员的。 第四十七条 隐藏、转移共同财产等 离婚时，一方隐藏、转移、变卖、毁损夫妻共同财产，或伪造债务企图侵占另一方财产的，分割夫妻共同财产时，对隐藏、转移、变卖、毁损夫妻共同财产或伪造债务的一方，可以少分或不分。离婚后，另一方发现有上述行为的，可以向人民法院提起诉讼，请求再次分割夫妻共同财产。 人民法院对前款规定的妨害民事诉讼的行为，依照民事诉讼法的规定予以制裁。 第四十八条 强制执行 对拒不执行有关扶养费、抚养费、赡养费、财产分割、遗产继承、探望子女等判决或裁定的，由人民法院依法强制执行。有关个人和单位应负协助执行的责任。 第四十九条 婚姻家庭的其他违法 其他法律对有关婚姻家庭的违法行为和法律责任另有规定的，依照其规定。 第六章 附则第五十条 变通规定 民族自治地方的人民代表大会有权结合当地民族婚姻家庭的具体情况，制定变通规定。自治州、自治县制定的变通规定，报省、自治区、直辖市人民代表大会常务委员会批准后生效。自治区制定的变通规定，报全国人民代表大会常务委员会批准后生效。","link":"/posts/79431e7f/"},{"title":"中华人民共和国消费者权益保护法","text":"基本信息 发文字号：主席令第11号 效力级别：法律 时效性：已被修订 发布日期：1993-10-31 实施日期：1994-01-01 发布机关：全国人大常委会 法律修订 １９９３年１０月３１日第八届全国人民代表大会常务委员会第四次会议通过 中华人民共和国消费者权益保护法（2013修正） 中华人民共和国消费者权益保护法（2009修正） 正文 第一章 总则第一条 为保护消费者的合法权益，维护社会经济秩序，促进社会主义市场经济健康发展，制定本法。 第二条 消费者为生活消费需要购买、使用商品或者接受服务，其权益受本法保护；本法未作规定的，受其他有关法律、法规保护。 第三条 经营者为消费者提供其生产、销售的商品或者提供服务，应当遵守本法；本法未作出规定的，应当遵守其他有关法律、法规。 第四条 经营者与消费者进行交易，应当遵循自愿、平等、公平、诚实信用的原则。 第五条 国家保护消费者的合法权益不受侵害。 国家采取措施，保障消费者依法行使权利，维护消费者的合法权益。 第六条 保护消费者的合法权益是全社会的共同责任。 国家鼓励、支持一切组织和个人对损害消费者合法权益的行为进行社会监督。 大众传播媒介应当做好维护消费者合法权益的宣传，对损害消费者合法权益的行为进行舆论监督。 第二章 消费者的权利第七条 消费者在购买、使用商品和接受服务时享有人身、财产安全不受损害的权利。 消费者有权要求经营者提供的商品和服务，符合保障人身、财产安全的要求。 第八条 消费者享有知悉其购买、使用的商品或者接受的服务的真实情况的权利。 消费者有权根据商品或者服务的不同情况，要求经营者提供商品的价格、产地、生产者、用途、性能、规格、等级、主要成份、生产日期、有效期限、检验合格证明、使用方法说明书、售后服务，或者服务的内容、规格、费用等有关情况。 第九条 消费者享有自主选择商品或者服务的权利。 消费者有权自主选择提供商品或者服务的经营者，自主选择商品品种或者服务方式，自主决定购买或者不购买任何一种商品、接受或者不接受任何一项服务。 消费者在自主选择商品或者服务时，有权进行比较、鉴别和挑选。 第十条 消费者享有公平交易的权利。 消费者在购买商品或者接受服务时，有权获得质量保障、价格合理、计量正确等公平交易条件，有权拒绝经营者的强制交易行为。 第十一条 消费者因购买、使用商品或者接受服务受到人身、财产损害的，享有依法获得赔偿的权利。 第十二条 消费者享有依法成立维护自身合法权益的社会团体的权利。 第十三条 消费者享有获得有关消费和消费者权益保护方面的知识的权利。 消费者应当努力掌握所需商品或者服务的知识和使用技能，正确使用商品，提高自我保护意识。 第十四条 消费者在购买、使用商品和接受服务时，享有其人格尊严、民族风俗习惯得到尊重的权利。 第十五条 消费者享有对商品和服务以及保护消费者权益工作进行监督的权利。 消费者有权检举、控告侵害消费者权益的行为和国家机关及其工作人员在保护消费者权益工作中的违法失职行为，有权对保护消费者权益工作提出批评、建议。 第三章 经营者的义务第十六条 经营者向消费者提供商品或者服务，应当依照《中华人民共和国产品质量法》和其他有关法律、法规的规定履行义务。 经营者和消费者有约定的，应当按照约定履行义务，但双方的约定不得违背法律、法规的规定。 第十七条 经营者应当听取消费者对其提供的商品或者服务的意见，接受消费者的监督。 第十八条 经营者应当保证其提供的商品或者服务符合保障人身、财产安全的要求。对可能危及人身、财产安全的商品和服务，应当向消费者作出真实的说明和明确的警示，并说明和标明正确使用商品或者接受服务的方法以及防止危害发生的方法。 经营者发现其提供的商品或者服务存在严重缺陷，即使正确使用商品或者接受服务仍然可能对人身、财产安全造成危害的，应当立即向有关行政部门报告和告知消费者，并采取防止危害发生的措施。 第十九条 经营者应当向消费者提供有关商品或者服务的真实信息，不得作引人误解的虚假宣传。 经营者对消费者就其提供的商品或者服务的质量和使用方法等问题提出的询问，应当作为真实、明确的答复。 商店提供商品应当明码标价。 第二十条 经营者应当标明其真实名称和标记。 租赁他人柜台或者场地的经营者，应当标明其真实名称和标记。 第二十一条 经营者提供商品或者服务，应当按照国家有关规定或者商业惯例向消费者出具购货凭证或者服务单据；消费者索要购货凭证或者服务单据的，经营者必须出具。 第二十二条 经营者应当保证在正常使用商品或者接受服务的情况下其提供的商品或者服务应当具有的质量、性能、用途和有效期限；但消费者在购买该商品或者接受该服务前已经知道其存在瑕疵的除外。 经营者以广告、产品说明、实物样品或者其他方式表明商品或者服务的质量状况的，应当保证其提供的商品或者服务的实际质量与表明的质量状况相符。 第二十三条 经营者提供商品或者服务，按照国家规定或者与消费者的约定，承担包修、包换、包退或者其他责任的，应当按照国家规定或者约定履行，不得故意拖延或者无理拒绝。 第二十四条 经营者不得以格式合同、通知、声明、店堂告示等方式作出对消费者不公平、不合理的规定，或者减轻、免除其损害消费者合法权益应当承担的民事责任。 格式合同、通知、声明、店堂告示等含有前款所列内容的，其内容无效。 第二十五条 经营者不得对消费者进行侮辱、诽谤，不得搜查消费者的身体及其携带的物品，不得侵犯消费者的人身自由。 第四章 国家对消费者合法权益的保护第二十六条 国家制定有关消费者权益的法律、法规和政策时，应听取消费者的意见和要求。 第二十七条 各级人民政府应当加强领导，组织、协调、督促有关行政部门做好保护消费者合法权益的工作。 各级人民政府应当加强监督，预防危害消费者人身、财产安全行为的发生，及时制止危害消费者人身、财产安全的行为。 第二十八条 各级人民政府工商行政管理部门和其他有关行政部门应当依照法律、法规的规定，在各自的职责范围内，采取措施，保护消费者的合法权益。 有关行政部门应当听取消费者及其社会团体对经营者交易行为、商品和服务质量问题的意见，及时调查处理。 第二十九条 有关国家机关应当依照法律、法规的规定，惩处经营者在提供商品和服务中侵害消费者合法权益的违法犯罪行为。 第三十条 人民法院应当采取措施，方便消费者提起诉讼。对符合《中华人民共和国民事诉讼法》起诉条件的消费者权益争议，必须受理，及时审理。 第五章 消费者组织第三十一条 消费者协会和其他消费者组织是依法成立的对商品和服务进行社会监督的保护消费者合法权益的社会团体。 第三十二条 消费者协会履行下列职能： （一）向消费者提供消费信息和咨询服务； （二）参与有关行政部门对商品和服务的监督、检查； （三）就有关消费者合法权益的问题，向有关行政部门反映、查询，提出建议； （四）受理消费者的投诉，并对投诉事项进行调查、调解； （五）投诉事项涉及商品和服务质量问题的，可以提请鉴定部门鉴定，鉴定部门应当告知鉴定结论； （六）就损害消费者合法权益的行为，支持受损害的消费者提起诉讼； （七）对损害消费者合法权益的行为，通过大众传播媒介予以揭露、批评。 各级人民政府对消费者协会履行职能应当予以支持。 第三十三条 消费者组织不得从事商品经营和营利性服务，不得以牟利为目的向社会推荐商品和服务。 第六章 争议的解决第三十四条 消费者和经营者发生消费者权益争议的，可以通过下列途径解决： （一）与经营者协商和解； （二）请求消费者协会调解； （三）向有关行政部门申诉； （四）根据与经营者达成的仲裁协议提请仲裁机构仲裁； （五）向人民法院提起诉讼。 第三十五条 消费者在购买、使用商品时，其合法权益受到损害的，可以向销售者要求赔偿。销售者赔偿后，属于生产者的责任或者属于向销售者提供商品的其他销售者的责任的，销售者有权向生产者或者其他销售者追偿。 消费者或者其他受害人因商品缺陷造成人身、财产损害的，可以向销售者要求赔偿，也可以向生产者要求赔偿。属于生产者责任的，销售者赔偿后，有权向生产者追偿。属于销售者责任的，生产者赔偿后，有权向销售者追偿。 消费者在接受服务时，其合法权益受到损害的，可以向服务者要求赔偿。 第三十六条 消费者在购买、使用商品或者接受服务时，其合法权益受到损害，因原企业分立、合并的，可以向变更后承受其权利义务的企业要求赔偿。 第三十七条 使用他人营业执照的违法经营者提供商品或者服务，损害消费者合法权益的，消费者可以向其要求赔偿，也可以向营业执照的持有人要求赔偿。 第三十八条 消费者在展销会、租赁柜台购买商品或者接受服务，其合法权益受到损害的，可以向销售者或者服务者要求赔偿。展销会结束或者柜台租赁期满后，也可以向展销会的举办者、柜台的出租者要求赔偿。展销会的举办者、柜台的出租者赔偿后，有权向销售者或者服务者追偿。 第三十九条 消费者因经营者利用虚假广告提供商品或者服务，其合法权益受到损害的，可以向经营者要求赔偿。广告的经营者发布虚假广告的，消费者可以请求行政主管部门予以惩处。广告的经营者不得提供经营者的真实名称、地址的，应当承担赔偿责任。 第七章 法律责任第四十条 经营者提供商品或者服务有下列情形之一的，除本法另有规定外，应当依照《中华人民共和国产品质量法》和其他有关法律、法规的规定，承担民事责任： （一）商品存在缺陷的； （二）不具备商品应当具备的使用性能而出售时未作说明的； （三）不符合在商品或者其包装上注明采用的商品标准的； （四）不符合商品说明、实物样品等方式表明的质量状况的； （五）生产国家明令淘汰的商品或者销售失效、变质的商品的； （六）销售的商品数量不足的； （七）服务的内容和费用违反约定的； （八）对消费者提出的修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失的要求，故意拖延或者无理拒绝的； （九）法律、法规规定的其他损害消费者权益的情形。 第四十一条 经营者提供商品或者服务，造成消费者或者其他受害人人身伤害的，应当支付医疗费、治疗期间的护理费、因误工减少的收入等费用，造成残疾的，还应当支付残疾者生活自助具费、生活补助费、残疾赔偿金以及由其扶养的人所必需的生活费等费用；构成犯罪的，依法追究刑事责任。 第四十二条 经营者提供商品或者服务，造成消费者或者其他受害人死亡的，应当支付丧葬费、死亡赔偿金以及由死者生前扶养的人所必需的生活费等费用；构成犯罪的，依法追究刑事责任。 第四十三条 经营者违反本法第二十五条规定，侵害消费者的人格尊严或者侵犯消费者人身自由的，应当停止侵害、恢复名誉、消除影响、赔礼道歉，并赔偿损失。 第四十四条 经营者提供商品或者服务，造成消费者财产损害的，应当按照消费者的要求，以修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失等方式承担民事责任。消费者与经营者另有约定的，按照约定履行。 第四十五条 对国家规定或者经营者与消费者约定包修、包换、包退的商品，经营者应当负责修理、更换或者退货。在保修期内两次修理仍不能正常使用的，经营者应当负责更换或者退货。 对包修、包换、包退的大件商品，消费者要求经营者修理、更换、退货的，经营者应当承担运输等合理费用。 第四十六条 经营者以邮购方式提供商品的，应当按照约定提供。未按照约定提供的，应当按照消费者的要求履行约定或者退回货款；并应当承担消费者必须支付的合理费用。 第四十七条 经营者以预收款方式提供商品或者服务的，应当按照约定提供。未按照约定提供的，应当按照消费者的要求履行约定或者退回预付款；并应当承担预付款的利息、消费者必须支付的合理费用。 第四十八条 依法经有关行政部门认定为不合格的商品，消费者要求退货的，经营者应当负责退货。 第四十九条 经营者提供商品或者服务有欺诈行为的，应当按照消费者的要求增加赔偿其受到的损失，增加赔偿的金额为消费者购买商品的价款或者接受服务的费用的一倍。 第五十条 经营者有下列情形之一，《中华人民共和国产品质量法》和其他有关法律、法规对处罚机关和处罚方式有规定的，依照法律、法规的规定执行；法律、法规未作规定的，由工商行政管理部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处以违法所得一倍以上五倍以下的罚款，没有违法所得的处以一万元以下的罚款；情节严重的，责令停业整顿、吊销营业执照： （一）生产、销售的商品不符合保障人身、财产安全要求的； （二）在商品中掺杂、掺假，以假充真，以次充好，或者以不合格商品冒充合格商品的； （三）生产国家明令淘汰的商品或者销售失效、变质的商品的； （四）伪造商品的产地，伪造或者冒用他人的厂名、厂址，伪造或者冒用认证标志、名优标志等质量标志的； （五）销售的商品应当检验、检疫而未检验、检疫或者伪造检验、检疫结果的； （六）对商品或者服务作引人误解的虚假宣传的； （七）对消费者提出的修理、重作、更换、退货、补足商品数量、退还货款和服务费用或者赔偿损失的要求，故意拖延或者无理拒绝的； （八）侵害消费者人格尊严或者侵犯消费者人身自由的； （九）法律、法规规定的对损害消费者权益应当予以处罚的其他情形。 第五十一条 经营者对行政处罚决定不服的，可以自收到处罚决定之日起十五日内向上一级机关申请复议，对复议决定不服的，可以自收到复议决定书之日起十五日内向人民法院提起诉讼；也可以直接向人民法院提起诉讼。 第五十二条 以暴力、威胁等方法阻碍有关行政部门工作人员依法执行职务的，依法追究刑事责任；拒绝、阻碍有关行政部门工作人员依法执行职务，未使用暴力、威胁方法的，由公安机关依照《中华人民共和国治安管理处罚条例》的规定处罚。 第五十三条 国家机关工作人员玩忽职守或者包庇经营者侵害消费者合法权益的行为的，由其所在单位或者上级机关给予行政处分；情节严重，构成犯罪的，依法追究刑事责任。 第八章 附则第五十四条 农民购买、使用直接用于农业生产的生产资料，参照本法执行。 第五十五条 本法自１９９４年１月１日起施行。","link":"/posts/945e951b/"},{"title":"中华人民共和国网络安全法","text":"《中华人民共和国网络安全法》是为保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展制定。由全国人民代表大会常务委员会于2016年11月7日发布，自2017年6月1日起施行。 中华人民共和国网络安全法中文名：中华人民共和国网络安全法 外文名：People’s Republic of China Network Security Law 发布机构：全国人民代表大会常务委员会 发布日期：2016年11月7日 实施日期：2017年6月1日 ​ 第一章 总 则 ​ 第二章 网络安全支持与促进 ​ 第三章 网络运行安全 ​ 第一节 一般规定 ​ 第二节 关键信息基础设施的运行安全 ​ 第四章 网络信息安全 ​ 第五章 监测预警与应急处置 ​ 第六章 法律责任 ​ 第七章 附 则 ### 第一章 总 则 **第一条** 为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展，制定本法。 第二条 在中华人民共和国境内建设、运营、维护和使用网络，以及网络安全的监督管理，适用本法。 第三条 国家坚持网络安全与信息化发展并重，遵循积极利用、科学发展、依法管理、确保安全的方针，推进网络基础设施建设和互联互通，鼓励网络技术创新和应用，支持培养网络安全人才，建立健全网络安全保障体系，提高网络安全保护能力。 第四条 国家制定并不断完善网络安全战略，明确保障网络安全的基本要求和主要目标，提出重点领域的网络安全政策、工作任务和措施。 第五条 国家采取措施，监测、防御、处置来源于中华人民共和国境内外的网络安全风险和威胁，保护关键信息基础设施免受攻击、侵入、干扰和破坏，依法惩治网络违法犯罪活动，维护网络空间安全和秩序。 第六条 国家倡导诚实守信、健康文明的网络行为，推动传播社会主义核心价值观，采取措施提高全社会的网络安全意识和水平，形成全社会共同参与促进网络安全的良好环境。 第七条 国家积极开展网络空间治理、网络技术研发和标准制定、打击网络违法犯罪等方面的国际交流与合作，推动构建和平、安全、开放、合作的网络空间，建立多边、民主、透明的网络治理体系。 第八条 国家网信部门负责统筹协调网络安全工作和相关监督管理工作。国务院电信主管部门、公安部门和其他有关机关依照本法和有关法律、行政法规的规定，在各自职责范围内负责网络安全保护和监督管理工作。 县级以上地方人民政府有关部门的网络安全保护和监督管理职责，按照国家有关规定确定。 第九条 网络运营者开展经营和服务活动，必须遵守法律、行政法规，尊重社会公德，遵守商业道德，诚实信用，履行网络安全保护义务，接受政府和社会的监督，承担社会责任。 第十条 建设、运营网络或者通过网络提供服务，应当依照法律、行政法规的规定和国家标准的强制性要求，采取技术措施和其他必要措施，保障网络安全、稳定运行，有效应对网络安全事件，防范网络违法犯罪活动，维护网络数据的完整性、保密性和可用性。 第十一条 网络相关行业组织按照章程，加强行业自律，制定网络安全行为规范，指导会员加强网络安全保护，提高网络安全保护水平，促进行业健康发展。 第十二条 国家保护公民、法人和其他组织依法使用网络的权利，促进网络接入普及，提升网络服务水平，为社会提供安全、便利的网络服务，保障网络信息依法有序自由流动。 任何个人和组织使用网络应当遵守宪法法律，遵守公共秩序，尊重社会公德，不得危害网络安全，不得利用网络从事危害国家安全、荣誉和利益，煽动颠覆国家政权、推翻社会主义制度，煽动分裂国家、破坏国家统一，宣扬恐怖主义、极端主义，宣扬民族仇恨、民族歧视，传播暴力、淫秽色情信息，编造、传播虚假信息扰乱经济秩序和社会秩序，以及侵害他人名誉、隐私、知识产权和其他合法权益等活动。 第十三条 国家支持研究开发有利于未成年人健康成长的网络产品和服务，依法惩治利用网络从事危害未成年人身心健康的活动，为未成年人提供安全、健康的网络环境。 第十四条 任何个人和组织有权对危害网络安全的行为向网信、电信、公安等部门举报。收到举报的部门应当及时依法作出处理；不属于本部门职责的，应当及时移送有权处理的部门。 有关部门应当对举报人的相关信息予以保密，保护举报人的合法权益。 第二章 网络安全支持与促进第十五条 国家建立和完善网络安全标准体系。国务院标准化行政主管部门和国务院其他有关部门根据各自的职责，组织制定并适时修订有关网络安全管理以及网络产品、服务和运行安全的国家标准、行业标准。 国家支持企业、研究机构、高等学校、网络相关行业组织参与网络安全国家标准、行业标准的制定。 第十六条 国务院和省、自治区、直辖市人民政府应当统筹规划，加大投入，扶持重点网络安全技术产业和项目，支持网络安全技术的研究开发和应用，推广安全可信的网络产品和服务，保护网络技术知识产权，支持企业、研究机构和高等学校等参与国家网络安全技术创新项目。 第十七条 国家推进网络安全社会化服务体系建设，鼓励有关企业、机构开展网络安全认证、检测和风险评估等安全服务。 第十八条 国家鼓励开发网络数据安全保护和利用技术，促进公共数据资源开放，推动技术创新和经济社会发展。 国家支持创新网络安全管理方式，运用网络新技术，提升网络安全保护水平。 第十九条 各级人民政府及其有关部门应当组织开展经常性的网络安全宣传教育，并指导、督促有关单位做好网络安全宣传教育工作。 大众传播媒介应当有针对性地面向社会进行网络安全宣传教育。 第二十条 国家支持企业和高等学校、职业学校等教育培训机构开展网络安全相关教育与培训，采取多种方式培养网络安全人才，促进网络安全人才交流。 第三章 网络运行安全 #### 第一节 一般规定 第二十一条 国家实行网络安全等级保护制度。网络运营者应当按照网络安全等级保护制度的要求，履行下列安全保护义务，保障网络免受干扰、破坏或者未经授权的访问，防止网络数据泄露或者被窃取、篡改： （一）制定内部安全管理制度和操作规程，确定网络安全负责人，落实网络安全保护责任； （二）采取防范计算机病毒和网络攻击、网络侵入等危害网络安全行为的技术措施； （三）采取监测、记录网络运行状态、网络安全事件的技术措施，并按照规定留存相关的网络日志不少于六个月； （四）采取数据分类、重要数据备份和加密等措施； （五）法律、行政法规规定的其他义务。 第二十二条 网络产品、服务应当符合相关国家标准的强制性要求。网络产品、服务的提供者不得设置恶意程序；发现其网络产品、服务存在安全缺陷、漏洞等风险时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 网络产品、服务的提供者应当为其产品、服务持续提供安全维护；在规定或者当事人约定的期限内，不得终止提供安全维护。 网络产品、服务具有收集用户信息功能的，其提供者应当向用户明示并取得同意；涉及用户个人信息的，还应当遵守本法和有关法律、行政法规关于个人信息保护的规定。 第二十三条 网络关键设备和网络安全专用产品应当按照相关国家标准的强制性要求，由具备资格的机构安全认证合格或者安全检测符合要求后，方可销售或者提供。国家网信部门会同国务院有关部门制定、公布网络关键设备和网络安全专用产品目录，并推动安全认证和安全检测结果互认，避免重复认证、检测。 第二十四条 网络运营者为用户办理网络接入、域名注册服务，办理固定电话、移动电话等入网手续，或者为用户提供信息发布、即时通讯等服务，在与用户签订协议或者确认提供服务时，应当要求用户提供真实身份信息。用户不提供真实身份信息的，网络运营者不得为其提供相关服务。 国家实施网络可信身份战略，支持研究开发安全、方便的电子身份认证技术，推动不同电子身份认证之间的互认。 第二十五条 网络运营者应当制定网络安全事件应急预案，及时处置系统漏洞、计算机病毒、网络攻击、网络侵入等安全风险；在发生危害网络安全的事件时，立即启动应急预案，采取相应的补救措施，并按照规定向有关主管部门报告。 第二十六条 开展网络安全认证、检测、风险评估等活动，向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息，应当遵守国家有关规定。 第二十七条 任何个人和组织不得从事非法侵入他人网络、干扰他人网络正常功能、窃取网络数据等危害网络安全的活动；不得提供专门用于从事侵入网络、干扰网络正常功能及防护措施、窃取网络数据等危害网络安全活动的程序、工具；明知他人从事危害网络安全的活动的，不得为其提供技术支持、广告推广、支付结算等帮助。 第二十八条 网络运营者应当为公安机关、国家安全机关依法维护国家安全和侦查犯罪的活动提供技术支持和协助。 第二十九条 国家支持网络运营者之间在网络安全信息收集、分析、通报和应急处置等方面进行合作，提高网络运营者的安全保障能力。 有关行业组织建立健全本行业的网络安全保护规范和协作机制，加强对网络安全风险的分析评估，定期向会员进行风险警示，支持、协助会员应对网络安全风险。 第三十条 网信部门和有关部门在履行网络安全保护职责中获取的信息，只能用于维护网络安全的需要，不得用于其他用途。 第二节 关键信息基础设施的运行安全第三十一条 国家对公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务等重要行业和领域，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的关键信息基础设施，在网络安全等级保护制度的基础上，实行重点保护。关键信息基础设施的具体范围和安全保护办法由国务院制定。 国家鼓励关键信息基础设施以外的网络运营者自愿参与关键信息基础设施保护体系。 第三十二条 按照国务院规定的职责分工，负责关键信息基础设施安全保护工作的部门分别编制并组织实施本行业、本领域的关键信息基础设施安全规划，指导和监督关键信息基础设施运行安全保护工作。 第三十三条 建设关键信息基础设施应当确保其具有支持业务稳定、持续运行的性能，并保证安全技术措施同步规划、同步建设、同步使用。 第三十四条 除本法第二十一条的规定外，关键信息基础设施的运营者还应当履行下列安全保护义务： （一）设置专门安全管理机构和安全管理负责人，并对该负责人和关键岗位的人员进行安全背景审查； （二）定期对从业人员进行网络安全教育、技术培训和技能考核； （三）对重要系统和数据库进行容灾备份； （四）制定网络安全事件应急预案，并定期进行演练； （五）法律、行政法规规定的其他义务。 第三十五条 关键信息基础设施的运营者采购网络产品和服务，可能影响国家安全的，应当通过国家网信部门会同国务院有关部门组织的国家安全审查。 第三十六条 关键信息基础设施的运营者采购网络产品和服务，应当按照规定与提供者签订安全保密协议，明确安全和保密义务与责任。 第三十七条 关键信息基础设施的运营者在中华人民共和国境内运营中收集和产生的个人信息和重要数据应当在境内存储。因业务需要，确需向境外提供的，应当按照国家网信部门会同国务院有关部门制定的办法进行安全评估；法律、行政法规另有规定的，依照其规定。 第三十八条 关键信息基础设施的运营者应当自行或者委托网络安全服务机构对其网络的安全性和可能存在的风险每年至少进行一次检测评估，并将检测评估情况和改进措施报送相关负责关键信息基础设施安全保护工作的部门。 第三十九条 国家网信部门应当统筹协调有关部门对关键信息基础设施的安全保护采取下列措施： （一）对关键信息基础设施的安全风险进行抽查检测，提出改进措施，必要时可以委托网络安全服务机构对网络存在的安全风险进行检测评估； （二）定期组织关键信息基础设施的运营者进行网络安全应急演练，提高应对网络安全事件的水平和协同配合能力； （三）促进有关部门、关键信息基础设施的运营者以及有关研究机构、网络安全服务机构等之间的网络安全信息共享； （四）对网络安全事件的应急处置与网络功能的恢复等，提供技术支持和协助。 第四章 网络信息安全第四十条 网络运营者应当对其收集的用户信息严格保密，并建立健全用户信息保护制度。 第四十一条 网络运营者收集、使用个人信息，应当遵循合法、正当、必要的原则，公开收集、使用规则，明示收集、使用信息的目的、方式和范围，并经被收集者同意。 网络运营者不得收集与其提供的服务无关的个人信息，不得违反法律、行政法规的规定和双方的约定收集、使用个人信息，并应当依照法律、行政法规的规定和与用户的约定，处理其保存的个人信息。 第四十二条 网络运营者不得泄露、篡改、毁损其收集的个人信息；未经被收集者同意，不得向他人提供个人信息。但是，经过处理无法识别特定个人且不能复原的除外。 网络运营者应当采取技术措施和其他必要措施，确保其收集的个人信息安全，防止信息泄露、毁损、丢失。在发生或者可能发生个人信息泄露、毁损、丢失的情况时，应当立即采取补救措施，按照规定及时告知用户并向有关主管部门报告。 第四十三条 个人发现网络运营者违反法律、行政法规的规定或者双方的约定收集、使用其个人信息的，有权要求网络运营者删除其个人信息；发现网络运营者收集、存储的其个人信息有错误的，有权要求网络运营者予以更正。网络运营者应当采取措施予以删除或者更正。 第四十四条 任何个人和组织不得窃取或者以其他非法方式获取个人信息，不得非法出售或者非法向他人提供个人信息。 第四十五条 依法负有网络安全监督管理职责的部门及其工作人员，必须对在履行职责中知悉的个人信息、隐私和商业秘密严格保密，不得泄露、出售或者非法向他人提供。 第四十六条 任何个人和组织应当对其使用网络的行为负责，不得设立用于实施诈骗，传授犯罪方法，制作或者销售违禁物品、管制物品等违法犯罪活动的网站、通讯群组，不得利用网络发布涉及实施诈骗，制作或者销售违禁物品、管制物品以及其他违法犯罪活动的信息。 第四十七条 网络运营者应当加强对其用户发布的信息的管理，发现法律、行政法规禁止发布或者传输的信息的，应当立即停止传输该信息，采取消除等处置措施，防止信息扩散，保存有关记录，并向有关主管部门报告。 第四十八条 任何个人和组织发送的电子信息、提供的应用软件，不得设置恶意程序，不得含有法律、行政法规禁止发布或者传输的信息。 电子信息发送服务提供者和应用软件下载服务提供者，应当履行安全管理义务，知道其用户有前款规定行为的，应当停止提供服务，采取消除等处置措施，保存有关记录，并向有关主管部门报告。 第四十九条 网络运营者应当建立网络信息安全投诉、举报制度，公布投诉、举报方式等信息，及时受理并处理有关网络信息安全的投诉和举报。 网络运营者对网信部门和有关部门依法实施的监督检查，应当予以配合。 第五十条 国家网信部门和有关部门依法履行网络信息安全监督管理职责，发现法律、行政法规禁止发布或者传输的信息的，应当要求网络运营者停止传输，采取消除等处置措施，保存有关记录；对来源于中华人民共和国境外的上述信息，应当通知有关机构采取技术措施和其他必要措施阻断传播。 第五章 监测预警与应急处置第五十一条 国家建立网络安全监测预警和信息通报制度。国家网信部门应当统筹协调有关部门加强网络安全信息收集、分析和通报工作，按照规定统一发布网络安全监测预警信息。 第五十二条 负责关键信息基础设施安全保护工作的部门，应当建立健全本行业、本领域的网络安全监测预警和信息通报制度，并按照规定报送网络安全监测预警信息。 第五十三条 国家网信部门协调有关部门建立健全网络安全风险评估和应急工作机制，制定网络安全事件应急预案，并定期组织演练。 负责关键信息基础设施安全保护工作的部门应当制定本行业、本领域的网络安全事件应急预案，并定期组织演练。 网络安全事件应急预案应当按照事件发生后的危害程度、影响范围等因素对网络安全事件进行分级，并规定相应的应急处置措施。 第五十四条 网络安全事件发生的风险增大时，省级以上人民政府有关部门应当按照规定的权限和程序，并根据网络安全风险的特点和可能造成的危害，采取下列措施： （一）要求有关部门、机构和人员及时收集、报告有关信息，加强对网络安全风险的监测； （二）组织有关部门、机构和专业人员，对网络安全风险信息进行分析评估，预测事件发生的可能性、影响范围和危害程度； （三）向社会发布网络安全风险预警，发布避免、减轻危害的措施。 第五十五条 发生网络安全事件，应当立即启动网络安全事件应急预案，对网络安全事件进行调查和评估，要求网络运营者采取技术措施和其他必要措施，消除安全隐患，防止危害扩大，并及时向社会发布与公众有关的警示信息。 第五十六条 省级以上人民政府有关部门在履行网络安全监督管理职责中，发现网络存在较大安全风险或者发生安全事件的，可以按照规定的权限和程序对该网络的运营者的法定代表人或者主要负责人进行约谈。网络运营者应当按照要求采取措施，进行整改，消除隐患。 第五十七条 因网络安全事件，发生突发事件或者生产安全事故的，应当依照《中华人民共和国突发事件应对法》、《中华人民共和国安全生产法》等有关法律、行政法规的规定处置。 第五十八条 因维护国家安全和社会公共秩序，处置重大突发社会安全事件的需要，经国务院决定或者批准，可以在特定区域对网络通信采取限制等临时措施。 第六章 法律责任第五十九条 网络运营者不履行本法第二十一条、第二十五条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处一万元以上十万元以下罚款，对直接负责的主管人员处五千元以上五万元以下罚款。 关键信息基础设施的运营者不履行本法第三十三条、第三十四条、第三十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处十万元以上一百万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款。 第六十条 违反本法第二十二条第一款、第二款和第四十八条第一款规定，有下列行为之一的，由有关主管部门责令改正，给予警告；拒不改正或者导致危害网络安全等后果的，处五万元以上五十万元以下罚款，对直接负责的主管人员处一万元以上十万元以下罚款： （一）设置恶意程序的； （二）对其产品、服务存在的安全缺陷、漏洞等风险未立即采取补救措施，或者未按照规定及时告知用户并向有关主管部门报告的； （三）擅自终止为其产品、服务提供安全维护的。 第六十一条 网络运营者违反本法第二十四条第一款规定，未要求用户提供真实身份信息，或者对不提供真实身份信息的用户提供相关服务的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十二条 违反本法第二十六条规定，开展网络安全认证、检测、风险评估等活动，或者向社会发布系统漏洞、计算机病毒、网络攻击、网络侵入等网络安全信息的，由有关主管部门责令改正，给予警告；拒不改正或者情节严重的，处一万元以上十万元以下罚款，并可以由有关主管部门责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处五千元以上五万元以下罚款。 第六十三条 违反本法第二十七条规定，从事危害网络安全的活动，或者提供专门用于从事危害网络安全活动的程序、工具，或者为他人从事危害网络安全的活动提供技术支持、广告推广、支付结算等帮助，尚不构成犯罪的，由公安机关没收违法所得，处五日以下拘留，可以并处五万元以上五十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处十万元以上一百万元以下罚款。 单位有前款行为的，由公安机关没收违法所得，处十万元以上一百万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 违反本法第二十七条规定，受到治安管理处罚的人员，五年内不得从事网络安全管理和网络运营关键岗位的工作；受到刑事处罚的人员，终身不得从事网络安全管理和网络运营关键岗位的工作。 第六十四条 网络运营者、网络产品或者服务的提供者违反本法第二十二条第三款、第四十一条至第四十三条规定，侵害个人信息依法得到保护的权利的，由有关主管部门责令改正，可以根据情节单处或者并处警告、没收违法所得、处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款；情节严重的，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照。 违反本法第四十四条规定，窃取或者以其他非法方式获取、非法出售或者非法向他人提供个人信息，尚不构成犯罪的，由公安机关没收违法所得，并处违法所得一倍以上十倍以下罚款，没有违法所得的，处一百万元以下罚款。 第六十五条 关键信息基础设施的运营者违反本法第三十五条规定，使用未经安全审查或者安全审查未通过的网络产品或者服务的，由有关主管部门责令停止使用，处采购金额一倍以上十倍以下罚款；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十六条 关键信息基础设施的运营者违反本法第三十七条规定，在境外存储网络数据，或者向境外提供网络数据的，由有关主管部门责令改正，给予警告，没收违法所得，处五万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照；对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 第六十七条 违反本法第四十六条规定，设立用于实施违法犯罪活动的网站、通讯群组，或者利用网络发布涉及实施违法犯罪活动的信息，尚不构成犯罪的，由公安机关处五日以下拘留，可以并处一万元以上十万元以下罚款；情节较重的，处五日以上十五日以下拘留，可以并处五万元以上五十万元以下罚款。关闭用于实施违法犯罪活动的网站、通讯群组。 单位有前款行为的，由公安机关处十万元以上五十万元以下罚款，并对直接负责的主管人员和其他直接责任人员依照前款规定处罚。 第六十八条 网络运营者违反本法第四十七条规定，对法律、行政法规禁止发布或者传输的信息未停止传输、采取消除等处置措施、保存有关记录的，由有关主管部门责令改正，给予警告，没收违法所得；拒不改正或者情节严重的，处十万元以上五十万元以下罚款，并可以责令暂停相关业务、停业整顿、关闭网站、吊销相关业务许可证或者吊销营业执照，对直接负责的主管人员和其他直接责任人员处一万元以上十万元以下罚款。 电子信息发送服务提供者、应用软件下载服务提供者，不履行本法第四十八条第二款规定的安全管理义务的，依照前款规定处罚。 第六十九条 网络运营者违反本法规定，有下列行为之一的，由有关主管部门责令改正；拒不改正或者情节严重的，处五万元以上五十万元以下罚款，对直接负责的主管人员和其他直接责任人员，处一万元以上十万元以下罚款： （一）不按照有关部门的要求对法律、行政法规禁止发布或者传输的信息，采取停止传输、消除等处置措施的； （二）拒绝、阻碍有关部门依法实施的监督检查的； （三）拒不向公安机关、国家安全机关提供技术支持和协助的。 第七十条 发布或者传输本法第十二条第二款和其他法律、行政法规禁止发布或者传输的信息的，依照有关法律、行政法规的规定处罚。 第七十一条 有本法规定的违法行为的，依照有关法律、行政法规的规定记入信用档案，并予以公示。 第七十二条 国家机关政务网络的运营者不履行本法规定的网络安全保护义务的，由其上级机关或者有关机关责令改正；对直接负责的主管人员和其他直接责任人员依法给予处分。 第七十三条 网信部门和有关部门违反本法第三十条规定，将在履行网络安全保护职责中获取的信息用于其他用途的，对直接负责的主管人员和其他直接责任人员依法给予处分。 网信部门和有关部门的工作人员玩忽职守、滥用职权、徇私舞弊，尚不构成犯罪的，依法给予处分。 第七十四条 违反本法规定，给他人造成损害的，依法承担民事责任。 违反本法规定，构成违反治安管理行为的，依法给予治安管理处罚；构成犯罪的，依法追究刑事责任。 第七十五条 境外的机构、组织、个人从事攻击、侵入、干扰、破坏等危害中华人民共和国的关键信息基础设施的活动，造成严重后果的，依法追究法律责任；国务院公安部门和有关部门并可以决定对该机构、组织、个人采取冻结财产或者其他必要的制裁措施。 第七章 附 则第七十六条 本法下列用语的含义： （一）网络，是指由计算机或者其他信息终端及相关设备组成的按照一定的规则和程序对信息进行收集、存储、传输、交换、处理的系统。 （二）网络安全，是指通过采取必要措施，防范对网络的攻击、侵入、干扰、破坏和非法使用以及意外事故，使网络处于稳定可靠运行的状态，以及保障网络数据的完整性、保密性、可用性的能力。 （三）网络运营者，是指网络的所有者、管理者和网络服务提供者。 （四）网络数据，是指通过网络收集、存储、传输、处理和产生的各种电子数据。 （五）个人信息，是指以电子或者其他方式记录的能够单独或者与其他信息结合识别自然人个人身份的各种信息，包括但不限于自然人的姓名、出生日期、身份证件号码、个人生物识别信息、住址、电话号码等。 第七十七条 存储、处理涉及国家秘密信息的网络的运行安全保护，除应当遵守本法外，还应当遵守保密法律、行政法规的规定。 第七十八条 军事网络的安全保护，由中央军事委员会另行规定。 第七十九条 本法自2017年6月1日起施行。","link":"/posts/b81fa239/"},{"title":"github page网站cdn优化加速","text":"CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 图片加速关于图传以及GitHub作为图库的使用方法请参考文章：博客图片上传picgo工具github图传使用。 在上面参考文章的基础之上只需要修改以下配置：（指定相关cdn域名） 原来项目中使用了原来的方式，进行全局替换，Mac idea直接快捷键command+shift+R全局替换 【ps：题外话】原来是统一用的GitHub的仓库中的图片，通过这样替换，可以看到图片统一管理是多么的重要，多么的方便管理操作。 至此，博客中的相关图片都加上了cdn。 其余资源文件用法： 1https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 例如： 123https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@1.0/images/trhx.pnghttps://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.0.1/css/style.csshttps://cdn.jsdelivr.net/gh/moezx/cdn@3.1.3//The%20Pet%20Girl%20of%20Sakurasou.mp4 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718// 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file// 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js// 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js// 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js// 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js// 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ 至此，github page 博客基本需要加速的完成。 参考文章:参考链接1参考链接2","link":"/posts/346ce02e/"},{"title":"github Issue 作为博客微型数据库的应用","text":"背景众所周知，对于hexo框架搭建的静态博客，难免会产生一些动态的数据，比如一些碎碎念、友链、音乐、时间轴等微型数据。目前一般的做法: a.是创建一个json数据，来存储这些微型数据，但是如果数据太多的话，一是比较慢，二是有个硬伤问题，就是json数据不能分页请求，只能一次拿完，太多的话网络带宽占用太多。 b.或者有的直接后台写一些接口服务啥的，还得在买个服务器部署上去，然后博客中访问接口。 c.或者有些可能就直接写到html中。 对于a、c方法都比较麻烦，每次更新了都要编译部署，不能很方便的动态更新。对于b的话，成本以及技术要求可能就更多一些了。 基于上面出现的问题，目前想到的一个解决方案就是，利用github 的issue作为一个微型数据库。能够很方便的动态更新，也能分页，也不需要啥json文件，想想都很方便。 issue数据库使用步骤issue的创建先创建一个Repository，对于此Repository可以专门作为微型的数据库，取名issue_database。创建好之后建立一些issue 如下所示 目前博客中，所有的动态数据都放到issue中了。 issue中存储数据对于创建好的issue，就可以往里面写数据了，比如我的友链数据为issue：blog_friends 对于issue中存储的数据最好存json格式的，因为可以方便后面取出来使用。存储好数据后，如果太多的话，可以点击hide,隐藏起来。同时这个issue最好给Lock conversation这样的好处是，防止别人往里面加些脏数据，只能自己往里写数据。哈哈，一般也没有闲的无聊的网友恶作剧。这样就存储好数据了。 博客中获取issue数据博客中通过js获取issue中的数据，以博客友链为例，以下是获取代码，以及处理 123456789101112131415161718// author by removef// https://removeif.github.io/$(function () { //获取处理友链数据，来自issue，一次取完 $.getJSON(\"https://api.github.com/repos/removeif/issue_database/issues/2/comments?per_page=100&amp;client_id=46a9f3481b46ea0129d8&amp;client_secret=79c7c9cb847e141757d7864453bcbf89f0655b24\", function (source) { var data = []; var source1; source1 = source; // 以后每次更新的都在后面，此处倒序，按时间降序排 source1.reverse(); // 把所有的数据放到data的列表中 $.each(source1, function (i, e) { data.push(...JSON.parse(e.body)); }); $.each(data, function (i, e) { // 博客中html文件的构建，渲染 });}); 上面代码中client_id、client_secret在另一篇文章中博客源码分享有详细的说明,可以查看一下。这样就能获取到相应的数据，进行操作。 issue数据的更新比如想更新任意一项数据都可以进github中对应的仓库的issue下进行更新，添加。然后实时去博客中查看。 扩展一下对于有些爱唠叨的人（比如我），弄个类似碎碎念的东西就比较实用了。之前想过各种方案，存json数据太不方便；后台写个服务部署服务器也太麻烦。最后思来想去还是利用了下现成的优秀项目gitalk,稍稍改改就能很好使用。 博客中的碎碎念对于博主而言，有发表框和修改的操作，能够方便发表和修改。 可能有时候还会发表一些图片，对图片的样式做了一些控制 对于网友的话只能查看以及点赞加❤️ 做法就是源码中改下返回html的文件内容，如果是管理员和非管理员返回一些不同的元素，能够很好的实现碎碎念的功能。查看碎碎念。 总结静态博客的动态数据是个痛点，GitHub Issue有很多可利用的地方。多去探索发掘其中的奥妙。 利用GitHub Issue来解决目前也是一种解决方法。希望后面会出现更好的解决方案。","link":"/posts/e7fe3cc/"},{"title":"安装、部分配置icarus主题中文版","text":"摘要发现icarus主题还不错，花了一两个小时研究了下安装、部分配置icarus主题中文版 安装icarus 直接下载主题模块放到blog项目 ,blog项目根目录执行 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 此时已经下载到项目中。 顶级_config.yml中选择icarus主题 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: icarus 此时主题已经安装好，清除、编译、部署可以看到效果了 配置icarus 完全参照官网配置，进行翻译解说 配置文章部分顶部图片添加icarus 主题中的配置_config.yml中开启图片开关 12article: thumbnail: true 文章.md文件头中添加图片绝对/相对地址 12345title: Getting Started with Icarusthumbnail: /gallery/thumbnails/desert.jpg// thumbnail:https://cdn.jsdelivr.net/gh/removeif/blog_image/20190620152744.png---Post content... 配置完成后部署显示效果如下(最新文章列表显示缩略图、文章开头显示一张设置图片) 左边文章导航栏开启icarus 主题中的配置_config.yml中开关 1234widgets: - type: toc position: left 同事文章顶部加入标签 1234title: Table of Contents Exampletoc: true---Post content... 配置效果 评论系统开启icarus 主题中的配置_config.yml中开启（部分评论系统需要翻墙才能使用，valine不用翻墙个人推荐，valine安装参考） 1234567comment: type: valine app_id: xxxxxxxx # (required) LeanCloud application id app_key: xxxxxxxx # (required) LeanCloud application key notify: false # (optional) receive email notification verify: false # (optional) show verification code placeholder: xxxxxxxx # (optional) comment box placeholder text 开启效果 捐赠收款开启icarus 主题中的配置_config.yml中开启 注意如果默认不配置，编译时有报错，可以# 把它注释掉，不启用功能 1234567891011donate: - # Donation entry name type: alipay # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvxdcwm0j20p011i4bg.jpg' - # Donation entry name type: wechat # Qrcode image URL qrcode: 'https://wx2.sinaimg.cn/large/b5d1b710gy1g0lvwdcpb5j20u014qgy2.jpg' 开启配置效果如下 全局搜索开启icarus 主题中的配置_config.yml中开启,不同的搜索类型需要安装插件参考官网,type: insight此类型不需要安装，已经内置 12search: type: insight 效果如下 更多配置请参考官网配置目前配置基本已经够使用，还需要更多配置请参考连接 参考自","link":"/posts/52c38f29/"},{"title":"博客图片上传picgo工具github图传使用","text":"摘要对于每一个写博客的人来说，图片是至关重要。这一路经历了多次图片的烦恼，之前选择了微博个人文章那里粘贴图片的方式上传，感觉也挺方便的。但是由于新浪的图片显示问题，如果header中不设置 标签就不能异步访问图片，导致图裂，那之恶心。然而设置之后又与网站访客统计的插件冲突，使之不能统计，真是神仙打架。无赖之下使用了PicGo工具，使用后感觉真XX方便！ PicGo工具下载安装配置下载 .PicGo下载 github网站提供三个版本的下载，MacOs、linux、windows覆盖市面上90%系统，还是很给力了。 我是mac用户，直接使用brew cask来安装PicGo: brew cask install picgo，简直方便到爆。 配置 PicGo配置(使用github图传，免费方便，同时配合github.io博客真是方便) 选上必填的就ok,一开始不知道token的设置，附赠token获取方法 图片上传相关的设置 链接格式：选择适合自己的，一般用户md文件中，选第一个，然后就可以疯狂使用了。 使用github图传，获取token在github-&gt;setting-&gt;developer settings 选择generate new token 勾选好之后生成就好了 使用 PicGo使用，简直方便 1).默认网页上直接右键复制图片 2).点击等待中的图片，开始上传 3).上传完之后有个提示，同时粘贴板也会自动粘贴上 4).直接粘贴到想要的地方 或者也可以直接截图，然后点击图片里的图片上传，很方便 PicGo上传动图gif 如果直接复制网页上的动图，去上传的话是截取的某帧，是静图。应该下载到本地，然后在拖进去上传就可以了。","link":"/posts/9e7c733f/"},{"title":"加密文章测试","text":"4630436162ade97ba2718b7d0c4b3b63480c11f21f943edd569d93952dd2b428ca40d00edd08503bde446612a9b43ffa557648f22736556fdb8df232a70f5b62381872db0244c43c00526e1a08cf52221edf34128af95f6689fc9f8038d2d384d80553865a152ddd5e6208a870af3b5c9bc83d20b2dbb9eed9bf4345fcbd80740d0d96973b857ce18daf962a01b68ae1d5fbd8ee95919ff5e4e59e2389903324d011f36e647c7bfde1d377a277b639b7845f1864318dedde1881f738423184c1eda461211d6767b7282687bd23a77a8725cebce8f83995baff71092164b22479 嗨，请准确无误地输入密码查看哟（密码：123456）！","link":"/posts/7e709353/"},{"title":"Vue 2 即将成为过去","text":"自从 2020 年 9 月 18 日 Vue 3 正式发布以来，已经有两年多时间了，终于在 2022 年 2 月 7 日 Vue 作者发布了一则消息：Vue 3 将成为新的默认版本。与此同时，Vue 相关官方周边的核心库 latest 发布标签将指向其 Vue 3 的兼容版本。 Vue 2 即将成为过去 自从 2020 年 9 月 18 日 Vue3 正式发布以来，已经有两年多时间了，终于在 2022 年 2 月 7 日 Vue作者发布了一则消息：Vue 3 将成为新的默认版本。与此同时，Vue相关官方周边的核心库 latest 发布标签将指向其 Vue 3 的兼容版本。 另外，随着 Vue 2.7 的发布，Vue 2.7 已经成为 Vue 2.x的最终次要版本。在这个版本之后，Vue 2进入了 LTS（长期支持），并且将不再接收新功能。这意味着 Vue 2.x 将在 2023年底结束其生命周期。 可以预见：在不久的将来，Vue 2.x 将会逐步淡出江湖，Vue 3 将会成为代替 Vue2 的主流框架。 Vue3 作为一个全球最顶尖的前端框架之一，整体的思想理念、程序设计、细节的取舍、API设计、项目的工程考量都是非常优秀的！通过对源码的阅读，不仅仅可以让我们快速建立起对 Vue3 运行机制的深入了解，还可以从中学习到很多程序设计的宝贵经验和架构思想！ 所以，让我们快人一步，现在就开始对 Vue 3 的深耕，去学习一下 Vue 3的核心技术实现原理，以及一些相对于 Vue 2 的改变之处。 全面拥抱 Vue 3 Vue 3 整体的设计相对于 Vue 2.x 有着不小的变化，在开启 Vue3 技术揭秘的旅途之前，我们先着重介绍几个相对于 Vue2.x 而言较大的几个变化，这里的介绍不会深入到源码的细节，旨在帮助小伙伴们快速建立起对 Vue3 的一些前置认知，更多的细节变化和设计原理我们将在接下来的课程中为大家渐进式地揭开面纱！ 1. 源码组织上的变化 在 Vue 2 中，所有的源码都存在在 src 目录下： Vue 3 相对于 Vue2 使用 monorepo 的方式进行包管理，使用 monorepo 的管理方式，使得 Vue3 源码模块职责显得特别地清晰明了，每个包独立负责一块核心功能的实现，方便开发和测试。如下图： 比如，compiler-core 专职负责与平台无关层的渲染器底层，对外提供统一调用函数，内部通过完整的测试用例保障功能的稳定性。而 compiler-dom 和 compiler-ssr 则依托于 compiler-core 分别实现浏览器和服务端侧的渲染器上层逻辑，模块核心职责清晰明了，提高了整体程序运行的健壮性！ 2. 引入 Composition API 在 Vue 2.7 之前，我们去开发 Vue应用，都是通过 data、computed、methods……这样的选项分类的方式来实现一个组件的开发。其实这样对于没有大量状态逻辑维护、复用的组件来说，是比较直观的组织方式，但是一旦遇到需要大量维护、复用状态的组件来说，这无疑增加了维护的成本和风险。 组合式 API (Composition API) 是一系列 API的集合，使我们可以使用函数而不是声明选项的方式书写 Vue组件。通过下图我们可以清晰地看出来二者的区别： 但 Composition API 也并不是”银弹”，它也有自己适合的场景，所以 Vue3 也是在实现层面做到了兼容 Options API 的写法。相对而言，CompositionAPI 更适用于大型的项目，因为大型项目可能会产生大量状态逻辑的维护，甚至跨组件的逻辑复用；而对于中小型项目来说，OptionsAPI 可以在你写代码时减少思考组织状态逻辑的方式，也是一种不错的选择。 3. 运作机制的变化 熟悉 Vue 2 源码的同学大致清楚 Vue2的核心运作机制可以抽象为下图所示的样子： Vue 3 则在底层实现中，摒弃了 Vue 2的部分实现，采用全新的响应式模型进行重写。这里我根据 Vue 3的运行机制，也简单画了一张 Vue 3 的宏观草图，如下所示： 可以粗略地看到： 首先，之前通过 new Vue() 来创建 Vue 对象的方式已经变成了 createApp； 其次，在响应式部分也由原来的 Object.defineProperty 改成了现在的 Proxy API 实现； 另外，针对响应式依赖收集的内容，在 Vue 2.x 版本中是收集了 Watcher，而到了 Vue 3 中则成了 effect。 除了上面所说的这些变化外，Vue 3不管是在编译时、还是在运行时都做了大量的性能优化。例如，在编译时，Vue3通过标记 /*#__PURE__*/ 来为打包工具提供良好的 Tree-Shaking 机制，通过 静态提升 机制，避免了大量静态节点的重复渲染执行；在运行时，又通过批量队列更新机制优化了更新性能，通过 PatchFlags 和 dynamicChildren 进行了 diff 的靶向更新…… 上面的内容有些不理解了？没关系，等等，这里先卖个关子。相信你一定可以在学习本小册的过程中，得到你的答案！ 开启小册的前置准备 如果你已经迫不及待地想赶紧开始学习 Vue 3的设计核心，请稍安勿躁，我们还需要做一些准备工作，以方便你在后续的学习中更容易理解文中的内容。 首先，本小册中所有关于 Vue的源码所依托的版本是 3.2.47。然后你也可以去 GitHub 上 clone下来 [Vue 3源码]{.underline}。 clone 下来后，我们可以简单看一下项目的目录结构： bash复制代码├── packages │ ├── compiler-core #与平台无关的编译器实现的核心函数包 │ ├── compiler-dom #浏览器相关的编译器上层内容 │ ├── compiler-sfc # 单文件组件的编译器 │├── compiler-ssr # 服务端渲染相关的编译器实现 │ ├── global.d.ts # ts相关一些声明文件 │ ├── reactivity # 响应式核心包 │ ├── runtime-core #与平台无关的渲染器相关的核心包 │ ├── runtime-dom #浏览器相关的渲染器部分 │ ├── runtime-test # 渲染器测试相关代码 │ ├──server-renderer # 服务端渲染相关的包 │ ├── sfc-playground #单文件组件演练场 │ ├── shared # 工具库相关 │ ├── size-check #检测代码体积相关 │ ├── template-explorer #演示模板编译成渲染函数相关的包 │ └── vue # 包含编译时和运行时的发布包","link":"/posts/51a34acf/"},{"title":"让 Vite 助力你的前端工程化之路","text":"当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说构建工具已经成为了前端工程项目的标配。 当下，在项目开发的过程中，前端工程师们越来越离不开构建工具了，可以说构建工具已经成为了前端工程项目的标配。 不过，如今的前端构建工具可谓[乱花渐欲迷人眼]{.mark}，有远古时代的[browserify]{.mark}、[grunt]{.mark}，有传统的[Webpack]{.mark}、[Rollup]{.mark}、[Parcel]{.mark}，也有现代的[Esbuild]{.mark}、[Vite]{.mark} 等等，不仅种类繁多，更新也很快。 于是，很多朋友会问我，到底哪个构建工具更好用、值得学。事实上，无论工具层面如何更新，它们解决的核心问题，即前端工程的痛点是不变的。因此，想要知道哪个工具更好用，就要看它解决前端工程痛点的效果。 那么，前端工程都有哪些痛点呢？ 首先是前端的模块化需求。我们知道，业界的模块标准非常多，包括ESM、CommonJS、AMD 和 CMD等等。前端工程一方面需要落实这些模块规范，保证模块正常加载。另一方面需要兼容不同的模块规范，以适应不同的执行环境。 其次是兼容浏览器，编译高级语法。由于浏览器的实现规范所限，只要高级语言/语法（TypeScript、JSX等）想要在浏览器中正常运行，就必须被转化为浏览器可以理解的形式。这都需要工具链层面的支持，而且这个需求会一直存在。 再者是线上代码的质量问题。和开发阶段的考虑侧重点不同，生产环境中，我们不仅要考虑代码的[安全性]{.mark}、[兼容性]{.mark}问题，保证线上代码的正常运行，也需要考虑代码运行时的性能问题。由于浏览器的版本众多，代码兼容性和安全策略各不相同，线上代码的质量问题也将是前端工程中长期存在的一个痛点。 同时，[开发效率]{.mark}也不容忽视。 我们知道，项目的冷启动/二次启动时间、热更新时间都可能严重影响开发效率，尤其是当项目越来越庞大的时候。因此，提高项目的启动速度和热更新速度也是前端工程的重要需求。 那么，前端构建工具是如何解决以上问题的呢？ 模块化方面，提供模块加载方案，并兼容不同的模块规范。 语法转译方面，配合 [Sass]{.mark}、[TSC]{.mark}、[Babel]{.mark} 等前端工具链，完成高级语法的转译功能，同时对于静态资源也能进行处理，使之能作为一个模块正常加载。 产物质量方面，在生产环境中，配合 [Terser]{.mark}等压缩工具进行代码压缩和混淆，通过 [TreeShaking]{.mark} 删除未使用的代码，提供对于低版本浏览器的语法降级处理等等。 开发效率方面，构建工具本身通过各种方式来进行性能优化，包括 [使用原生语言Go/Rust]{.mark}、[no-bundle]{.mark}等等思路，提高项目的启动性能和热更新的速度。 为什么 Vite 是当前最高效的构建工具？ 现在，让我们回到一开始提出的问题，到底哪个工具更好用？或者说，哪个工具解决前端工程痛点的效果更好？ The State of JavaScript Survey 最近的调查结果中显示， Vite在全球开发者中的满意度超过98%，已经被用到了[SvelteKit]{.mark}、[Astro]{.mark}这些大型框架中，成为当下最受瞩目的前端构建工具。我也最推荐你使用它。为什么是Vite 呢？我们可以根据上面说的四个维度来审视它。 首先是开发效率。传统构建工具普遍的缺点就是太慢了，与之相比，Vite能将项目的启动性能提升一个量级，并且达到毫秒级的瞬间热更新效果。 就拿 Webpack 来说，我在工作中发现，一般的项目使用 Webpack之后，启动花个几分钟都是很常见的事情，热更新也经常需要等待十秒以上。这主要是因为： 项目冷启动时必须递归打包整个项目的依赖树 JavaScript 语言本身的性能限制，导致构建性能遇到瓶颈，直接影响开发效率 这样一来，代码改动后不能立马看到效果，自然开发体验也越来越差。而其中，最占用时间的就是代码打包和文件编译。 而 Vite 很好地解决了这些问题。一方面，Vite 在开发阶段基于浏览器原生 ESM的支持实现了[no-bundle]{.mark}服务，另一方面借助 Esbuild超快的编译速度来做第三方库构建和 TS/JSX语法编译，从而能够有效提高开发效率。 除了开发效率，在其他三个维度上， Vite 也表现不俗。 模块化方面，Vite 基于浏览器原生 ESM的支持实现模块加载，并且无论是开发环境还是生产环境，都可以将其他格式的产物(如CommonJS)转换为 ESM。 语法转译方面，Vite 内置了对 TypeScript、JSX、Sass等高级语法的支持，也能够加载各种各样的静态资源，如图片、Worker 等等。 产物质量方面，Vite 基于成熟的打包工具 Rollup实现生产环境打包，同时可以配合 [Terser]{.mark}、[Babel]{.mark}等工具链，可以极大程度保证构建产物的质量。 因此，如果你想要学习一个前端构建工具，Vite将会是你当下一个最好的选择。它不仅解决了传统构建工具的开发效率问题，而且具备一个优秀构建工具的各项要素，还经历了社区大规模的验证与落地。 如何才能学好 Vite ？ 不过，很多人在学习和应用 Vite 的过程中总会遇到各种各样的问题。 比如说，很多 Vite学习资料既不系统，也不深入。绝大多数的文章只能教会我们如何搭建一个简单的脚手架项目，甚至代码都不一定正确。 即使通过资料学完了 Vite 的相关知识，但因为对 Vite的生态了解不够，遇到实际问题的时候依然不知道要使用哪些插件或者解决方案。 第三方库里面含有 CommonJS 代码导致报错了怎么办? 想在开发过程中进行 Eslint 代码规范检查怎么办？ 生产环境打包项目后，如何产出构建产物分析报告？ 如果要兼容不支持原生 ESM 的浏览器，怎么办？ 而且，如果你对 Vite 底层使用的构建引擎 Esbuild 和 Rollup不够熟悉，遇到一些需要定制的场景，往往也会捉襟见肘。 写一个 Esbuild 插件来处理一下问题依赖 对于 Rollup 打包产物进行自定义拆包，解决实际场景中经常出现的循环依赖问题 使用 Esbuild 的代码转译和压缩功能会出现哪些兼容性问题？如何解决？ 当然，作为一个构建工具，Vite的难点不仅在于它本身的灵活性，也包含了诸如[Babel]{.mark}、[core-js]{.mark} 等诸多前端工具链的集成和应用。 @babel/preset-env 的 useBuiltIns 属性各个取值有哪些区别？ @babel/polyfill 与 @babel/runtime-corejs 有什么区别？ @babel/plugin-transform-runtime 与 @babel/preset-env 的 useBuiltIn 相比有什么优化？ core-js 的作用是什么？其产物有哪些版本？ core-js 和 core-js-pure 有什么区别？ 此外，由于构建工具(不仅包括 Vite，也包括底层引擎Rollup)的源码晦涩难懂，涉及大量的基础工具库，导致很多人对构建工具原理的理解只浮于表面，很难更进一步。 作为一名深耕在一线的前端工程师，我的日常工作就是跟各种构建工具打交道，在公司中诸多的业务项目中落地了Vite，有丰富的 Vite 实战经验和源码阅读经验，也给 Vite仓库贡献过一些代码。因此，我也非常乐意将自己在 Vite方面的实战经验与学习方法通过小册系统性地分享给大家。 那么， Vite该如何学习呢？我按照循序渐进、可实操、可延伸的三个原则，由浅入深设计课程内容，提供大量的实战场景和案例，同时尽可能给大家提供解决问题的方法和视角，让大家学完课程后能做到举一反三。具体来说，我将课程设计为5 个模块。 在基础使用篇中，我将与你从 0 开始实现 Vite项目初始化，接入各种现代化的 CSS 方案，集成 Eslint、Styelint、Commonlint等一系列 Lint 工具链，处理各种形式的静态资源，掌握 Vite预编译的各种使用技巧，最终让你能独立搭建一个相对完整的脚手架工程。 在双引擎篇中，我们会学习 Vite 的双引擎架构， Esbuild 和 Rollup相关的内容，包括它们的基本使用和插件开发，掌握[最小必要知识]{.mark}，为后续的高级应用作铺垫。 而高级应用篇， 我们将学习 Vite的各种高级用法和构建性能优化手段，学会如何编写一个完整的 Vite插件，熟练进行生产环境拆包，使用 Vite 搭建复杂的 SSR工程，实现基于模块联邦的跨应用模块共享架构。不管是项目性能优化技巧，还是对前端底层标准和规范的理解，你都会从这一模块得到不少提升。 接下来，我们将一起剖析 Vite 的核心源码，理解诸如[JIT]{.mark}、[ProxyModule]{.mark}、[Module Graph]{.mark}、[HMR Boundary]{.mark}和[PluginContainer]{.mark} 等源码中重要概念的作用及底层实现，一步步教你学会阅读Vite 的源码，将如下架构图中的关键环节各个击破，学透 Vite 实现原理。 最后是手写实战篇。 首先，我们会手写 Vite 的开发时 no-bundle服务，也就是开发环境下基于浏览器原生 ESM 的 DevServer。然后，我也会带你一步步完成一个生产环境打包工具（Bundler），从AST解析的功能开始，完成代码的词法分析（tokenize）和语义分析（parse），实现模块依赖图和作用域链的搭建，并完成Tree Shaking、循环依赖检测及 Bundle 代码生成，最终实现一个类似 Rollup 的Bundler。 可以看到，我们在课程中非常重视上手实战。课程的代码全部会上传至 Github仓库(仓库地址)，基本上每一节内容都有能run起来的代码案例。尤其在最后一章，为了让你理解构建工具的底层原理，我会带你一步步搭建一个简单的构建工具，进行上千行代码的手写实战，做到真正的代码可实操。 最后，我希望在这本小册中，我们能一起深入 Vite 的实战要点和实现原理，领略前端工程化构建领域的底层风光，真正实现 Vite 从入门到进阶","link":"/posts/e76f424e/"},{"title":"模块标准：为什么 ESM 是前端模块化的未来？","text":"2002 年 AJAX诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了CommonJS、AMD、CMD、UMD和ESModule等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD规范提出时社区诞生 的模块加载工具requireJS，基于 CommonJS规范的模块打包工具browserify，还有能让用户提前用 上 ES Module语法的 JS编译器Babel、兼容各种模块规范的重量级打包工具Webpack以及基于浏览器原 生ES Module 支持而实现的 no-bundle 构建工具 2002 年 AJAX诞生至今，前端从刀耕火种的年代，经历了一系列的发展，各种标准和工具百花齐放。下图中我们可以看到，自 2009 年 Node.js 诞生，前端先后出现了CommonJS、AMD、CMD、UMD和ESModule等模块规范，底层规范的发展催生出了一系列工具链的创新，比如 AMD规范提出时社区诞生 的模块加载工具requireJS，基于 CommonJS规范的模块打包工具browserify，还有能让用户提前用 上 ES Module语法的 JS编译器Babel、兼容各种模块规范的重量级打包工具Webpack以及基于浏览器原 生ES Module 支持而实现的 no-bundle 构建工具Vite等等。 总体而言，业界经历了一系列由规范、标准引领工程化改革的过程。构建工具作为前端工程化的核心要素，与底层的前端模块化规范和标准息息相关。接下来的时间，我就带你梳理一下前端模块化是如何演进的。这样你能更清楚地了解到各种模块化标准诞生的背景和意义，也能更好地理解ES Module 为什么能够成为现今最主流的前端模块化标准。 无模块化标准阶段早在模块化标准还没有诞生的时候，前端界已经产生了一些模块化的开发手段，如文件划分、命名空间和 IIFE 私有作用域。下面，我来简单介绍一下它们的实现以及背后存在的问题。 1. 文件划分文件划分方式是最原始的模块化实现，简单来说就是将应用的状态和逻辑分散到不同的文件中，然后通过 HTML 中的 script来一一引入。下面是一个通过文件划分实现模块化的具体例子: 1// module-a.js 3 1// module-b.js 2 function method() { 3 console.log(&quot;execute method&quot;); 4 } 5 1 // index.html 2 &lt;!DOCTYPE html&gt; 3 &lt;html lang=&quot;en&quot;&gt; 4 &lt;head&gt; 5 &lt;meta charset=&quot;UTF-8&quot; /&gt; 6 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; 7 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; 8 &lt;title&gt;Document&lt;/title&gt; 9 &lt;/head&gt; 10 &lt;body&gt; 11 &lt;script src=&quot;./module-a.js&quot;&gt;&lt;/script&gt; 12 &lt;script src=&quot;./module-b.js&quot;&gt;&lt;/script&gt; 13 &lt;script&gt; 14 console.log(data); 15 method(); 16 &lt;/script&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; 19 从中可以看到module-a和module-b为两个不同的模块，通过两个 script标签分别引入到 HTML 中，这么做看似是分散了不同模块的状态和运行逻辑，但实际上也隐藏着一些风险因素: 1.模块变量相当于在全局声明和定义，会有变量名冲突的问题。比如module-b可能也存在data变量，这就会与 module-a中的变量冲突。 2.由于变量都在全局定义，我们很难知道某个变量到底属于哪些模块，因此也给调试带来了困难。 3.无法清晰地管理模块之间的依赖关系和加载顺序。假如 module-a依赖module-b，那么上述 HTML 的 script执行顺序需要手动调整，不然可能会产生运行时错 误。 2. 命名空间 命名空间是模块化的另一种实现手段，它可以解决上述文件划分方式中全局变量定义所带来的一系列问题。下面是一个简单的例子: 1// module-a.js 8 1// module-b.js 8 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=&quot;en&quot;&gt; 3 &lt;head&gt; 4 &lt;meta charset=&quot;UTF-8&quot; /&gt; 5 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; 6 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; 7 &lt;title&gt;Document&lt;/title&gt; 8 &lt;/head&gt; 9 &lt;body&gt; 10 &lt;script src=&quot;./module-a.js&quot;&gt;&lt;/script&gt; 11 &lt;script src=&quot;./module-b.js&quot;&gt;&lt;/script&gt; 12 &lt;script&gt; 13 // 此时 window 上已经绑定了 moduleA 和 moduleB 14 console.log(moduleA.data); 15 moduleB.method(); 16 &lt;/script&gt; 17 &lt;/body&gt; 18 &lt;/html&gt; 19 这样一来，每个变量都有自己专属的命名空间，我们可以清楚地知道某个变量到底属于哪个模块，同时也避免全局变量命名的问题。 3. IIFE(立即执行函数)不过，相比于命名空间的模块化手段，IIFE实现的模块化安全性要更高，对于模块作用域的区分更加彻底。你可以参考如下IIFE 实现模块化的例子: 1// module-a.js 13 1// module-b.js 13 1 // index.html 2 &lt;!DOCTYPE html&gt; 3 &lt;html lang=&quot;en&quot;&gt; 4 &lt;head&gt; 5 &lt;meta charset=&quot;UTF-8&quot; /&gt; 6 &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt; 7 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; 8 &lt;title&gt;Document&lt;/title&gt; 9 &lt;/head&gt; 10 &lt;body&gt; 11 &lt;script src=&quot;./module-a.js&quot;&gt;&lt;/script&gt; 12 &lt;script src=&quot;./module-b.js&quot;&gt;&lt;/script&gt; 13 &lt;script&gt; 14 // 此时 window 上已经绑定了 moduleA 和 moduleB 15 console.log(moduleA.data); 16 moduleB.method(); 17 &lt;/script&gt; 18 &lt;/body&gt; 19 &lt;/html&gt; 20 我们知道，每个IIFE即立即执行函数都会创建一个私有的作用域，在私有作用域中的变量外界是无法访问的，只有模块内部的方法才能访问。拿上述的module-a来说: 1// module-a.js 13 对于其中的 data变量，我们只能在模块内部的method函数中通过闭包访问，而在其它模块中无法直接访问。这就是模块私有成员功能，避免模块私有成员被其他模块非法篡改，相比于命名空间的实现方式更加安全。但实际上，无论是命名空间还是IIFE，都是为了解决全局变量所带来的命名冲突及作用域不明确的问题，也就是在文件划分方式中所总结的问题 1和问题2，而并没有真正解决另外一个问题——模块加载。如果模块间存在依赖关系，那么 script标签的加载顺序就需要受到严格的控制，一旦顺序不对，则很 有可能产生运行时Bug。而随着前端工程的日益庞大，各个模块之间相互依赖已经是非常常见的事情，模块加载的需求已经成为了业界刚需，而以上的几种非标准模块化手段不能满足这个需求，因此我们需要指定一个行业标准去统一前端代码的模块化。不过前端的模块化规范统一也经历了漫长的发展阶段，即便是到现在也没有实现完全的统一。接下来，我们就来熟悉一下业界主流的三大模块规范: CommonJS、AMD和 ES Module。 CommonJS 规范 CommonJS 是业界最早正式提出的 JavaScript 模块规范，主要用于服务端，随着Node.js 越来越普及，这个规范也被业界广泛应用。对于模块规范而言，一般会包含 2 方面内容: 统一的模块化代码规范 实现自动加载模块的加载器(也称 loader) 对于 CommonJS 模块规范本身，相信有 Node.js使用经验的同学都不陌生了，为了方便你理解，我 举一个使用 CommonJS的简单例子: 1// module-a.js 13 代码中使用 require来导入一个模块，用module.exports来导出一个模块。实际上Node.js 内部会有 相应的 loader转译模块代码，最后模块代码会被处理成下面这样: 1(function (exports, require, module, __filename,__dirname) { 2 // 执行模块代码 3 // 返回 exports 对象 4 }); 5 对 CommonJS 而言，一方面它定义了一套完整的模块化代码规范，另一方面Node.js 为之实现了自动加载模块的loader，看上去是一个很不错的模块规范，但也存在一些问题: 1.模块加载器由 Node.js 提供，依赖了 Node.js本身的功能实现，比如文件系统，如果 CommonJS 模块直接放到浏览器中是无法执行的。当然, 业界也产生了browserify这种打包工具来支持打包 CommonJS 模块，从而顺利在浏览器中执行，相当于社区实现了一个第三方的 loader。 2.CommonJS本身约定以同步的方式进行模块加载，这种加载机制放在服务端是没问题的，一来模块都在本地，不需要进行网络IO，二来只有服务启动时才会加载模块，而服务通常启动后会一直运行，所以对服务的性能并没有太大的影响。但如果这种加载机制放到浏览器端，会带来明显的性能问题。它会产生大量同步的模块请求，浏览器要等待响应返回后才能继续解析模块。也就是说，模块请求会造成浏览器JS 解析过程的阻塞，导致页面加 载速度缓慢。 总之，CommonJS是一个不太适合在浏览器中运行的模块规范。因此，业界也设计出了全新的规范来作为浏览器端的模块标准，最知名的要数 AMD了。 AMD 规范 AMD全称为Asynchronous ModuleDefinition，即异步模块定义规范。模块根据这个规范，在浏览器环境中会被异步加载，而不会像 CommonJS规范进行同步加载，也就不会产生同步请求导致的浏览器解析过程阻塞的问题了。我们先来看看这个模块规范是如何来使用的: 1// main.js 14 在 AMD 规范当中，我们可以通过 define 去定义或加载一个模块，比如上面的main模块和print模 块，如果模块需要导出一些成员需要通过在定义模块的函数中return 出去(参考 print模块)，如果当 前模块依赖了一些其它的模块则可以通过define 的第一个参数来声明依赖(参考main模块)，这样模块的代码执行之前浏览器会先加载依赖模块。 当然，你也可以使用 require 关键字来加载一个模块，如: 1// module-a.js 2 require([&quot;./print.js&quot;], function (printModule) { 3 printModule.print(&quot;module-a&quot;); 4 }); 5 不过 require 与 define 的区别在于前者只能加载模块，而不能定义一个模块。由于没有得到浏览器的原生支持，AMD 规范需要由第三方的 loader来实现，最经典的就是requireJS 库了，它完整实现了 AMD规范，至今仍然有不少项目在使用。 不过 AMD规范使用起来稍显复杂，代码阅读和书写都比较困难。因此，这个规范并不能成为前端模块化的终极解决方案，仅仅是社区中提出的一个妥协性的方案，关于新的模块化规范的探索，业界从仍未停止脚步。 同期出现的规范当中也有 CMD规范，这个规范是由淘宝出品的SeaJS实现的，解决的问题和 AMD 一样。不过随着社区的不断发展，SeaJS 已经被requireJS兼容了。 当然，你可能也听说过 UMD(Universal ModuleDefinition)规范，其实它并不算一个新的规范， 只是兼容 AMD 和 CommonJS的一个模块化方案，可以同时运行在浏览器和 Node.js 环境。顺便提一句，后面将要介绍的 ES Module 也具备这种跨平台的能力。 ES6 Module ES6 Module也被称作 ES Module(或 ESM)， 是由 ECMAScript官方提出的模块化规范，作为一个官方提 出的规范，ESModule已经得到了现代浏览器的内置支持。在现代浏览器中，如果在 HTML中加入含 有type=&quot;module&quot;属性的 script 标签，那么浏览器会按照 ES Module规范来进行依赖加载和模块解 析，这也是 Vite 在开发阶段实现 no-bundle的原因，由于模块加载的任务交给了浏览器，即使不打包也可以顺利运行模块代码，具体的模块加载流程我们会在下一节进行详细的解释。 大家可能会担心 ES Module 的兼容性问题，其实 ES Module的浏览器兼容性如今已经相当好了，覆 盖了 90% 以上的浏览器份额，在CanIUse上的详情数据如下图所示: 不仅如此，一直以 CommonJS 作为模块标准的 Node.js 也紧跟 ES Module的发展步伐， 从12.20版本开始正式支持原生ES Module。也就是说，如今 ES Module 能够同时在浏览器与 Node.js环境中执行，拥有天然的跨平台能力。 下面是一个使用 ES Module 的简单例子: 1// main.js 11 1 &lt;!DOCTYPE html&gt; 2 &lt;html lang=&quot;en&quot;&gt; 3 &lt;head&gt; 4 &lt;meta charset=&quot;UTF-8&quot; /&gt; 5 &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/src/favicon.svg&quot;/&gt; 6 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot; /&gt; 7 &lt;title&gt;Vite App&lt;/title&gt; 8 &lt;/head&gt; 9 &lt;body&gt; 10 &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 11 &lt;script type=&quot;module&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt; 12 &lt;/body&gt; 13 &lt;/html&gt; 14 如果在 Node.js 环境中，你可以在package.json中声明type: &quot;module&quot;属性: 1// package.json 5 然后 Node.js 便会默认以 ES Module 规范去解析模块: 1node main.js 2 // 打印 a 3 顺便说一句，在 Node.js 中，即使是在 CommonJS 模块里面，也可以通过import方法顺利加载 ES 模块，如下所示: 1async function func() { ES Module 作为 ECMAScript官方提出的规范，经过五年多的发展，不仅得到了众多浏览器的原生支 持，也在Node.js中得到了原生支持，是一个能够跨平台的模块规范。同时，它也是社区各种生态库的发展趋势，尤其是被如今大火的构建工具 Vite 所深度应用。可以说，ESModule 前景一片光明， 成为前端大一统的模块标准指日可待。 当然，这一讲我们只简单介绍了ESM。至于高级特性，我们将在「高级应用篇」专门介绍。你可以先利用我这里给到的官方资料提前预习： MDN官方解释、ECMAScript内部提案细节。 小结 这一节，我们要重点掌握前端模块化的诞生意义、主流的模块化规范和ESM 规范的优势。由于前端构建工具的改革与底层模块化规范的发展息息相关，从一开始我就带你从头梳理了前端模块化的演进史，从无模块化标准的时代开始谈起，跟你介绍了文件划分的模块化方案，并分析了这个方案潜在的几个问题。随后又介绍了命名空间和IIFE两种方案，但这两种方式并没有解决模块自动加载的问题。由此展开对前端模块化规范的介绍，我主要给你分析了三个主流的模块化标准:CommonJS、AMD以 及 ESModule，针对每个规范从模块化代码标准、模块自动加载方案这两个维度给你进行了详细的拆解，最后得出 ES Module 即将成为主流前端模块化方案的结论。本小节的内容就到这里了，希望能对你有所启发，也欢迎你把自己的学习心得打到评论区，我们下一节再见~","link":"/posts/658c93f2/"},{"title":"渲染器：组件是如何被渲染成 DOM 的","text":"相对于传统的 [jQuery]{.mark} 一把梭子撸到底的开发模式，组件化可以帮助我们实现 [视图]{.mark} 和 [逻辑]{.mark} 的复用，并且可以对每个部分进行单独的思考 前言 相对于传统的 [jQuery]{.mark} 一把梭子撸到底的开发模式，组件化可以帮助我们实现 [视图]{.mark} 和 [逻辑]{.mark} 的复用，并且可以对每个部分进行单独的思考。对于一个大型的 [Vue.js]{.mark} 应用，通常是由一个个组件组合而成： 但是我们实际访问的页面，是由 [DOM]{.mark} 元素构成的，而组件的 [&lt;template&gt;]{.mark} 中的内容只是一个模板字符串而已。那模板字符串是如何被渲染成 [DOM]{.mark} 的呢？接下来我们将从组件入手，揭秘 [Vue]{.mark} 的组件是如何被渲染成真实的 [DOM]{.mark} 的。 初始化一个 Vue 3 应用 在开始本章节之前，我们先来简单初始化一个 [Vue 3]{.mark} 的应用： shell复制代码# 安装 vue cli $ yarn global add @vue/cli # 创建 vue3 的基础脚手架 一路回车 $ vue create vue3-demo 接下来，打开项目，可以看到[Vue.js]{.mark} 的入口文件 [main.js]{.mark} 的内容如下： import { createApp } from 'vue' import App from './App.vue' createApp(App).mount('#app') 这里就有一个根组件 [App.vue]{.mark}。为了更加简单地介绍 [Vue]{.mark} 根组件的渲染过程，我把 [App.vue]{.mark} 根组件进行了一个简单的修改： html复制代码&lt;template&gt; &lt;div class=&quot;helloWorld&quot;&gt; hello world &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { setup() { // ... } } &lt;/script&gt; 根组件模板编译 我们知道 [.vue]{.mark} 类型的文件无法在 [Web]{.mark} 端直接加载，我们通常会在 [webpack]{.mark} 的编译阶段，通过 [vue-loader]{.mark} 编译生成组件相关的 [JavaScript]{.mark} 和 [CSS]{.mark}，并把 [template]{.mark} 部分编译转换成 [render]{.mark} 函数添加到组件对象的属性中。 上述的 [App.vue]{.mark} 文件内的模板其实是会被编译工具在编译时转成一个渲染函数，大致如下： import { openBlock as _openBlock, createElementBlock as_createElementBlock } from &quot;vue&quot; const _hoisted_1 = { class: &quot;helloWorld&quot; } export function render(_ctx, _cache, $props, $setup, $data,$options) { return (_openBlock(), _createElementBlock(&quot;div&quot;, _hoisted_1, &quot;hello world &quot;)) } 关于 [&lt;template&gt;]{.mark} 中的模板字符串是如何被编译成 [render]{.mark} 函数的，以及 [_hoisted_1]{.mark} 是个什么玩意，我们将在后续章节中详细介绍。 现在我们只需要知道 [&lt;script&gt;]{.mark} 中的对象内容最终会和编译后的模板内容一起，生成一个 [App]{.mark} 对象传入 [createApp]{.mark} 函数中： { render(_ctx, _cache, $props, $setup, $data, $options) { // ... }, setup() { // ... } } 对象组件渲染成真实的 DOM 接着回到 [main.js]{.mark} 的入口文件，整个初始化的过程只剩下如下部分了： createApp(App).mount('#app') 打开源码，可以看一下 [createApp]{.mark} 的过程： // packages/runtime-dom/src/index.ts export const createApp = (...args) =&gt; { const app = ensureRenderer().createApp(...args); // ... return app; }; 猜测一下，[ensureRenderer().createApp(...args)]{.mark} 这个链式函数执行完成后肯定返回了 [mount]{.mark} 函数，[ensureRenderer]{.mark} 就是构造了一个带有 [createApp]{.mark} 函数的渲染器renderer 对象 ： // packages/runtime-dom/src/index.ts function ensureRenderer() { // 如果 renderer 有值的话，那么以后都不会初始化了 return ( renderer || (renderer = createRenderer(rendererOptions) ) } // renderOptions 包含以下函数： const renderOptions = { createElement, createText, setText, setElementText, patchProp, insert, remove, } 这里返回的 [renderer]{.mark} 对象，可以认为是一个跨平台的渲染器对象，针对不同的平台，会创建出不同的 [renderer]{.mark} 对象，上述是创建浏览器环境的 [renderer]{.mark} 对象，对于服务端渲染的场景，则会创建 [serverrender]{.mark} 的 [renderer]{.mark}: // packages/runtime-dom/src/index.ts let enabledHydration = false function ensureHydrationRenderer() { renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions) enabledHydration = true return renderer } 再来看一下 [createRender]{.mark} // packages/runtime-core/src/renderer.ts export function createRenderer(options) { // ... // 这里不介绍 hydrate 模式 return { render, hydrate, createApp: createAppAPI(render, hydrate), } } 可以看到，[renderer]{.mark} 对象上包含了 [createApp]{.mark} 和 [render]{.mark} 方法。再来看一下 [createApp]{.mark} 方法： // packages/runtime-core/src/apiCreateApp.ts function createAppAPI(render, hydrate) { // createApp createApp 方法接收的两个参数：根组件的对象和 prop return function createApp(rootComponent, rootProps = null) { const app = { // ... 省略很多不需要在这里介绍的属性 _component: rootComponent, _props: rootProps, mount(rootContainer, isHydrate, isSVG) { // ... } } return app } } 直到这里，我们才真正拨开了 [Vue3]{.mark} 初始化根组件的核心方法，也就是入口文件 [createApp]{.mark} 真正执行的内容就是这里的 [createAppAPI]{.mark} 函数中的 [createApp]{.mark} 函数，该函数接收了 [&lt;App/&gt;]{.mark} 组件作为根组件 [rootComponent]{.mark}，返回了一个包含 [mount]{.mark} 方法的 [app]{.mark} 对象。 接下来再深入地看一下 [mount]{.mark} 的内部实现： // packages/runtime-core/src/apiCreateApp.ts mount(rootContainer, isHydrate, isSVG) { if (!isMounted) { // ... 省略部分不重要的代码 // 1. 创建根组件的 vnode const vnode = createVNode( rootComponent, rootProps ) // 2. 渲染根组件 render(vnode, rootContainer, isSVG) isMounted = true } } 1. 创建根组件的 vnode 什么是 [vnode]{.mark} 节点呢？其实它和 [VirtualDOM]{.mark} 是一个意思，就是将真实的 [DOM]{.mark} 以普通对象形式的数据结构来表达，简化了很多 [DOM]{.mark} 中内容。 熟悉 [JSDOM]{.mark} 编程的小伙伴都知道 [JS]{.mark} 直接操作 [DOM]{.mark} 往往会带来许多性能负担，所以 [vnode]{.mark} 提供了对真实 [DOM]{.mark} 上的一层虚拟映射，我们只需要操作这个虚拟的数据结构，那些真正费性能的活交给这些框架来操作就好了，框架会帮我们做很多性能优化的事情。这也是 [vnode]{.mark} 带来的最大的优势之一。 其次，因为 [vnode]{.mark} 只是一种与平台无关的数据结构而已，所以理论上我们也可以将它渲染到不同平台上从而达到跨平台渲染的目的。这个也是 [weex]{.mark}、[mpvue]{.mark} 等跨端渲染框架的核心基础。 上述例子中的 [template]{.mark} 中的内容用 [vnode]{.mark} 可以表示为： const vnode = { type: 'div', props: { 'class': 'helloWorld' }, children: 'helloWorld' } 说了这么多，那么根节点是如何被创建成一个 [vnode]{.mark} 的呢？核心也就在 [createVNode]{.mark} 函数中： typescript复制代码// packages/runtime-core/src/vnode.ts function createBaseVNode(...) { const vnode = { type, props, key: props &amp;&amp; normalizeKey(props), children, component: null, shapeFlag, patchFlag, dynamicProps, dynamicChildren: null, // ... 一些其他属性 } // ... return vnode } function createVNode(type, props = null, children = null) { if (props) { // 如果存在 props 则需要对 props 进行一些处理，这里先省略 } // ... // 处理 shapeFlag 类型 const shapeFlag = isString(type) ? ShapeFlags.ELEMENT : __FEATURE_SUSPENSE__ &amp;&amp; isSuspense(type) ? ShapeFlags.SUSPENSE : isTeleport(type) ? ShapeFlags.TELEPORT : isObject(type) ? ShapeFlags.STATEFUL_COMPONENT : isFunction(type) ? ShapeFlags.FUNCTIONAL_COMPONENT : 0 // ... return createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true ) } 当进行根组件渲染的时候，[createVNode]{.mark} 的第一个入参 [type]{.mark} 是我们的 [App]{.mark} 对象，也就是一个 [Object]{.mark}，所以得到的 [shapeFlag]{.mark} 的值是 [STATEFUL_COMPONENT]{.mark}，代表的是一个有状态组件对象。（这里顺便提一下，如果传入的是个函数，那么就是一个函数式组件 [FUNCTIONAL_COMPONENT]{.mark}，函数式组件和有状态的对象组件都是 [Vue]{.mark} 可处理的组件类型，这个会在下面渲染阶段提及。） 到这里，[Vue]{.mark} 完成了对根组件的 [Vnode]{.mark} 对象的创建，接下来要做的就是将该组件渲染到页面中。 2. VNode 渲染成真实的组件 回到 [mount]{.mark} 函数中，接下来一步就是对 [vnode]{.mark} 的渲染工作，核心代码： render(vnode, rootContainer); 那么这里的 [render]{.mark} 函数是什么呢？通过上面的代码我们发现，其实它是在调用 [createAppAPI]{.mark} 时传入进来的，而 [createAppAPI]{.mark} 则是在创建 [renderer]{.mark} 渲染器的时候调用的。那么，接下来看看 [render]{.mark} 函数的实现： // packages/runtime-core/src/renderer.ts const render = (vnode, container) =&gt; { if (vnode == null) { // 如果 vnode 不存在，表示需要卸载组件 if (container._vnode) { unmount(container._vnode, null, null, true) } } else { // 否则进入更新流程（初始化创建也是特殊的一种更新） patch(container._vnode || null, vnode, container) } // 缓存 vnode container._vnode = vnode } 很明显，对于初始化根组件的过程中，传入了一个根组件的 [vnode]{.mark} 对象，所以这里会执行 [patch]{.mark} 相关的动作。[patch]{.mark} 本意是补丁的意思，可以理解成为更新做一些补丁的活儿，其实初始的过程也可以看作是一个全量补丁，一种特殊的更新操作。 // packages/runtime-core/src/renderer.ts function patch(n1,n2,container = null,anchor = null,parentComponent =null) { // 对于类型不同的新老节点，直接进行卸载 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) { anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null } // 基于 n2 的类型来判断 // 因为 n2 是新的 vnode const { type, shapeFlag } = n2; switch (type) { case Text: // 处理文本节点 break; // 其中还有几个类型比如： static fragment comment default: // 这里就基于 shapeFlag 来处理 if (shapeFlag &amp; ShapeFlags.ELEMENT) { // 处理普通 DOM 元素 processElement(n1, n2, container, anchor, parentComponent); } else if (shapeFlag &amp; ShapeFlags.COMPONENT) { // 处理 component processComponent(n1, n2, container, parentComponent); } else if { // ... 处理其他元素 } } } [patch]{.mark} 函数主要接收的参数说明如下： n1 表示老的 vnode 节点； n2 表示新的 vnode 节点； container 表示需要挂载的 dom 容器； anchor 挂载的参考元素； parentComponent 父组件。 这里我们主要关注前 3个参数，因为是初始化的过程，所以 [n1]{.mark} 本次值为空，核心看 [n2]{.mark} 的值，[n2]{.mark} 有一个 [type]{.mark} 和 [shapeFlag]{.mark}。当前 [n2]{.mark} 的 [type]{.mark} 是 [App]{.mark} 组件对象，所以逻辑会进入 [Switch]{.mark} 的 [default]{.mark} 中。再比较 [shapeFlag]{.mark} 属性，前面提到 [shapeFlag]{.mark} 的值是 [STATEFUL_COMPONENT]{.mark}。 这里需要注意的是 [ShapeFlags]{.mark} 是一个二进制左移操作符生成的对象，其中[ShapeFlags.COMPONENT= ShapeFlags.STATEFUL_COMPONENT |ShapeFlags.FUNCTIONAL_COMPONENT]{.mark}， 所以 [shapeFlag &amp;ShapeFlags.COMPONENT]{.mark} 这里的值是 [true]{.mark}，关于二进制左移操作符对象在 [Vue3]{.mark} 中会大量使用，后面也会详细介绍。 接着也就进入了 [processComponent]{.mark} 的逻辑了： // packages/runtime-core/src/renderer.ts function processComponent(n1, n2, container, parentComponent) { // 如果 n1 没有值的话，那么就是 mount if (!n1) { // 初始化 component mountComponent(n2, container, parentComponent); } else { updateComponent(n1, n2, container); } } 同理，这里我们只看初始化的逻辑，所以 [n1]{.mark} 此时还是个空值，那么就会进入 [mountComponent]{.mark} 函数对组件进行初始挂载过程。 // packages/runtime-core/src/renderer.ts function mountComponent(initialVNode, container, parentComponent) { // 1. 先创建一个 component instance const instance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent )); // 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数... setupComponent(instance); // 3. 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container); } 该函数实现过程还是非常清晰的，思考一下，一个组件的初始化要做哪些内容呢？ 其实很容易想到，我们需要一个实例化的组件对象，该对象可以在 [Vue]{.mark} 执行的运行时上下文中随时获取到，另外还需要对实例化后的组件中的属性做一些优化、处理、赋值等操作，最后，就是把组件实例的 [render]{.mark} 函数执行一遍。 上面也是 [mountComponent]{.mark} 核心做的事情，我们一个个来看。 第一步是组件实例化，在 [Vue3]{.mark} 中通过 [createComponentInstance]{.mark} 的方法创建组件实例，返回的是一个组件实例的对象，大致包含以下属性： // packages/runtime-core/src/component.ts const instance = { // 这里是组件对象 type: vnode.type, // 组件 vnode vnode, // 新的组件 vnode next: null, // props 相关 props: {}, // 指向父组件 parent, // 依赖注入相关 provides: parent ? parent.provides : {}, // 渲染上下文代理 proxy: null, // 标记是否被挂载 isMounted: false, // attrs 相关 attrs: {}, // slots 相关 slots: {}, // context 相关 ctx: {}, // setup return 的状态数据 setupState: {}, // ... }; 上述实例属性，相对源码而言，已经省略了很多内容了，这些属性现在看着肯定不知所云，头皮发麻。但相应的属性是 [vue]{.mark} 在特定的场景和功能下才会用到的，相信你跟着本小册一起阅读后，回过头来再去看一遍这些属性，就会”顿悟”。 然后是对实例化后的组件中的属性做一些优化、处理、赋值等操作，这里主要是初始化了 [props]{.mark}、[slots]{.mark}，并执行组件的 [setup]{.mark} 函数，核心的实现和功能我们将在下一节介绍。 // packages/runtime-core/src/component.ts export function setupComponent(instance) { // 1. 处理 props // 取出存在 vnode 里面的 props const { props, children } = instance.vnode; initProps(instance, props); // 2. 处理 slots initSlots(instance, children); // 3. 调用 setup 并处理 setupResult setupStatefulComponent(instance); } 最后是把组件实例的 [render]{.mark} 函数执行一遍，这里是通过 [setupRenderEffect]{.mark} 来执行的。我们再看一下这个函数的实现： // packages/runtime-core/src/renderer.ts const setupRenderEffect = (instance, initialVNode, container, anchor,parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 渲染子树的 vnode const subTree = (instance.subTree = renderComponentRoot(instance)) // 挂载子树 vnode 到 container 中 patch(null, subTree, container, anchor, instance, parentSuspense, isSVG) // 把渲染生成的子树根 DOM 节点存储到 el 属性上 initialVNode.el = subTree.el instance.isMounted = true } else { // 更新相关，后面介绍 } } // 创建副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions) } 这里我们再看一下 [componentUpdateFn]{.mark} 这个函数，核心是调用了 [renderComponentRoot]{.mark} 来生成 [subTree]{.mark}，然后再把 [subTree]{.mark} 挂载到 [container]{.mark} 中。其实 [renderComponentRoot]{.mark} 的核心工作就是执行 [instance.render]{.mark} 方法，该方法前面我们已经说了，组件在编译时会生成组件对象，包含了 [render]{.mark} 函数，该函数内部是一系列的渲染函数的执行： import { openBlock, createElementBlock } from &quot;vue&quot; const _hoisted_1 = { class: &quot;helloWorld&quot; } export function render(...) { return (openBlock(), createElementBlock(&quot;div&quot;, _hoisted_1, &quot; helloworld &quot;)) } 那么只需要看一下 [createElementBlock]{.mark} 函数的实现： // packages/runtime-core/src/vnode.ts export const createElementBlock = (...) =&gt; { return setupBlock( createBaseVNode( type, props, children, patchFlag, dynamicProps, shapeFlag, true /* isBlock */ ) ) }; 可以看到本质还是调用了 [createBaseVNode]{.mark} 创新 [vnode]{.mark}。所以，我们可以推导出 [subtree]{.mark} 就是调用 [render]{.mark} 函数而生产的 [vnode]{.mark} 节点。这里需要注意的一点是，因为 [subtree]{.mark} 调用的 [createBaseVNode]{.mark} 创建时，传入的 [typediv]{.mark} 在这里是个 [string]{.mark}，所以返回的 [shapeFlags]{.mark} 的值是 [ELEMENT]{.mark}。 渲染生成子树 [vnode]{.mark} 后，接下来就是继续调用 [patch]{.mark} 函数把子树 [vnode]{.mark} 挂载到 [container]{.mark} 中了，前面说过了 [patch]{.mark} 的实现，再来简单看一下当传入的 [vnode]{.mark} 的 [shapeFlags]{.mark} 是个 [ELEMENT]{.mark} 时，会调用 [processElement]{.mark} 这个函数： if (shapeFlag &amp; ShapeFlags.ELEMENT) { processElement(n1, n2, container, anchor, parentComponent); } 我们来看一下 [processElement]{.mark} 的实现： // packages/runtime-core/src/renderer.ts function processElement(n1, n2, container, anchor, parentComponent) { if (!n1) { // 挂载元素节点 mountElement(n2, container, anchor); } else { // 更新元素节点 updateElement(n1, n2, container, anchor, parentComponent); } } 因为在初始化的过程中，[n1]{.mark} 是 [null]{.mark}，所以这里执行的是 [mountElement]{.mark} 进行元素的初始化挂载。 // packages/runtime-core/src/renderer.ts const mountElement = (vnode, container, anchor, parentComponent,parentSuspense, isSVG, optimized) =&gt; { let el const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode // ... // 根据 vnode 创建 DOM 节点 el = vnode.el = hostCreateElement(vnode.type, isSVG, props &amp;&amp; props.is) if (props) { // 处理 props 属性 for (const key in props) { if (!isReservedProp(key)) { hostPatchProp(el, key, null, props[key], isSVG) } } } // 文本节点处理 if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { hostSetElementText(el, vnode.children) } else if (shapeFlag &amp; ShapeFlags.ARRAY_CHILDREN) { // 如果节点是个数据类型，则递归子节点 mountChildren(vnode.children, el) } // 把创建好的 el 元素挂载到容器中 hostInsert(el, container, anchor) } [mountElemet]{.mark} 首先是通过 [hostCreateElement]{.mark} 创建了一个 [DOM]{.mark} 节点，然后处理一下 [props]{.mark} 属性，接着根据 [shapeFlag]{.mark} 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点，如果子节点是个数组，比如这种情况： return (openBlock(), createElementBlock(&quot;div&quot;, _hoisted_1, [ hoisted_2, createVNode(_component_Hello) ])) 对于这种子节点是数组的情况时，它的 [shapeFlag]{.mark} 将是一个数组类型 [ARRAY_CHILDREN]{.mark}。此时会对该 [vnode]{.mark} 节点的子节点调用 [mountChildren]{.mark} 进行递归的 [patch]{.mark} 渲染。 最后，处理完所有子节点后，通过 [hostInsert]{.mark} 方法把缓存在内存中的 [DOMel]{.mark} 映射渲染到真实的 [DOM Container]{.mark} 当中。 // packages/runtime-dom/src/nodeOps.ts insert: (child, parent, anchor) { parent.insertBefore(child, anchor || null) } 总结 到这里，我们已经完成了从入口文件开始，分析根组件如何挂载渲染到真实 [DOM]{.mark} 的流程，再简单通过一张流程图回顾一下上述内容，绿色部分是初始化的过程，也是本小节的内容，灰色部分我们后面章节再做介绍。 然后我们再引用一下 [Vue]{.mark} 官网上的一张渲染流程图： 现在再来看这一张图，整体流程就会清晰了很多：在组件初始化挂载阶段，模板被编译成渲染函数的形式，交由渲染器执行，渲染器执行渲染函数得到 [APP]{.mark} 组件对象的子树 [vnode]{.mark}，子树 [vnode]{.mark} 进行递归 [patch]{.mark} 后生成不同类型的 [DOM]{.mark} 节点，最后把这些 [DOM]{.mark} 节点挂载到页面的 [container]{.mark} 当中。","link":"/posts/2d76dd84/"},{"title":"渲染器：数据访问是如何被代理的？","text":"我们先看一个有意思的示例 前言 组件上有一个动态文本节点 []{.mark}，但是却有 [2]{.mark} 处定义了 [msg]{.mark} 响应式数据；另外有一个按钮，点击后会修改响应式数据。 &lt;template&gt; &lt;p&gt;&lt;/p&gt; &lt;button @click=&quot;changeMsg&quot;&gt;点击试试&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { data() { return { msg: 'msg from data' } }, setup() { const msg = ref('msg from setup') return { msg } }, methods: { changeMsg() { this.msg = 'change' } } } &lt;/script&gt; 思考一下： 界面显示的内容是什么？ 点击按钮后，修改的是哪部分的数据？是 data 中定义的，还是 setup 中的呢？ 先别急着找答案，相信你阅读完这一节，一定会得到答案。 上一节，我们知道了根组件在初始化渲染的过程中，会执行 [mountComponent]{.mark} 的函数： function mountComponent(initialVNode, container,parentComponent) { // 1. 先创建一个 component instance const instance = (initialVNode.component = createComponentInstance( initialVNode, parentComponent )); // 2. 初始化组件实例 setupComponent(instance); // 3. 设置并运行带副作用的渲染函数 setupRenderEffect(instance, initialVNode, container); } 上文，我们简单介绍了关于 [setupComponent]{.mark} 函数的作用是为了对实例化后的组件中的属性做一些优化、处理、赋值等操作。本小节我们将重点介绍 [setupComponent]{.mark} 的内部实现和作用。 初始化组件实例 我们再来回顾一下 [setupComponent]{.mark} 在源码中的实现： export function setupComponent(instance, isSSR = false) { const { props, children } = instance.vnode // 判断组件是否是有状态的组件 const isStateful = isStatefulComponent(instance) // 初始化 props initProps(instance, props, isStateful, isSSR) // 初始化 slots initSlots(instance, children) // 如果是有状态组件，那么去设置有状态组件实例 const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : undefined return setupResult } [setupComponent]{.mark} 方法做了什么？ 通过 isStatefulComponent(instance) 判断是否是有状态的组件； initProps 初始化 props； initSlots 初始化 slots； 根据组件是否是有状态的，来决定是否需要执行 setupStatefulComponent 函数。 其中， [isStatefulComponent]{.mark} 判断是否是有状态的组件的函数如下： function isStatefulComponent(instance) { return instance.vnode.shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT } 前面我们已经说过了，[ShapeFlags]{.mark} 在遇到组件类型的 [type =Object]{.mark} 时，[vnode]{.mark} 的[shapeFlags =ShapeFlags.STATEFUL_COMPONENT]{.mark}。所以这里会执行 [setupStatefulComponent]{.mark} 函数。 function setupStatefulComponent(instance, isSSR) { // 定义 Component 变量 const Component = instance.type // 1. 创建渲染代理的属性访问缓存 instance.accessCache = Object.create(null) // 2. 创建渲染上下文代理, proxy 对象其实是代理了 instance.ctx 对象 instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers); // 3. 执行 setup 函数 const { setup } = Component if (setup) { // 如果 setup 函数带参数，则创建一个 setupContext const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null) // 执行 setup 函数，获取结果 const setupResult = callWithErrorHandling(setup, instance, 0,[instance.props, setupContext]) // 处理 setup 执行结果 handleSetupResult(instance, setupResult) } else { // 4. 完成组件实例设置 finishComponentSetup(instance, isSSR) } } [setupStatefulComponent]{.mark} 字面意思就是设置有状态组件，那么什么是有状态组件呢？简单而言，就是对于有状态组件，[Vue]{.mark} 内部会保留组件状态数据。相对于有状态组件而言，[Vue]{.mark} 还存在一种函数组件 [FUNCTIONAL_COMPONENT]{.mark}，一起看个示例： import { ref } from 'vue'; export default () =&gt; { let num = ref(0); const plusNum = () =&gt; { num.value ++; }; return ( &lt;div&gt; &lt;button onClick={plusNum}&gt; { num.value } &lt;/button&gt; &lt;/div&gt; ) } 这个函数点击按钮时，[num]{.mark} 的值并不会按照我们预期那样值会一直递增，因为它是一个函数组件，函数组件内部是没有状态保持的，所以 [num]{.mark} 数据更新时，组件会重新渲染，[num]{.mark} 的值永远不变一直是 [0]{.mark}。 所以在这个时候，为了能符合我们预期的结果，我们需要将其设置成有状态的组件。我们可以通过 [defineComponent]{.mark} 函数包装一下： import { ref, defineComponent } from 'vue'; export default defineComponent(() =&gt; { let num = ref(0); const plusNum = () =&gt; { num.value ++; }; return () =&gt; ( &lt;div&gt; &lt;button onClick={plusNum}&gt; { num.value } &lt;/button&gt; &lt;/div&gt; ) }); [defineComponent]{.mark} 返回的是个对象类型的 [type]{.mark}，所以就变成了有状态组件。 好了，搞清楚什么是有状态组件后，我们接着回到 [setupStatefulComponent]{.mark} 实现中，来一步步地分析其核心实现的原理。 创建渲染上下文代理 首先我们看 [1-2]{.mark} 两个步骤，关于第一点：为什么要创建渲染代理的属性访问缓存呢？这里先卖个关子，先看第二步：创建渲染上下文代理，这里为什么要对 [instance.ctx]{.mark} 做代理呢？如果熟悉 [Vue2]{.mark} 的小伙伴应该了解对于 [Vue 2]{.mark} 的 [OptionsAPI]{.mark} 的写法如下： &lt;template&gt; &lt;p&gt;&lt;/p&gt; &lt;/template&gt; &lt;script&gt; export default { data() { num: 1 }, mounted() { this.num = 2 } } &lt;/script&gt; [Vue2.x]{.mark} 是如何实现访问 [this.num]{.mark} 获取到 [num]{.mark} 的值，而不是通过 [this._data.num]{.mark} 来获取 [num]{.mark} 的值呢？其实 [Vue2.x]{.mark} 版本中，为 [_data]{.mark} 设置了一层代理： _proxy(options.data); function _proxy (data) { const that = this; Object.keys(data).forEach(key =&gt; { Object.defineProperty(that, key, { configurable: true, enumerable: true, get: function proxyGetter () { return that._data[key]; }, set: function proxySetter (val) { that._data[key] = val; } }) }); } 本质就是通过 [Object.defineProperty]{.mark} 使在访问 [this]{.mark} 上的某属性时从 [this._data]{.mark} 中读取（写入）。 而 [Vue 3]{.mark} 也在这里做了类似的事情，[Vue3]{.mark} 内部有很多状态属性，存储在不同的对象上，比如 [setupState]{.mark}、[ctx]{.mark}、[data]{.mark}、[props]{.mark}。这样用户取数据就会考虑具体从哪个对象中获取，这无疑增加了用户的使用负担，所以对 [instance.ctx]{.mark} 进行代理，然后根据属性优先级关系依次完成从特定对象上获取值。 get 了解了代理的功能后，我们来具体看一下是如何实现代理功能的，也就是 [proxy]{.mark} 的 [PublicInstanceProxyHandlers]{.mark} 它的实现。先看一下 [get]{.mark} 函数： export const PublicInstanceProxyHandlers = { get({ _: instance }, key) { const { ctx, setupState, data, props, accessCache, type, appContext } =instance let normalizedProps if (key[0] !== '$') { // 从缓存中获取当前 key 存在于哪个属性中 const n = accessCache![key] if (n !== undefined) { switch (n) { case AccessTypes.SETUP: return setupState[key] case AccessTypes.DATA: return data[key] case AccessTypes.CONTEXT: return ctx[key] case AccessTypes.PROPS: return props![key] } } else if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) { // 从 setupState 中取 accessCache![key] = AccessTypes.SETUP return setupState[key] } else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) { // 从 data 中取 accessCache![key] = AccessTypes.DATA return data[key] } else if ( (normalizedProps = instance.propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key) ) { // 从 props 中取 accessCache![key] = AccessTypes.PROPS return props![key] } else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) { // 从 ctx 中取 accessCache![key] = AccessTypes.CONTEXT return ctx[key] } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) { // 都取不到 accessCache![key] = AccessTypes.OTHER } } const publicGetter = publicPropertiesMap[key] let cssModule, globalProperties if (publicGetter) { // 以 $ 保留字开头的相关函数和方法 // ... } else if ( // css module (cssModule = type.__cssModules) &amp;&amp; (cssModule = cssModule[key]) ) { // ... } else if (ctx !== EMPTY_OBJ &amp;&amp; hasOwn(ctx, key)) { // ... } else if ( // 全局属性 ((globalProperties = appContext.config.globalProperties), hasOwn(globalProperties, key)) ) { // ... } else if (__DEV__) { // 一些告警 // ... } } } 这里，可以回答我们的第一步 [创建渲染代理的属性访问缓存]{.mark} 这个步骤的问题了。如果我们知道 [key]{.mark} 存在于哪个对象上，那么就可以直接通过对象取值的操作获取属性上的值了。如果我们不知道用户访问的 [key]{.mark} 存在于哪个属性上，那只能通过 [hasOwn]{.mark} 的方法先判断存在于哪个属性上，再通过对象取值的操作获取属性值，这无疑是多操作了一步，而且这个判断是比较耗费性能的。如果遇到大量渲染取值的操作，那么这块就是个性能瓶颈，所以这里用了 [accessCache]{.mark} 来标记缓存 [key]{.mark} 存在于哪个属性上。这其实也相当于用一部分空间换时间的优化。 接下来，函数首先判断 [key[0] !=='$']{.mark} 的情况（[$]{.mark} 开头的一般是 [Vue]{.mark} 组件实例上的内置属性），在 [Vue3]{.mark} 源码中，会依次从 [setupState、data、props、ctx]{.mark} 这几类数据中取状态值。 这里的定义顺序，决定了后续取值的优先级顺序：[setupState]{.mark} &gt;[data]{.mark} &gt;[props]{.mark} &gt; [ctx]{.mark}。 如果 [key]{.mark} 是以 [$]{.mark} 开头，则首先会判断是否是存在于组件实例上的内置属性： 整体的获取顺序依次是：[publicGetter]{.mark} &gt; [cssModule]{.mark} &gt; [ctx]{.mark}。最后，如果都取不到，那么在开发环境就会给一些告警提示。 set 接着继续看一下设置对象属性的代理函数： export const PublicInstanceProxyHandlers = { set({ _: instance }, key, value) { const { data, setupState, ctx } = instance if (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) { // 设置 setupState setupState[key] = value return true } else if (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) { // 设置 data data[key] = value return true } else if (hasOwn(instance.props, key)) { // 不能给 props 赋值 return false } if (key[0] === '$' &amp;&amp; key.slice(1) in instance) { // 不能给组件实例上的内置属性赋值 return false } else { // 用户自定义数据赋值 ctx[key] = value } return true } } 可以看到这里也是和前面 [get]{.mark} 函数类似的通过调用顺序来实现对 [set]{.mark} 函数不同属性设置优先级的，可以直观地看到优先级关系为：[setupState]{.mark} &gt; [data]{.mark} &gt; [props]{.mark}。同时这里也有说明：就是如果直接对 [props]{.mark} 或者组件实例上的内置属性赋值，则会告警。 has 最后，再看一个 [proxy]{.mark} 属性 [has]{.mark} 的实现： export const PublicInstanceProxyHandlers = { has({_: { data, setupState, accessCache, ctx, appContext, propsOptions}}, key) { let normalizedProps return ( !!accessCache![key] || (data !== EMPTY_OBJ &amp;&amp; hasOwn(data, key)) || (setupState !== EMPTY_OBJ &amp;&amp; hasOwn(setupState, key)) || ((normalizedProps = propsOptions[0]) &amp;&amp; hasOwn(normalizedProps, key))|| hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key) ) }, } 这个函数则是依次判断 [key]{.mark} 是否存在于 [accessCache]{.mark} &gt; [data]{.mark} &gt; [setupState]{.mark} &gt; [prop]{.mark} &gt; [ctx]{.mark} &gt; [publicPropertiesMap]{.mark} &gt; [globalProperties]{.mark}，然后返回结果。 [has]{.mark} 在业务代码的使用定义如下： export default { created () { // 这里会触发 has 函数 console.log('msg' in this) } } 至此，我们就搞清楚了创建上下文代理的过程。 调用执行 setup 函数 一个简单的包含 [CompositionAPI]{.mark} 的 [Vue 3 demo]{.mark} 如下： &lt;template&gt; &lt;p&gt;&lt;/p&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: String }, setup (props, setupContext) { // todo } } &lt;/script&gt; 这里的 [setup]{.mark} 函数，正是在这里被调用执行的： // 获取 setup 函数 const { setup } = Component // 存在 setup 函数 if (setup) { // 根据 setup 函数的入参长度，判断是否需要创建 setupContext 对象 const setupContext = (instance.setupContext = setup.length &gt; 1 ? createSetupContext(instance) : null) // 调用 setup const setupResult = callWithErrorHandling(setup, instance, 0,[instance.props, setupContext]) // 处理 setup 执行结果 handleSetupResult(instance, setupResult) } createSetupContext 因为 [setupContext]{.mark} 是 [setup]{.mark} 中的第二个参数，所以会判断 [setup]{.mark} 函数参数的长度，如果大于 [1]{.mark}，则会通过 [createSetupContext]{.mark} 函数创建 [setupContext]{.mark} 上下文。 该上下文创建如下： function createSetupContext (instance) { return { get attrs() { return attrs || (attrs = createAttrsProxy(instance)) }, slots: instance.slots, emit: instance.emit, expose } } 可以看到，[setupContext]{.mark} 中包含了 [attrs、slots、emit、expose]{.mark} 这些属性。这些属性分别代表着：组件的属性、插槽、派发事件的方法 [emit]{.mark}、以及所有想从当前组件实例导出的内容 [expose]{.mark}。 这里有个小的知识点，就是可以通过函数的 [length]{.mark} 属性来判断函数参数的个数： function foo() {}; foo.length // 0 function bar(a) {}; bar.length // 1 callWithErrorHandling 第二步，通过 [callWithErrorHandling]{.mark} 函数来间接执行 [setup]{.mark} 函数，其实就是执行了以下代码： const setupResult = setup &amp;&amp;setup(shallowReadonly(instance.props), setupContext); 只不过增加了对执行过程中 [handleError]{.mark} 的捕获。 在后续章节的阅读中，你会发现 [Vue3]{.mark} 很多函数的调用都是通过 [callWithErrorHandling]{.mark} 来包裹的： export function callWithErrorHandling(fn, instance, type, args= []) { let res try { res = args ? fn(...args) : fn() } catch (err) { handleError(err, instance, type) } return res } 这样的好处一方面可以由 [Vue]{.mark} 内部统一 [try...catch]{.mark} 处理用户代码运行可能出现的错误。另一方面这些错误也可以交由用户统一注册的 [errorHandler]{.mark} 进行处理，比如上报给监控系统。 handleSetupResult 最后执行 [handleSetupResult]{.mark} 函数： function handleSetupResult(instance, setupResult) { if (isFunction(setupResult)) { // setup 返回渲染函数 instance.render = setupResult } else if (isObject(setupResult)) { // proxyRefs 的作用就是把 setupResult 对象做一层代理 instance.setupState = proxyRefs(setupResult); } finishComponentSetup(instance) } [setup]{.mark} 返回值不一样的话，会有不同的处理，如果 [setupResult]{.mark} 是个函数，那么会把该函数绑定到 [render]{.mark} 上。比如： &lt;script&gt; import { createVnode } from 'vue' export default { props: { msg: String }, setup (props, { emit }) { return (ctx) =&gt; { return [ createVnode('p', null, ctx.msg) ] } } } &lt;/script&gt; 当 [setupResult]{.mark} 是一个对象的时候，我们为 [setupResult]{.mark} 对象通过 [proxyRefs]{.mark} 作了一层代理，方便用户直接访问 [ref]{.mark} 类型的值。比如，在模板中访问 [setupResult]{.mark} 中的数据，就可以省略 [.value]{.mark} 的取值，而由代理来默认取 [.value]{.mark} 的值。 注意，这里 [instance.setupState = proxyRefs(setupResult);]{.mark} 之前的Vue 源码的写法是 [instance.setupState =reactive(setupResult);]{.mark} ，至于为什么改成上面的，Vue作者也有相关说明：[Template auto ref unwrapping for setup() returnobject is now applied only to the root level refs.]{.mark} 完成组件实例设置 最后，到了 [finishComponentSetup]{.mark} 这个函数了： function finishComponentSetup(instance) { // type 是个组件对象 const Component = instance.type; if (!instance.render) { // 如果组件没有 render 函数，那么就需要把 template 编译成 render 函数 if (compile &amp;&amp; !Component.render) { if (Component.template) { // 这里就是 runtime 模块和 compile 模块结合点 // 运行时编译 Component.render = compile(Component.template, { isCustomElement: instance.appContext.config.isCustomElement || NO }) } } instance.render = Component.render; } if (__FEATURE_OPTIONS_API__ &amp;&amp; !(__COMPAT__ &amp;&amp; skipOptions)) { // 兼容选项式组件的调用逻辑 } } 这里主要做的就是根据 [instance]{.mark} 上有没有 [render]{.mark} 函数来判断是否需要进行运行时渲染，运行时渲染指的是在浏览器运行的过程中，动态编译 [&lt;template&gt;]{.mark} 标签内的内容，产出渲染函数。对于编译时渲染，则是有渲染函数的，因为模板中的内容会被 [webpack]{.mark} 中 [vue-loader]{.mark} 这样的插件进行编译。 另外需要注意的，这里有个 [__FEATURE_OPTIONS_API__]{.mark} 变量用来标记是否是兼容 [选项式API]{.mark} 调用，如果我们只使用 [CompositionApi]{.mark} 那么就可以通过 [webpack]{.mark} 静态变量注入的方式关闭此特性。然后交由 [Tree-Shacking]{.mark} 删除无用的代码，从而减少引用代码包的体积。 总结 有了上面的一些介绍，我们再来回答一下开篇中提到的问题： 初始化渲染的时候，会从实例上获取状态 msg 的值，获取的优先级是： setupState &gt; data &gt; props &gt; ctx。 setupState 就是 setup 函数执行后返回的状态值，所以这里渲染的是： msg from setup。 点击按钮的时候，会更新实例上的状态，更新的优先级是： setupState &gt; data。所以会更新 setup 中的状态数据 msg。","link":"/posts/b209f95d/"},{"title":"渲染器：组件是如何完成更新的？","text":"了解了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 [setupRenderEffect]{.mark} 这个函数中。 前言 了解了数据访问代理的过程以及组件实例初始化的过程，接下来，我们将介绍组件的更新逻辑，这部分逻辑主要包含在 [setupRenderEffect]{.mark} 这个函数中。 组件更新 const setupRenderEffect = (instance, initialVNode, container,anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 初始化组件 } else { // 更新组件 } } // 创建响应式的副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions) } 在前面的小节中，我们说完了关于 [mounted]{.mark} 的流程。接下来我们将着重来看一下组件更新的逻辑： const setupRenderEffect = (instance, initialVNode, container,anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 初始化组件 } else { // 更新组件 let { next, vnode } = instance // 如果有 next 的话说明需要更新组件的数组（props, slot 等） if (next) { next.el = vnode.el // 更新组件实例信息 updateComponentPreRender(instance, next, optimized) } else { next = vnode } // 获取新的子树 vnode const nextTree = renderComponentRoot(instance) // 获取旧的子树 vnode const prevTree = instance.subTree // 更新子树 vnode instance.subTree = nextTree // patch 新老子树的 vnode patch( prevTree, nextTree, // 处理 teleport 相关 hostParentNode(prevTree.el), // 处理 fragment 相关 getNextHostNode(prevTree), instance, parentSuspense, isSVG) // 缓存更新后的 DOM 节点 next.el = nextTree.el } } // 创建响应式的副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions) } 这里的核心流程是通过 [next]{.mark} 来判断当前是否需要更新 [vnode]{.mark} 的节点信息，然后渲染出新的子树 [nextTree]{.mark}，再进行比对新旧子树并找出需要更新的点，进行 [DOM]{.mark} 更新。我们先来看一下 [patch]{.mark} 的更新流程： function patch(n1, n2, container = null, anchor = null,parentComponent = null) { // 对于类型不同的新老节点，直接进行卸载 if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) { anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null } // 基于 n2 的类型来判断 // 因为 n2 是新的 vnode const { type, shapeFlag } = n2; switch (type) { case Text: processText(n1, n2, container); break; // 其中还有几个类型比如： static fragment comment case Fragment: processFragment(n1, n2, container); break; default: // 这里就基于 shapeFlag 来处理 if (shapeFlag &amp; ShapeFlags.ELEMENT) { processElement(n1, n2, container, anchor, parentComponent); } else if (shapeFlag &amp; ShapeFlags.STATEFUL_COMPONENT) { processComponent(n1, n2, container, parentComponent); } } } 首先判断当 [n1]{.mark} 存在，即存在老节点，但新节点和老节点不是同类型的节点情况，那么执行销毁老节点，新增新节点。那么 [Vue]{.mark} 如何判断是否是不同类型的节点呢？答案就在 [isSameVNodeType]{.mark} 函数中： export function isSameVNodeType(n1, n2) { // 新老节点的 type 和 key 都相同 return n1.type === n2.type &amp;&amp; n1.key === n2.key } 这里比如从 [div]{.mark} 变成了 [p]{.mark} 标签，那么 [isSameVNodeType]{.mark} 就会是个 [false]{.mark}。 如果当新老节点是同类型的节点，则会根据 [shapeFlag]{.mark}不同走到不同的逻辑，如果是普通元素更新，那么就会走到 [processElement]{.mark} 的逻辑中；如果是组件更新，则会走到 [processComponent]{.mark} 中。 接下来分别看看这两种更新机制有什么不同。 processElement 这里我们也着重看一下 [processElement]{.mark} 的更新流程： const processElement = (n1, n2, container, anchor,parentComponent, parentSuspense, isSVG, optimized) =&gt; { isSVG = isSVG || n2.type === 'svg' if (n1 == null) { // 初始化的过程 } else { // 更新的过程 patchElement(n1, n2, parentComponent, parentSuspense, isSVG, optimized) } } [processElement]{.mark} 更新逻辑调用 [patchElement]{.mark} 函数： const patchElement = (n1, n2, parentComponent, parentSuspense,isSVG, optimized) =&gt; { const el = (n2.el = n1.el) let { patchFlag, dynamicChildren, dirs } = n2 // ... // 旧节点的 props const oldProps = (n1 &amp;&amp; n1.props) || EMPTY_OBJ // 新节点的 props const newProps = n2.props || EMPTY_OBJ // 对比 props 并更新 patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense,isSVG) // 先省略 dynamicChildren 的逻辑，后续介绍... // 全量比对子节点更新 patchChildren(n1, n2, el, null, parentComponent, parentSuspense,areChildrenSVG) } 可以看到普通元素的更新主要做的就是先更新 [props]{.mark} ，当 [props]{.mark} 更新完成后，然后再统一更新子节点。关于如何进行 [patchProps]{.mark} 做节点的属性更新不是本小节的重点，这里先跳过。 这里省略了对 [dynamicChildren]{.mark} 存在时，执行 [patchBlockChildren]{.mark} 的优化 [diff]{.mark} 过程，我们直接先看全量 [diff]{.mark} 也就是 [patchChildren]{.mark} 函数。关于 [patchBlockChildren]{.mark} 我们将在编译过程中的优化小节中进行详细介绍 接着来看 [patchChildren]{.mark} 更新子节点的函数： const patchChildren = (n1, n2, container, anchor,parentComponent, parentSuspense, isSVG, optimized = false) =&gt; { // c1 代表旧节点的子节点元素 const c1 = n1 &amp;&amp; n1.children const prevShapeFlag = n1 ? n1.shapeFlag : 0 // c2 代表新节点的子节点元素 const c2 = n2.children const { patchFlag, shapeFlag } = n2 // 新节点是文本 if (shapeFlag &amp; ShapeFlags.TEXT_CHILDREN) { // 旧节点是数组 if (prevShapeFlag &amp; ARRAY_CHILDREN) { // 卸载旧节点 unmountChildren(c1, parentComponent, parentSuspense) } if (c2 !== c1) { // 新旧节点都是文本，但内容不一样，则替换 hostSetElementText(container, c2) } } else { // 新节点不为文本 // 旧节点是数组 if (prevShapeFlag &amp; ARRAY_CHILDREN) { // 新节点也是数组 if (shapeFlag &amp; ARRAY_CHILDREN) { // 进行新旧节点的 diff patchKeyedChildren(c1, c2, container, anchor, parentComponent,parentSuspense, isSVG, optimized) } else { // 卸载旧节点 unmountChildren(c1, parentComponent, parentSuspense, true) } } else { // 新节点不为文本 // 旧节点不是数组 // 旧节点是文本 if (prevShapeFlag &amp; TEXT_CHILDREN) { // 则把它清空 hostSetElementText(container, '') } // 新节点是数组 if (shapeFlag &amp; ARRAY_CHILDREN) { // 挂载新节点 mountChildren(c2, container, anchor, parentComponent, parentSuspense,isSVG, optimized) } } } } 对于子节点来说，节点类型只会有三种可能，分别是：文本节点、数组节点、空节点。所以这个方法里所有的 [ifelse]{.mark} 分支就是在考虑新旧节点可能的全部情况，并进行相应的处理。这里流程分支有点多，画个图大家就明白在做啥了： 其中新旧节点都是数组的情况涉及到我们平常所说的 [diff]{.mark} 算法，会放到后面专门去解析。 看完处理[DOM]{.mark}元素的情况，接下来看处理[vue]{.mark}组件。 processComponent const processComponent = (n1, n2, container, anchor,parentComponent, parentSuspense, isSVG, optimized) =&gt; { if (n1 == null) { // 初始化的过程 } else { // 更新的过程 updateComponent(n1, n2, parentComponent, optimized) } } [processComponent]{.mark} 更新逻辑调用 [updateComponent]{.mark} 函数： const updateComponent = (n1, n2, optimized) =&gt; { const instance = (n2.component = n1.component)! // 根据新老节点判断是否需要更新子组件 if (shouldUpdateComponent(n1, n2, optimized)) { //... // 如果需要更新，则将新节点 vnode 赋值给 next instance.next = n2 // 执行前面定义在 instance 上的 update 函数。 instance.update() } else { // 如果不需要更新，则将就节点的内容更新到新节点上即可 n2.el = n1.el instance.vnode = n2 } } [updateComponent]{.mark} 函数首先通过 [shouldUpdateComponent]{.mark} 函数来判断当前是否需要更新。因为有些 [VNode]{.mark} 值的变化并不需要立即显示更新子组件，举个例子： &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;Child /&gt; &lt;/template&gt; &lt;script setup&gt; import { ref } from 'vue' const msg = ref('hello') &lt;script&gt; 因为子组件不依赖父组件的状态数据，所以子组件是不需要更新的。这也从侧面反映出 [Vue]{.mark} 的更新不仅是组件层面的细粒度更新，更在源码层面帮我们处理了一些不必要的子节点更新！ 最后执行的 [instance.update]{.mark}，这个函数其实就是在 [setupRenderEffect]{.mark} 内创建的。最终子组件的更新还会走一遍自己副作用函数的渲染，然后 [patch]{.mark} 子组件的子模板 [DOM]{.mark}，接上上面的流程。 回过头来再看这里我们多次出现了 [next]{.mark} 变量。为了更好地理解整体的流程，我们再来看一个 [demo]{.mark}： &lt;template&gt; &lt;div&gt; hello world &lt;hello :msg=&quot;msg&quot; /&gt; &lt;button @click=&quot;changeMsg&quot;&gt;修改 msg&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { setup () { const msg = ref('你好') function changeMsg() { msg.value = '你好啊，我变了' } return { msg, changeMsg } } } &lt;/script&gt; // hello.vue &lt;template&gt; &lt;div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: String } } &lt;/script&gt; 这里有个 [App.vue]{.mark} 组件，内部有一个 [hello]{.mark} 组件，我们来从头再捋一下整体的流程，就清楚了 [next]{.mark} 的作用。 当点击 修改 msg 后， App 组件自身的数据变化，导致 App 组件进入 update 逻辑，此时是没有 next 的，接下来渲染新的子组件 vnode，得到真实的模板 vnode nextTree，用新旧 subTree进行 patch。 此时 patch的元素类型是 div，进入更新普通元素的流程，先更新 props，再更新子节点，当前 div下的子节点有 Hello组件时，进入组件的的更新流程。 在更新 Hello 组件时，根据 updateComponent 函数执行的逻辑，会先将 Hello组件 instance.next 赋值为最新的子组件 vnode，之后再主动调用 instance.update 进入上面的副作用渲染函数，这次的实例是 Hello 组件自身的渲染，且 next 存在值。 当 [next]{.mark} 存在时，会执行 [updateComponentPreRender]{.mark} 函数： const updateComponentPreRender = (instance, nextVNode,optimized) =&gt; { // 新节点 vnode.component 赋值为 instance nextVNode.component = instance // 获取老节点的 props const prevProps = instance.vnode.props // 为 instance.vnode 赋值为新的组件 vnode instance.vnode = nextVNode instance.next = null // 更新 props updateProps(instance, nextVNode.props, prevProps, optimized) // 更新 slots updateSlots(instance, nextVNode.children) } [updateComponentPreRender]{.mark} 函数核心功能就是完成了对实例上的属性、[vnode]{.mark} 信息、[slots]{.mark} 进行更新，当后续组件渲染的时候，得到的就是最新的值。 总而言之，[next]{.mark} 就是用来标记接下来需要渲染的子组件，如果 [next]{.mark} 存在，则会进行子组件实例相关内容属性的更新操作，再进行子组件的更新流程。 总结 本节着重介绍了组件的更新逻辑，我们再补齐一下第二节中的流程图： 本文介绍了关于普通元素的简单更新过程，那关于复杂的更新过程的逻辑，也就是新老子节点都是数组的普通元素，应该如何进行更新呢？这就涉及到了 [diff]{.mark} 算法","link":"/posts/8d428288/"},{"title":"渲染器：数组子节点的 diff 算法","text":"了解了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？ 前言 了解了关于新旧子节点不同为数组的情况下的更新过程，下面将接着上节的内容继续介绍如果子节点都是数组的情况，那么更新过程会变成什么样呢？ 1. 从头比对 [Vue3]{.mark} 的 [diff]{.mark} 算法第一步就是进行新老节点从头比对的方式来判断是否是同类型的节点： const patchKeyedChildren = (c1, c2, container, parentAnchor,parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // (a b) c // (a b) d e while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[i] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) // 如果是 sameVnode 则递归执行 patch if (isSameVNodeType(n1, n2)) { patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense,isSVG, optimized) } else { break } i++ } } 这里有几个变量需要说明一下： i 代表的是头部的标记位； e1 代表的是旧的子节点的尾部标记位； e2 代表的是新的子节点的尾部标记位。 从头比对就是通过不断移动 [i]{.mark} 这个头部标记位来判断对应的节点是否是 [sameVnode]{.mark}。如果是，则进行递归 [patch]{.mark} 操作，递归 [patch]{.mark} 就是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入从尾比对流程。 2. 从尾比对 const patchKeyedChildren = (c1, c2, container, parentAnchor,parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // ... // 从尾部开始比对 // a (b c) // d e (b c) while (i &lt;= e1 &amp;&amp; i &lt;= e2) { const n1 = c1[e1] const n2 = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) // 如果是 sameVnode 则递归执行 patch if (isSameVNodeType(n1, n2)) { patch(n1, n2, container, parentAnchor, parentComponent, parentSuspense,isSVG, optimized) } else { break } e1-- e2-- } } 从尾比对就是通过不断移动新旧节点 [e1]{.mark} 和 [e2]{.mark} 的尾部指针来判断对应的节点是否是 [sameVnode]{.mark}。如果是则进行递归 [patch]{.mark} 操作，递归 [patch]{.mark} 也是继续进入到我们上一小节的内容。如果不满足条件，则退出头部比对，进入后续流程。 3. 新增节点 假设我们有这样一个旧列表： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;/ul&gt; 新列表的变更是在中间插入了一个新节点： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;/ul&gt; 那么先进入第一步头部比对流程： 第一步执行时，会完成对 [a]{.mark} 和 [b]{.mark} 头部这 2个节点进行 [patch]{.mark}。当 [i =2]{.mark} 时，由于此时的 [c]{.mark} 和 [e]{.mark} 节点的 [key]{.mark} 不一样，所以退出了头部比对流程，进入尾部比对： { 第二步执行时，会完成对 [c]{.mark} 和 [d]{.mark} 尾部这 2个节点进行 [patch]{.mark}。当 [e1 = 1]{.mark} 时，由于[i &gt;e1]{.mark}，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点多了个 [e]{.mark} 节点的情况，所以我们需要添加多余的剩余节点： const patchKeyedChildren = (c1, c2, container,parentAnchor, parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始必须 // ... // 从尾部开始比对 // ... // 如果有多余的新节点，则执行新增逻辑 if (i &gt; e1) { if (i &lt;= e2) { const nextPos = e2 + 1 const anchor = nextPos &lt; l2 ? c2[nextPos].el : parentAnchor while (i &lt;= e2) { // 新增新节点 patch(null, c2[i], container, anchor, parentComponent, parentSuspense,isSVG) i++ } } } } 4. 删除节点 类比新增节点的情况，假设我们有这样一个旧列表： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;/ul&gt; 新列表的变更是在中间删除了一个旧节点： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;/ul&gt; 那么先进入第一步头部比对流程： 第一步执行时，会完成对 [a]{.mark} 和 [b]{.mark} 头部这 2个节点进行 [patch]{.mark}。当 [i =2]{.mark} 时，由于此时的 [e]{.mark} 和 [c]{.mark} 节点的 [key]{.mark} 不一样，所以退出了头部比对流程，进入尾部比对： 第二步执行时，会完成对 [c]{.mark} 和 [d]{.mark} 尾部这 2个节点进行 [patch]{.mark}。当 [e2 = 1]{.mark} 时，由于[i &gt;e2]{.mark}，所以退出了尾部比对流程。肉眼可见，此时的情况是新节点少了个 [e]{.mark} 节点的情况，所以我们需要删除节点 [e]{.mark}： const patchKeyedChildren = (c1, c2, container, parentAnchor,parentComponent, parentSuspense, isSVG, optimized) =&gt; { let i = 0 const l2 = c2.length // 旧节点的尾部标记位 let e1 = c1.length - 1 // 新节点的尾部标记位 let e2 = l2 - 1 // 从头部开始比对 // ... // 从尾部开始比对 // ... // 如果有多余的新节点，则执行新增逻辑 // ... // 如果有多余的旧节点，则执行卸载逻辑 else if (i &gt; e2) { while (i &lt;= e1) { // 卸载节点 unmount(c1[i], parentComponent, parentSuspense, true) i++ } } } 5. 未知子序列 经过步骤 1、2 的操作后如果可以直接进入步骤 3、4那是非常方便的操作了，直接进行多余删除缺少新增的操作。如果步骤 3、4的条件都不满足的情况，那么 [Vue]{.mark} 是如何处理的呢？再来看这样一个例子。 旧子节点： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;f&quot;&gt;f&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt; &lt;/ul&gt; 新子节点： &lt;ul&gt; &lt;li key=&quot;a&quot;&gt;a&lt;/li&gt; &lt;li key=&quot;b&quot;&gt;b&lt;/li&gt; &lt;li key=&quot;e&quot;&gt;e&lt;/li&gt; &lt;li key=&quot;c&quot;&gt;c&lt;/li&gt; &lt;li key=&quot;d&quot;&gt;d&lt;/li&gt; &lt;li key=&quot;i&quot;&gt;i&lt;/li&gt; &lt;li key=&quot;g&quot;&gt;g&lt;/li&gt; &lt;li key=&quot;h&quot;&gt;h&lt;/li&gt; &lt;/ul&gt; 此时经过步骤 1、2 后的结果可以表示为如下图： 这种情况，既不满足 [i &gt; e1]{.mark} 也不满足 [i &gt;e2]{.mark} 的条件，所以对于这种情况应该如何处理呢？我们知道 [DOM]{.mark} 更新的性能优劣关系大致为：[属性更新]{.mark} &gt; [位置移动]{.mark} &gt; [增删节点]{.mark}。所以，我们需要尽可能地复用老节点，做属性更新，减少移动次数和增删节点的次数。 那么上述更新策略假设有这样 2 种方式。 c 和 d 节点不动，只做 patch， e 节点 patch 后移动到 c 节点前面，删除 f 节点，然后在 d 节点后面添加 i 节点。 e 节点不动，只做 patch， c 和 d 节点 patch 后移动到 e 节点后面，删除 f 节点，然后在 d 节点后面添加 i 节点。 根据上面的性能优劣关系，我们需要尽可能多地保障最多的公共子节点位置不变，只做 [patch]{.mark} 更新。然后找出多余的节点删除，找出新的节点添加，找出有需要移动的节点移动。 当需要进行移动操作时，那么这个问题就变成了求取新旧子树上的最长公共子序列。当知道了最长公共子序列，所有的操作就可以简化为： 如果节点在新节点中，不在旧节点中，那么新增节点。 如果节点在旧节点中，不在新节点中，那么删除节点。 如果节点既在旧节点中，也在新节点中，那么更新。 如果节点需要移动，那么求取最长公共子序列后，进行最小位置移动。 接下来看看 [Vue]{.mark} 是如何实现上述能力的。 构造新老节点位置映射 keyToNewIndexMap // 旧子序列开始位置 const s1 = i // 新子序列开始位置 const s2 = i // 5.1 构建 key:index 关系索引 map const keyToNewIndexMap = new Map() for (i = s2; i &lt;= e2; i++) { const nextChild = (c2[i] = optimized ? cloneIfMounted(c2[i] as VNode) : normalizeVNode(c2[i])) if (nextChild.key != null) { keyToNewIndexMap.set(nextChild.key, i) } } 这里的新旧子节点开始位置通过 [s1]{.mark} 和 [s2]{.mark} 作为标记，然后开始进行构造新老节点位置映射，这里新节点 [key]{.mark} -&gt; [index]{.mark} 关系的索引图是保存在了 [keyToNewIndexMap]{.mark} 这样一个 [Map]{.mark} 结构中，其中的 [key]{.mark} 就是新节点的 [key]{.mark} 值，而 [value]{.mark} 则是旧节点对应的位置关系 [index]{.mark}。这一步完成后，生成的 [keyToNewIndexMap]{.mark} 结果可以表示为： keyToNewIndexMap = {e: 2, c: 3, d: 4, i: 5} 继续处理旧节点 有了上面的 [keyToNewIndexMap]{.mark} 新节点的索引图，接下来我们就需要遍历旧的节点，寻找旧节点在新节点中对应的位置信息，如果找到则做更新，找不到则移除。 // 记录新节点已更新的数目 let patched = 0 // 记录新节点还有多少个没有更新 const toBePatched = e2 - s2 + 1 // 标记是否有必要进行节点的位置移动 let moved = false // 标记是否有节点进行了位置移动 let maxNewIndexSoFar = 0 // 记录新节点在旧节点中的位置数组 const newIndexToOldIndexMap = new Array(toBePatched) // newIndexToOldIndexMap 全部置为 0 for (i = 0; i &lt; toBePatched; i++) newIndexToOldIndexMap[i] = 0 // 开始遍历旧子节点 for (i = s1; i &lt;= e1; i++) { // prevChild 代表旧节点 const prevChild = c1[i] // 还有多余的旧节点，则删除 if (patched &gt;= toBePatched) { unmount(prevChild, parentComponent, parentSuspense, true) continue } // 记录旧节点在新节点中的位置数组 let newIndex = keyToNewIndexMap.get(prevChild.key) // 如果旧节点不存在于新节点中，则删除该节点 if (newIndex === undefined) { unmount(prevChild, parentComponent, parentSuspense, true) } else { // newIndexToOldIndexMap 中元素为 0 表示着新节点不存在于旧节点中 newIndexToOldIndexMap[newIndex - s2] = i + 1 // 默认不移动的话，所有相同节点都是增序排列的 // 如果有移动，必然出现节点降序的情况 if (newIndex &gt;= maxNewIndexSoFar) { maxNewIndexSoFar = newIndex } else { moved = true } // 更新节点 patch( prevChild, c2[newIndex] as VNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) // 记录更新的数量 patched++ } } 我们简单来总结一下这一步的一些核心操作。 Step 1： 定义一个初始长度为新节点数组长度且默认值全为 0的变量 [newIndexToOldIndexMap]{.mark}，记录新节点中的元素在旧节点中的位置关系。 Step2： 遍历旧的节点数组，如果旧节点不存在于新节点中，则表示旧的节点其实是多余的节点，需要被移除。 Step3： 如果旧节点存在于新节点数组中，则将它在旧子序列中的位置信息记录到 [newIndexToOldIndexMap]{.mark} 中，同时根据 [newIndex]{.mark} 是否大于 [maxNewIndexSoFar]{.mark} 来判断是否有节点移动。 这里我们结合个例子来说明。假如旧节点信息为 [abc]{.mark}、新节点为 [cab]{.mark}，当旧节点遍历到 [c]{.mark} 节点时，此时的[newIndex]{.mark} 的值为 [0]{.mark} 而 [maxNewIndexSoFar]{.mark} 的值为 [2]{.mark}。这就意味着此时的 [c]{.mark} 节点并不是升序位于 [ab]{.mark} 节点之后的，因此需要标记为有需要移动的节点。 Step 4： 更新相同节点。 经过上面的一系列操作，我们最终得到了一个 [newIndexToOldIndexMap]{.mark} 和一个 [moved]{.mark} 两个变量，这两个变量将在下文的移动和新增节点中被使用。 我们来看一下示例处理后的结果，如下图所示： 此时 [c]{.mark}、[d]{.mark}、[e]{.mark} 因为是相同节点，所以进行 [patch]{.mark} 更新，[f]{.mark} 节点因为不存在于新的索引中，所以被删除。最后得到的 [newIndexToOldIndexMap]{.mark} 数据结构大致如下： newIndexToOldIndexMap = [5, 3, 4, 0] 而且此时的 [moved]{.mark} 也被标记为 [true]{.mark}。 移动和增加新节点 通过前面的操作，我们完成了对旧节点的移除和更新，那么接下来就是需要进行对节点的移动和新节点的增加了： // 根据 newIndexToOldIndexMap 求取最长公共子序列 const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR // 最长公共子序列尾部索引 j = increasingNewIndexSequence.length - 1 // 从尾部开始遍历 for (i = toBePatched - 1; i &gt;= 0; i--) { const nextIndex = s2 + i const nextChild = c2[nextIndex] const anchor = nextIndex + 1 &lt; l2 ? c2[nextIndex + 1].el :parentAnchor // 如果新子序列中的节点在旧子序列中不存在，则新增节点 if (newIndexToOldIndexMap[i] === 0) { patch(null, nextChild, container, anchor, parentComponent,parentSuspense, isSVG) } else if (moved) { // 如果需要移动且 // 没有最长递增子序列 // 当前的节点不在最长递增子序列中 if (j &lt; 0 || i !== increasingNewIndexSequence[j]) { move(nextChild, container, anchor, MoveType.REORDER) } else { j-- } } } Step1： 这里针对 [moved]{.mark} 是 [true]{.mark} 的情况，则会进行求取最长递增子序列的索引操作。 什么是最长递增子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。本例中，[newIndexToOldIndexMap= [5, 3, 4, 0]]{.mark} 最长递增子序列的值为 [[3, 4]]{.mark},对应到 [newIndexToOldIndexMap]{.mark} 中的索引即 [increasingNewIndexSequence= [1, 2]]{.mark}。关于具体的算法细节，我们后面再详细探讨。 Step2： 从尾部开始遍历新的子序列，在遍历的过程中，如果新子序列中的节点在旧子序列中不存在，也就是 [newIndexToOldIndexMap[i]=== 0]{.mark}，则新增节点。 Step3： 判断是否存在节点移动的情况，如果存在的话则看节点的索引是不是在最长递增子序列中，如果不在，则将它移动到锚点的前面，否则仅移动最长子序列的尾部指针。 针对上述例子中，新的子序列为 [e,c,d,i]{.mark}。最长递增子序列的索引为 [[1,2]]{.mark}。开始遍历到 [i]{.mark} 节点时，因为 [newIndexToOldIndexMap[i]=0]{.mark} 所以新增，然后遍历到 [c,d]{.mark} 节点，因为存在于最长子序列中，所以最后 [j= -1]{.mark}。当遍历到 [e]{.mark} 节点时，此时 [j =-1]{.mark} 并且 [e]{.mark} 节点不存在于最长递增子序列索引中，索引最后一步就是把节点 [e]{.mark} 进行一次移动： move(nextChild, container, anchor, MoveType.REORDER) 其中 [anchor]{.mark} 是参照物，记录着上一次更新的节点信息，也就是节点 [c]{.mark} 的信息，所以这里的意思就是将节点 [e]{.mark} 移动到节点 [c]{.mark} 前面。 至此，完成了所有节点的增、删、更新、移动的操作，此次操作结果如下： 最长递增子序列 求最长递增子序列是 [LeetCode]{.mark} 上的一道经典算法题，原题：300. 最长递增子序列。 什么是上升子序列？简单来说指的是找到一个特定的最长的子序列，并且子序列中的所有元素单调递增。 假设我们的序列为 [[5, 3, 4, 9]]{.mark} ，那么最长的递增子序列是 [[3,4]]{.mark}。 那么如何找到最长的递增子序列呢？[Vue]{.mark} 内部使用的是一套 [贪心 +二分查找]{.mark} 的算法，关于贪心和二分查找的解释如下。 贪心算法：贪心算法在每一步都做出了当时看起来最佳的选择，也就是说，它总是做出局部最优的选择，寄希望这样的选择能导致全局最优解。leetCode455. 分发饼干。 二分查找：每次的查找都是和区间的中间元素对比，将待查找的区间缩小为一半，直到找到目标元素，或者区间被缩小为0（没找到）。leetCode704. 二分查找。 那么这里我们再结合一下贪心算法的思想，在求取最长上升子序列时，对于同样长度是二的序列 [[2,3]]{.mark} 一定比 [[2,5]]{.mark} 好，因为要想让子序列尽可能地长，那么上升得尽可能慢，这样潜力更大。 所以我们可以创建一个临时数组，用来保存最长的递增子序列，如果当前遍历的元素大于临时数组中的最后一个元素（也就是临时数组的最大值）时，那么将其追加到临时数组的尾部，否则，查找临时数组，找到第一个大于该元素的数并替换它，这样就保证了临时数组上升时最慢的。因为是单调递增的序列，我们也可以在临时数组中用二分查找，降低时间复杂度。 以输入序列 [[1, 4, 5, 2, 8, 7, 6,0]]{.mark} 为例，根据上面算法的描述，我们大致可以得到如下的计算步骤： [1] [1, 4] [1, 4, 5] [1, 2, 5] [1, 2, 5, 8] [1, 2, 5, 7] [0, 2, 5, 6] 可以看到，如果单纯地按照上述算法的模式，得到的结果的长度虽然一致，但位置顺序和值并不符合预期，预期结果是 [[1,4, 5,6]]{.mark}。那么在 [Vue]{.mark} 中是如何解决这个顺序和值错乱的问题呢？ 我们一起来看看源码的实现： function getSequence (arr) { const p = arr.slice() const result = [0] let i, j, u, v, c const len = arr.length for (i = 0; i &lt; len; i++) { const arrI = arr[i] // 排除等于 0 的情况 if (arrI !== 0) { j = result[result.length - 1] // 与最后一项进行比较 if (arr[j] &lt; arrI) { // 存储在 result 更新前的最后一个索引的值 p[i] = j result.push(i) continue } u = 0 v = result.length - 1 // 二分搜索，查找比 arrI 小的节点，更新 result 的值 while (u &lt; v) { // 取整得到当前位置 c = ((u + v) / 2) | 0 if (arr[result[c]] &lt; arrI) { u = c + 1 } else { v = c } } if (arrI &lt; arr[result[u]]) { if (u &gt; 0) { // 正确的结果 p[i] = result[u - 1] } // 有可能替换会导致结果不正确，需要一个新数组 p 记录正确的结果 result[u] = i } } } u = result.length v = result[u - 1] // 回溯数组 p，找到最终的索引 while (u-- &gt; 0) { result[u] = v v = p[v] } return result } 其中 [result]{.mark} 中存储的是长度为 [i]{.mark} 的递增子序列最小末尾值的索引。[p]{.mark} 是来存储在每次更新 [result]{.mark} 前最后一个索引的值，并且它的 [key]{.mark} 是这次要更新的 [result]{.mark} 值： // 插入 p[i] = j result.push(i) // 替换 p[i] = result[u - 1] result[u] = i 对于上述的实例，我们在进行最后一步回溯数组 [p]{.mark} 之前，得到的数据机构如下： result = [ 0, 3, 2, 6 ] // =&gt; [0, 2, 5, 6] p = [1, 0, 1, 0, 2, 2, 2] 从 [result]{.mark} 最后一个元素 [6]{.mark} 对应的索引 [6]{.mark} 开始回溯，可以看到 [p[6]= 2]{.mark}，[p[2] = 1]{.mark}，[p[1] =0]{.mark}，所以通过对 [p]{.mark} 的回溯，得到最终的 [result]{.mark} 值是 [[0,1, 2, 6]]{.mark}，也就找到最长递增子序列的最终索引了。 总结 至此我们介绍完了关于 [Vue3]{.mark} 的 [diff]{.mark} 算法。","link":"/posts/16c5c5d5/"},{"title":"响应式原理：基于 Proxy 的响应式是什么样的？","text":"本文开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 [Vue3]{.mark} 中一个基于 [CompositionAPI]{.mark} 响应式应用的例子是如何编写的 前言 本文开启响应式原理的篇章，在开启这个篇章之前，我们先来了解一下 [Vue3]{.mark} 中一个基于 [CompositionAPI]{.mark} 响应式应用的例子是如何编写的： &lt;template&gt; &lt;div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { reactive, ref } from 'vue' export default { setup() { const state = reactive({ msg: 'hello world' }) const count = ref(0) const changeMsg = () =&gt; { state.msg = 'world hello' } return { state, count, changeMsg, } } } &lt;/script&gt; 此时我们通过 [reactive API]{.mark} 或者 [refAPI]{.mark} 来定义响应式对象。 对于 [reactiveAPI]{.mark} 而言，核心是用来定义集合类型的数据，比如：普通对象、数组和 [Map]{.mark}、[Set]{.mark}。 对于 [refAPI]{.mark} 而言，可以用来对 [string]{.mark}、[number]{.mark}、[boolean]{.mark} 这些原始类型数据进行响应式定义。 关于二者使用上的更多区别和差异，小伙伴们可以直接参见 [Vue3]{.mark} 官网上《响应式基础》这个章节中的介绍。对于二者的核心实现原理，其实都是依托于 [Vue3]{.mark} 的响应式基础，本小节将以 [reactiveAPI]{.mark} 作为切入点，核心分析 [Vue 3]{.mark} 的响应式原理。 Reactive 找到源码中关于 [reactive]{.mark} 部分的定义： export function reactive(target: object) { // 不需要对 readonly 的对象进行响应式 if (isReadonly(target)) { return target } return createReactiveObject( target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap ) } 这个函数核心也就是通过 [createReactiveObject]{.mark} 把我们传入的 [target]{.mark} 变成响应式的： function createReactiveObject(target, isReadonly,baseHandlers, collectionHandlers, proxyMap) { // 如果目标不是对象，则直接返回 if (!isObject(target)) { return target } // 已经是一个响应式对象了，也直接返回 if ( target[ReactiveFlags.RAW] &amp;&amp; !(isReadonly &amp;&amp; target[ReactiveFlags.IS_REACTIVE]) ) { return target } // proxyMap 中已经存入过 target，直接返回 const existingProxy = proxyMap.get(target) if (existingProxy) { return existingProxy } // 只有特定类型的值才能被 observe. const targetType = getTargetType(target) if (targetType === TargetType.INVALID) { return target } // 通过 proxy 来构造一个响应式对象 const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) // 缓存 target proxy proxyMap.set(target, proxy) return proxy } 上述整个核心流程就是首先经过一系列判断，判断符合要求的 [target]{.mark} 才能被响应式，整理的判断包括了[target]{.mark} 的类型、是否是响应式的、是否已经被定义过了，以及是否是符合要求的类型这些步骤，最后执行的是 [newProxy()]{.mark} 这样的一个响应式代理 [API]{.mark}。一起来看看这个 [API]{.mark} 的实现： const proxy = new Proxy( target, targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers ) [Proxy]{.mark} 根据 [targetType]{.mark} 来确定执行的是 [collectionHandlers]{.mark} 还是 [baseHandlers]{.mark}。那 [targetType]{.mark} 是什么时候确定的呢？可以看一下： const targetType = getTargetType(target) function getTargetType(value) { return value[ReactiveFlags.SKIP] || !Object.isExtensible(value) ? TargetType.INVALID : targetTypeMap(toRawType(value)) } export const toRawType = (value) =&gt; { // toTypeString 转换成字符串的方式，比如 &quot;[object RawType]&quot; return toTypeString(value).slice(8, -1) } function targetTypeMap(rawType) { switch (rawType) { case 'Object': case 'Array': return TargetType.COMMON case 'Map': case 'Set': case 'WeakMap': case 'WeakSet': return TargetType.COLLECTION default: return TargetType.INVALID } } 因为 [target]{.mark} 传入进来的是一个 [Object]{.mark}，所以 [toRawType(value)]{.mark} 得到的值是 [Object]{.mark}。所以这里的 [targetType]{.mark} 的值等于 [TargetType.COMMON]{.mark} 也就是执行了 [baseHandlers]{.mark} 。而当我们的 [reactive(target)]{.mark} 中的 [target]{.mark} 是个 [WeakMap]{.mark} 或者 [WeakSet]{.mark} 时，那么执行的就是 [collectionHandlers]{.mark} 了。 接下来看一下 [baseHandlers]{.mark} 的实现： export const mutableHandlers = { get, set, deleteProperty, has, ownKeys } 这里就是 [Proxy]{.mark} 中的定义 [handler]{.mark} 的一些属性。 get：属性读取操作的捕捉器。 set：属性设置操作的捕捉器。 deleteProperty：delete 操作符的捕捉器。 has：in 操作符的捕捉器。 ownKeys：Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。 而关于响应式核心的部分就在 [set]{.mark} 和 [get]{.mark} 中，我们一起来看一下二者的定义实现。 1. get 其中 [get]{.mark} 的实现： const get = /*#__PURE__*/ createGetter() 可以看到核心其实通过 [createGetter]{.mark} 来实现的： function createGetter(isReadonly = false, shallow = false) { return function get(target: Target, key: string | symbol, receiver:object) { // 对 ReactiveFlags 的处理部分 if (key === ReactiveFlags.IS_REACTIVE) { return !isReadonly } else if (key === ReactiveFlags.IS_READONLY) { return isReadonly } else if (key === ReactiveFlags.IS_SHALLOW) { return shallow } else if ( key === ReactiveFlags.RAW &amp;&amp; receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap ).get(target) ) { return target } const targetIsArray = isArray(target) if (!isReadonly) { // 数组的特殊方法处理 if (targetIsArray &amp;&amp; hasOwn(arrayInstrumentations, key)) { return Reflect.get(arrayInstrumentations, key, receiver) } // 对象 hasOwnProperty 方法处理 if (key === 'hasOwnProperty') { return hasOwnProperty } } // 取值 const res = Reflect.get(target, key, receiver) // Symbol Key 不做依赖收集 if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) { return res } // 进行依赖收集 if (!isReadonly) { track(target, TrackOpTypes.GET, key) } // 如果是浅层响应，那么直接返回，不需要递归了 if (shallow) { return res } if (isRef(res)) { // 跳过数组、整数 key 的展开 return targetIsArray &amp;&amp; isIntegerKey(key) ? res : res.value } if (isObject(res)) { // 如果 isReadonly 是 true，那么直接返回 readonly(res) // 如果 res 是个对象或者数组类型，则递归执行 reactive 函数把 res变成响应式 return isReadonly ? readonly(res) : reactive(res) } return res } } 因为调用 [createGetter]{.mark} 时，默认参数 [isReadonly =false]{.mark}，所以这里可以先忽略 [isReadonly]{.mark} 的部分。整体而言，该函数还是比较通俗易懂的，首先对 [key]{.mark} 属于 [ReactiveFlags]{.mark} 的部分做了特殊处理，这也是为什么在 [createReactiveObject]{.mark} 函数中判断响应式对象是否存在 [ReactiveFlags.RAW]{.mark} 属性，如果存在就返回这个响应式对象本身。 然后当我们的 [target]{.mark} 是数组，且 [key]{.mark} 值存在 [arrayInstrumentations]{.mark} 中时，返回 [arrayInstrumentations]{.mark} 中对应的 [key]{.mark} 值。再来看看 [arrayInstrumentations]{.mark} 是个什么： const arrayInstrumentations = createArrayInstrumentations() function createArrayInstrumentations() { const instrumentations = {}; (['includes', 'indexOf', 'lastIndexOf']).forEach(key =&gt; { instrumentations[key] = function (this, ...args) { // toRaw 可以把响应式对象转成原始数据 const arr = toRaw(this) for (let i = 0, l = this.length; i &lt; l; i++) { // 对数组的每一项进行依赖收集 track(arr, TrackOpTypes.GET, i + '') } // 先尝试用参数本身，可能是响应式数据 const res = arr[key](...args) if (res === -1 || res === false) { // 如果失败，再尝试把参数转成原始数据 return arr[key](...args.map(toRaw)) } else { return res } } }) // instrument length-altering mutation methods to avoid length beingtracked // which leads to infinite loops in some cases (#2137) ;(['push', 'pop', 'shift', 'unshift', 'splice'] asconst).forEach(key =&gt; { instrumentations[key] = function (this: unknown[], ...args:unknown[]) { pauseTracking() const res = (toRaw(this) as any)[key].apply(this, args) resetTracking() return res } }) return instrumentations } 当[reactive]{.mark}函数传入数组时，[get]{.mark}捕获器会先在[arrayInstrumentations]{.mark}对象上查找，如果找不到，再在代理对象[target]{.mark}上查找。[arrayInstrumentations]{.mark}对象会重写两类函数，一类是查询类函数: [includes]{.mark}、 [indexOf]{.mark}、 [lastIndexOf]{.mark}，代表对数组的读取操作。在这些函数中会执行[track]{.mark}函数，对数组上的索引和[length]{.mark}属性进行追踪。 一类是修改类函数[push]{.mark}、 [pop]{.mark}、 [shift]{.mark}、 [unshift]{.mark}、 [splice]{.mark}，代表对数组的修改操作，在这些函数中暂停了全局的追踪功能，防止某些情况下导致死循环。关于这里的一些说明也可以参见 Vueissue。 再回过头看 [createGetter]{.mark} 中，接下来的操作就是通过 [track(target,TrackOpTypes.GET,key)]{.mark} 进行依赖收集，我们再来一起看一下 [track]{.mark} 的实现： // 是否应该收集依赖 let shouldTrack = true // 当前激活的 effect let activeEffect // 存放所有 reactive 传入的 receiver 容器 const targetMap = new WeakMap() export function track(target, type, key) { if (shouldTrack &amp;&amp; activeEffect) { let depsMap = targetMap.get(target) if (!depsMap) { targetMap.set(target, (depsMap = new Map())) } let dep = depsMap.get(key) if (!dep) { depsMap.set(key, (dep = createDep())) } trackEffects(dep) } } export function trackEffects( dep, debuggerEventExtraInfo ) { // ... if (shouldTrack) { // 把 activeEffect 添加到 dep 中 dep.add(activeEffect!) activeEffect!.deps.push(dep) } } 上面函数有点绕，其实核心就是在生成一个数据结构，什么样的数据结构呢？我们来画个图看看： 我们创建了全局的 [targetMap]{.mark} ，它的键是 [target]{.mark}，值是 [depsMap]{.mark}；这个 [depsMap]{.mark} 的键是 [target]{.mark} 的 [key]{.mark}，值是 [dep]{.mark} 集合，[dep]{.mark} 集合中存储的是依赖的副作用函数 [effect]{.mark}。 另外，关于 [trackEffects]{.mark} 的实现细节，我们后面的小节再详细介绍。 注意到 [Proxy]{.mark} 在访问对象属性时才递归执行劫持对象属性，相比 [Object.defineProperty]{.mark} 在定义时就遍历把所有层级的对象设置成响应式而言，在性能上有所提升。 2. set 上面说完了 [get]{.mark} 的流程，我们了解了依赖收集后的数据结构存储在了 [targetMap]{.mark} 中，接下来我们接着看 [set]{.mark} 的过程： const set = /*#__PURE__*/ createSetter() 可以看到核心其实通过 [createSetter]{.mark} 来实现的： function createSetter(shallow = false) { return function set(target, key, value, receiver) { let oldValue = target[key] // 不是浅层响应式，这里默认是 false if (!shallow) { // 不是浅层响应式对象 if (!isShallow(value) &amp;&amp; !isReadonly(value)) { oldValue = toRaw(oldValue) value = toRaw(value) } // ... } else { // 在浅模式中，对象被设置为原始值，而不管是否是响应式 } const hadKey = isArray(target) &amp;&amp; isIntegerKey(key) ? Number(key) &lt; target.length : hasOwn(target, key) const result = Reflect.set(target, key, value, receiver) // 如果目标的原型链也是一个 proxy，通过 Reflect.set修改原型链上的属性会再次触发 setter，这种情况下就没必要触发两次 trigger了 if (target === toRaw(receiver)) { if (!hadKey) { trigger(target, TriggerOpTypes.ADD, key, value) } else if (hasChanged(value, oldValue)) { trigger(target, TriggerOpTypes.SET, key, value, oldValue) } } return result } } 可以看到 [set]{.mark} 的核心逻辑是先根据是否是浅层响应式来确定原始值和新值，这里默认不是浅层的响应式，所以会先把原始值和新值进行 [toRaw]{.mark} 转换，然后通过 [Reflect.set]{.mark} 设置值，最后通过 [trigger]{.mark} 函数派发通知，并依据 [key]{.mark} 是否存在于 [target]{.mark} 上来确定通知类型是 [add]{.mark}（新增）还是 [set]{.mark}（修改）。 接下来核心就是 [trigger]{.mark} 的逻辑，是如何实现触发响应的: export functiontrigger(target,type,key,newValue,oldValue,oldTarget) { const depsMap = targetMap.get(target) if (!depsMap) { return } let deps: (Dep | undefined)[] = [] if (type === TriggerOpTypes.CLEAR) { deps = [...depsMap.values()] } else if (key === 'length' &amp;&amp; isArray(target)) { depsMap.forEach((dep, key) =&gt; { if (key === 'length' || key &gt;= toNumber(newValue)) { deps.push(dep) } }) } else { if (key !== void 0) { deps.push(depsMap.get(key)) } switch (type) { case TriggerOpTypes.ADD: if (!isArray(target)) { deps.push(depsMap.get(ITERATE_KEY)) if (isMap(target)) { deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)) } } else if (isIntegerKey(key)) { deps.push(depsMap.get('length')) } break case TriggerOpTypes.DELETE: if (!isArray(target)) { deps.push(depsMap.get(ITERATE_KEY)) if (isMap(target)) { deps.push(depsMap.get(MAP_KEY_ITERATE_KEY)) } } break case TriggerOpTypes.SET: if (isMap(target)) { deps.push(depsMap.get(ITERATE_KEY)) } break } } if (deps.length === 1) { if (deps[0]) { triggerEffects(deps[0]) } } else { const effects: ReactiveEffect[] = [] for (const dep of deps) { if (dep) { effects.push(...dep) } } triggerEffects(createDep(effects)) } } 内容有点多，看起来有点头大，我们来简化一下： export function trigger(target, type, key) { const dep = targetMap.get(target) dep.get(key).forEach(effect =&gt; effect.run()) } 核心其实就是通过 [target]{.mark} 找到 [targetMap]{.mark} 中的 [dep]{.mark}，再根据 [key]{.mark} 来找到所有的副作用函数 [effect]{.mark} 遍历执行。副作用函数就是上面 [get]{.mark} 收集起来的。 这里有个有意思的地方是对数组的操作监听，我们来看一段代码： const state = reactive([]); effect(() =&gt; { console.log(`state: ${state[1]}`) }); // 不会触发 effect state.push(0); // 触发 effect state.push(1); 上面的 [demo]{.mark} 中，我们第一次访问了 [state[1]]{.mark}，所以，对 [state[1]]{.mark} 进行了依赖收集，而第一次的 [state.push(0)]{.mark} 设置的是 [state]{.mark} 的第 [0]{.mark} 个元素，所以不会触发响应式更新。而第二次的 [push]{.mark} 触发了对 [state[1]]{.mark} 的更新。这看起来很合理，没啥问题。那么我们再来看另外一个示例： // 响应式数据 const state = reactive([]) // 观测变化 effect(() =&gt; console.log('state map: ', state.map(item =&gt; item)) state.push(1) 按照常理来说，[state.map]{.mark} 由于 [state]{.mark} 是个空数组，所以理论上不会对数组的每一项进行访问，所以 [state.push(1)]{.mark} 理论上也不会触发 [effect]{.mark}。但实际上是会的，为什么呢？我们再来看一下一个 [proxy]{.mark} 的 [demo]{.mark}： const raw = [] const arr = new Proxy(raw, { get(target, key) { console.log('get', key) return Reflect.get(target, key) }, set(target, key, value) { console.log('set', key) return Reflect.set(target, key, value) } }) arr.map(v =&gt; v) 可以看到打印的内容如下： get map get length get constructor 可以看到 [map]{.mark} 函数的操作，会触发对数组的 [length]{.mark} 访问！这就有意思了，当访问数组 [length]{.mark} 的时候，我们进行了对 [state]{.mark} 的依赖收集，而数组的 [push]{.mark} 操作也会改变 [length]{.mark} 的长度，如果我们对 [length]{.mark} 做监听，那么此时便会触发 [effect]{.mark}！而 [Vue]{.mark} 也是这么做的，也就是这段代码： deps.push(depsMap.get('length')) 同理，对于 [for in, forEach, map... ]{.mark}都会触发 [length]{.mark} 的依赖收集，从而 [pop, push,shift...]{.mark} 等等操作都会触发响应式更新！ 另外，除了数组，对象的 [Object.keys]{.mark} , [for ... of...]{.mark} 等等对象遍历操作都会触发响应式的依赖收集，这是因为 [Vue]{.mark} 在定义 [Proxy]{.mark} 的时候，定义了 [ownKeys]{.mark} 这个函数： function ownKeys(target) { track(target, TrackOpTypes.ITERATE, isArray(target) ? 'length' :ITERATE_KEY) return Reflect.ownKeys(target) } [ownKeys]{.mark} 函数内部执行了 [track]{.mark} 进行了对 [Object]{.mark} 的 [ITERATE_KEY]{.mark} 的依赖收集。而在 [setter]{.mark} 的时候，则对 [ITERATE_KEY]{.mark} 进行了响应式触发： deps.push(depsMap.get(ITERATE_KEY)) 总结 至此，我们讲完了对响应式的依赖收集和触发过程，但有个概览我们没有说清楚，那就是 [effect]{.mark} 到底是什么，以及是如何产生的被收集到 [dep]{.mark} 当中的。下一节我们将具体介绍。 课外知识 这里细心的小伙伴，可能会注意到在上面的源码中出现了一个有意思的标识符 [/*#__PURE__*/]{.mark}。要说这个东西，那就需要说到和这玩意相关的 [Tree-Shaking]{.mark} 副作用了。我们知道 [Tree-Shaking]{.mark} 可以删除一些 [DC（deadcode）]{.mark} 代码。但是对于一些有副作用的函数代码，却是无法进行很好的识别和删除，举个例子： foo() function foo(obj) { obj?.a } 上述代码中，[foo]{.mark} 函数本身是没有任何意义的，仅仅是对对象 [obj]{.mark} 进行了属性 [a]{.mark} 的读取操作，但是 [Tree-Shaking]{.mark} 是无法删除该函数的，因为上述的属性读取操作可能会产生副作用，因为 [obj]{.mark} 可能是一个响应式对象，我们可能对 [obj]{.mark} 定了一个 [getter]{.mark} 在 [getter]{.mark} 中触发了很多不可预期的操作。 如果我们确认 [foo]{.mark} 函数是一个不会有副作用的纯净的函数，那么这个时候 [/*#__PURE__*/]{.mark} 就派上用场了，其作用就是告诉打包器，对于 [foo]{.mark} 函数的调用不会产生副作用，你可以放心地对其进行 [Tree-Shaking]{.mark}。 另外，值得一提的是，在 [Vue3]{.mark} 源码中，包含了大量的 [/*#__PURE__*/]{.mark} 标识符，可见 [Vue3]{.mark} 对源码体积的控制是多么的用心！","link":"/posts/bf54f4c/"},{"title":"响应式原理：副作用函数探秘","text":"我们说到了 [Reactive]{.mark} 会在 [proxygetter]{.mark} 的时候收集 [effect]{.mark} 依赖，在 [proxysetter]{.mark} 的时候触发 [effect]{.mark} 的执行。那么 [effect]{.mark} 副作用函数到底是个什么？以及是如何被收集起来的呢？ 前言 我们说到了 [Reactive]{.mark} 会在 [proxygetter]{.mark} 的时候收集 [effect]{.mark} 依赖，在 [proxysetter]{.mark} 的时候触发 [effect]{.mark} 的执行。那么 [effect]{.mark} 副作用函数到底是个什么？以及是如何被收集起来的呢？ effect 找到源码中关于 [effect]{.mark} 部分的定义： export function effect (fn, options) { // 如果 fn 已经是一个 effect 函数了，则指向原始函数 if (fn.effect) { fn = fn.effect.fn } // 构造 _effect 实例 const _effect = new ReactiveEffect(fn) // options 初始化 if (options) { extend(_effect, options) if (options.scope) recordEffectScope(_effect, options.scope) } // 如有 options 或者 不是懒加载，执行 _effect.run() if (!options || !options.lazy) { _effect.run() } // 返回 _effect.run const runner = _effect.run.bind(_effect) runner.effect = _effect return runner } 这个 [effect]{.mark} 函数内部核心是通过 [ReactiveEffect]{.mark} 类创建了一个 [_effect]{.mark} 实例，从代码来看，[_effect]{.mark} 上包含了一个 [run]{.mark} 函数。默认 [effect]{.mark} 是没有传入 [options]{.mark} 参数的，所以这里直接执行了 [_effect.run()]{.mark}。我们知道，[fn]{.mark} 函数是在 [effect]{.mark} 函数中的一个入参，比如： const state = reactive({a: 1}) effect(() =&gt; console.log(state.a)) 根据上一小节，我们知道因为这里我们访问了 [state.a]{.mark} 所以收集了副作用函数，但是需要知道的是这里的 [effect]{.mark} 传入的是一个 [fn]{.mark}，所以要想访问 [state.a]{.mark} 那这个 [fn]{.mark} 必须要执行才可以。那是在哪里执行的呢？接下来看一下 [ReactiveEffect]{.mark} 的实现： // 用于记录位于响应上下文中的effect嵌套层次数 let effectTrackDepth = 0 // 二进制位，每一位用于标识当前effect嵌套层级的依赖收集的启用状态 export left trackOpBit = 1 // 表示最大标记的位数 const maxMarkerBits = 30 // 当前活跃的 effect let activeEffect; export class ReactiveEffect { // 用于标识副作用函数是否位于响应式上下文中被执行 active = true // 副作用函数持有它所在的所有依赖集合的引用，用于从这些依赖集合删除自身 deps = [] // 指针为，用于嵌套 effect 执行后动态切换 activeEffect parent = undefined // ... run() { // 若当前 ReactiveEffect 对象脱离响应式上下文 // 那么其对应的副作用函数被执行时不会再收集依赖 if (!this.active) { return this.fn() } // 缓存是否需要收集依赖 let lastShouldTrack = shouldTrack try { // 保存上一个 activeEffect 到当前的 parent 上 this.parent = activeEffect // activeEffect 指向当前的 effect activeEffect = this // shouldTrack 置成 true shouldTrack = true // 左移操作符 &lt;&lt; 将第一个操作数向左移动指定位数 // 左边超出的位数将会被清除，右边将会补零。 // trackOpBit 是基于 1 左移 effectTrackDepth 位 trackOpBit = 1 &lt;&lt; ++effectTrackDepth // 如果未超过最大嵌套层数，则执行 initDepMarkers if (effectTrackDepth &lt;= maxMarkerBits) { initDepMarkers(this) } else { cleanupEffect(this) } // 这里执行了 fn return this.fn() } finally { if (effectTrackDepth &lt;= maxMarkerBits) { // 用于对曾经跟踪过，但本次副作用函数执行时没有跟踪的依赖采取删除操作。 // 新跟踪的 和 本轮跟踪过的都会被保留 finalizeDepMarkers(this) } // &lt;&lt; --effectTrackDepth 右移动 effectTrackDepth 位 trackOpBit = 1 &lt;&lt; --effectTrackDepth // 返回上个 activeEffect activeEffect = this.parent // 返回上个 shouldTrack shouldTrack = lastShouldTrack // 情况本次的 parent 指向 this.parent = undefined } } } 大致看一眼，我们可以看到在 [ReactiveEffect]{.mark} 中是执行了 [this.fn()]{.mark} 的，这也就解释了 [effect]{.mark} 中的回调函数 [fn]{.mark} 是在这里被调用的。接下来详细研究一下这个 [ReactiveEffect]{.mark}。 但这段代码看起来不是很长，但涉及了好几个概念，我们来一个个看。 1. parent 的作用 为什么 [ReactiveEffect]{.mark} 要设计一个 [parent]{.mark} 这样一个看似没啥用的变量指针来存储上一次的 [activeEffect]{.mark} 呢？如果改成下面这样不是更简单吗？ run() { if (!this.active) { return this.fn(); } // 初始化 shouldTrack = true; activeEffect = this; const result = this.fn(); // 重置 shouldTrack = false; return result; } 其实对于下面这样的代码： const state = reactive({a: 1}) effect(() =&gt; console.log(state.a)) state.a++ [effect]{.mark} 函数内调用 [ReactiveEffect]{.mark} 实例的 [run]{.mark} 函数。[run]{.mark} 函数执行的时候，把 [activeEffect]{.mark} 指向 [this]{.mark}。然后执行 [effect]{.mark} 传入的 [fn]{.mark} 函数，函数在执行的时候访问了 [state.a]{.mark} 触发了 [getter]{.mark} 钩子。回顾一下上一节的内容，[getter]{.mark} 的时候有触发添加 [activeEffect]{.mark} 的功能： // 把 activeEffect 添加到 dep 中 dep.add(activeEffect!) 而 [activeEffect]{.mark} 正是这里的 [this]{.mark}。当执行 [state.a++]{.mark} 时，访问了[state.a]{.mark} 的 [setter]{.mark}。上一节也说了，[setter]{.mark} 的执行会调用 [effect.run]{.mark} 函数： // triggerEffects effect.run(); 所以又会执行 [fn]{.mark}。 到这里看似很完美，那么我们再来看另外一个例子🌰： const state = reactive({ a: 1, b: 2 }); // ef1 effect(() =&gt; { // ef2 effect(() =&gt; console.log(`b: ${state.b}`)) console.log(`a: ${state.a}`) }); state.a ++ 按照上面的逻辑，在第一次 [effect]{.mark} 执行的时候，[activeEffect =ef1]{.mark} 然后再执行内部的 [effect]{.mark}， 此时 [activeEffect =ef2]{.mark} 然后 [ef2]{.mark} 执行完成回到 [ef1]{.mark} 函数体内，此时再访问 [state.a]{.mark} 触发对 [a]{.mark} 的依赖收集，但收集到的却是 [ef2]{.mark}。那么最终打印的是： b: 2 a: 1 b: 2 很明显不符合我们的要求，我们期望的是输出： b: 2 a: 1 b: 2 a: 2 这时候 [parent]{.mark} 就排上用场了，当为 [effect]{.mark} 加上 [parent]{.mark} 属性后，我们再来捋一下整体的流程。 执行 ef1 的时候， activeEffect 指向 ef1，此时 parent 是 undefined。 执行 ef1 fn 遇到了 ef2，调用 ef2 此时 ef2 的 parent 指向 ef1， activeEffect 指向 ef2。然后执行 ef2 的 fn。 ef2 的 fn 执行的时候，访问了 state.b 依赖收集 ef2。执行完成后， activeEffect = this.parent 又把 activeEffect 指向了 ef1。 返回 ef1 的 fn 体继续执行，此时访问 state.a 依赖收集 activeEffect 为 ef1。 触发 state.a 的 setter，调用 a 的副作用 ef1，依次打印…… 到这里相信各位小伙伴已经清楚了 [parent]{.mark} 的作用了，那就是通过 [parent]{.mark} 这个标记，来回切换 [activeEffect]{.mark} 的指向，从而完成对嵌套 [effect]{.mark} 的正确的依赖收集。 2. 依赖清理 在说依赖清理之前，再来看一个有意思的例子： const state = reactive({ a: 1, show: true }); effect(() =&gt; { if (state.show) { console.log(`a: ${state.a}`) } }); state.a ++ setTimeout(() =&gt; { state.show = false state.a ++ }, 1000) 上面的例子中，我们在 [effect]{.mark} 中完成了对 [show]{.mark} 和 [a]{.mark} 的依赖收集，然后 [1s]{.mark} 后，我们改变了 [show]{.mark} 的状态为 [false]{.mark}。此时 [effect]{.mark} 内的函数中的 [console.log]{.mark} 将永远不会执行，然后再触发 [state.a++]{.mark} 的动作，访问 [a]{.mark} 的 [getter]{.mark}，如果没有依赖清理，那么按照之前的做法，测试也会触发 [effect.fn]{.mark} 的执行，但这个执行其实没意义的，因为 [a]{.mark} 已经没有被使用了，是一个永远不会被访问到的变量，造成了性能浪费。所以我们需要删除 [a]{.mark} 的副作用函数，让它不要执行。 接下来一起来看看 [Vue]{.mark} 是怎么做的吧！这里涉及到的内容有点多，我们先一个个解释，首先补习一下关于 [js]{.mark} 的一些操作符的基础知识。 1. 左移（&lt;&lt;） 左移操作符 ([&lt;&lt;]{.mark}) 将第一个操作数转换成 2进制后向左移动指定位数，左边超出的位数将会被清除，右边将会补零。 const a = 1; // 00000000000000000000000000000001 const b = 1; console.log(a &lt;&lt; b); // 00000000000000000000000000000010 // expected output: 2 2. 位或操作（|） 位或操作符（|）， 如果两位之一为 1，则设置每位为 1。 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a | b); // 00000000000000000000000000000111 // expected output: 7 3. 按位与（&amp;） 按位与运算符 ([&amp;]{.mark})在两个操作数对应的二进位都为 [1]{.mark} 时，该位的结果值才为 [1]{.mark}，否则为 [0]{.mark}。 const a = 5; // 00000000000000000000000000000101 const b = 3; // 00000000000000000000000000000011 console.log(a &amp; b); // 00000000000000000000000000000001 // expected output: 1 4. 按位非（~） 按位非运算符（~），反转操作数的位。 const a = 5; // 00000000000000000000000000000101 const b = -3; // 11111111111111111111111111111101 console.log(~a); // 11111111111111111111111111111010 // expected output: -6 console.log(~b); // 00000000000000000000000000000010 // expected output: 2 有了这些基础的知识点后，再来认识几个变量。 1. effectTrackDepth 用于记录位于响应上下文中的 [effect]{.mark} 嵌套层次数，默认值为 [0]{.mark}。 // effectTrackDepth = 0 effect(() =&gt; { // effectTrackDepth = 1 effect(() =&gt; {}) }) 2. trackOpBit 二进制位，每一位用于标识当前 [effect]{.mark} 嵌套层级的依赖收集的启用状态。默认值为 [1]{.mark}，即 [00000000000000000000000000000001]{.mark}。 3. maxMarkerBits 表示最大的 [effect]{.mark} 嵌套的层次数，最大值为 [30]{.mark}。 好了，搞懂了这些操作符之后，我们来看看 [Vue]{.mark} 的依赖清理是如何实现的，先来看不超过 [maxMarkerBits]{.mark} 层级数的嵌套 [effect]{.mark} 的依赖收集的过程，还以上面那个 [demo]{.mark} 作为示例： const state = reactive({ a: 1, show: true }); effect(() =&gt; { if (state.show) { console.log(`a: ${state.a}`) } }); state.a ++ setTimeout(() =&gt; { state.show = false state.a ++ }, 1000) Step 1：[run]{.mark} 函数执行的时候，[trackOpBit = 1 &lt;&lt;++effectTrackDepth]{.mark} 这个语句执行完成后，得到 [effectTrackDepth =1]{.mark}；[trackOpBit.toString(2) =00000000000000000000000000000010]{.mark}。 Step 2：因为 [effectTrackDepth &lt;maxMarkerBits]{.mark} ，所以执行 [initDepMarkers]{.mark} 函数，因为这里的 [deps]{.mark} 在初始化的时候还是个空数组，所以此函数未执行。 export const initDepMarkers = ({ deps }) =&gt; { if (deps.length) { for (let i = 0; i &lt; deps.length; i++) { deps[i].w |= trackOpBit // set was tracked } } } Step3：执行 [this.fn]{.mark} 函数，先访问 [state.show]{.mark}，触发了 [trackEffects]{.mark}。 export function trackEffects(dep) { let shouldTrack = false if (effectTrackDepth &lt;= maxMarkerBits) { // 如果本轮副作用函数执行过程中已经访问并收集过，则不用再收集该依赖 if (!newTracked(dep)) { // 设置 dep.n dep.n |= trackOpBit shouldTrack = !wasTracked(dep) } } else { // Full cleanup mode. shouldTrack = !dep.has(activeEffect!) } if (shouldTrack) { dep.add(activeEffect!) activeEffect!.deps.push(dep) } } 这里需要额外了解 2个函数：[wasTracked]{.mark}（已经被收集过，缩写是 [w]{.mark}）和 [newTracked]{.mark}（新收集的依赖，缩写是 [n]{.mark}）。 export const wasTracked = dep =&gt; (dep.w &amp; trackOpBit) &gt; 0 export const newTracked = dep =&gt; (dep.n &amp; trackOpBit) &gt; 0 进入 [trackEffects]{.mark} 时，因为此时还没有为 [dep.n]{.mark} 进行或运算赋值，所以 [state.show]{.mark} 的 [newTracked= false]{.mark}，[wasTracked = false]{.mark}。 所以计算得到 [shouldTrack =true]{.mark}，最后将 [activeEffect]{.mark} 收集进入 [dep]{.mark} 中，同时执行了 [activeEffect.deps.push(dep)]{.mark} 将 [dep]{.mark} 存入了 [activeEffect]{.mark} 的 [deps]{.mark} 中。然后访问 [state.a]{.mark} 重复上述操作。上述步骤执行完成后的 [activeEffect.deps]{.mark} 如下： [ {&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]}, {&quot;w&quot;:0,&quot;n&quot;: 00000000000000000000000000000010, [effect]} ] Step 4：最后执行 [finalizeDepMarkers]{.mark} 函数，根据第 3步，此时 [effect]{.mark} 中的 [deps]{.mark} 包含了 2个 [dep]{.mark}，分别是 [state.show]{.mark} 和 [state.a]{.mark}。 [finalizeDepMarkers]{.mark} 函数内部执行了 [wasTracked]{.mark}（已经被收集过，缩写是 [w]{.mark}）和 [newTracked]{.mark}（新收集的依赖，缩写是 [n]{.mark}）函数，因为 [dep.w = 0]{.mark} 所以 [wasTracked = false]{.mark}。 export const finalizeDepMarkers = (effect: ReactiveEffect) =&gt;{ const { deps } = effect if (deps.length) { let ptr = 0 for (let i = 0; i &lt; deps.length; i++) { const dep = deps[i] if (wasTracked(dep) &amp;&amp; !newTracked(dep)) { dep.delete(effect) } else { // 缩小依赖集合的大小 deps[ptr++] = dep } // clear bits dep.w &amp;= ~trackOpBit dep.n &amp;= ~trackOpBit } deps.length = ptr } } 因为 [wasTracked =false]{.mark}，因此 [finalizeDepMarkers]{.mark} 处理后仍然将副作用函数保留在这两个属性对应的依赖集合中，同时把 [dep.w]{.mark} 和 [dep.n]{.mark} 重置回0。 [{&quot;w&quot;:0, &quot;n&quot;:0, [effect]},{&quot;w&quot;:0, &quot;n&quot;:0,[effect]}] Step 5：当执行 [state.show =false]{.mark} 的时候，触发 [effect.run]{.mark} 的执行，此时执行 [initDepMarkers]{.mark} 时，因为已经存在了 [dep]{.mark}，所以先访问 [state.show]{.mark}。 当执行到 [trackEffects]{.mark} 时，此时的 [newTracked =false]{.mark}，执行逻辑和之前一致。只不过因为 [state.show =false]{.mark}，所以没有触发 [state.a]{.mark} 的这一部分逻辑的处理，最后得到的结果为： [ { &quot;w&quot;: 00000000000000000000000000000010, &quot;n&quot;: 00000000000000000000000000000010, [effect] }, { &quot;w&quot;: 00000000000000000000000000000010, &quot;n&quot;: 0, [effect] } ] Step 6：最后执行 [finalizeDepMarkers]{.mark} 时，如下。 if (wasTracked(dep) &amp;&amp; !newTracked(dep)) { dep.delete(effect) } 因为这里的 [state.a]{.mark} 的 [wasTracked =true]{.mark} 且 [newTracked]{.mark} 为 [false]{.mark}，所以执行了 [dep.delete(effect)]{.mark} 将 [effect]{.mark} 从 [dep]{.mark} 中踢掉。 Step7：[1s]{.mark} 后执行 [state.a++]{.mark} 的操作，由于 [state.a]{.mark} 中没有 [effect]{.mark} 了，所以不会执行副作用函数。 总结： [Vue]{.mark} 在组件的 [effect]{.mark} 执行之前，会根据 [dep]{.mark} 的收集标记位 [w]{.mark} 和 [n]{.mark} 来进行清理依赖，删除之前 [state.a]{.mark} 收集的 [effect]{.mark} 依赖。这样当我们修改 [state.a]{.mark} 时，由于已经没有依赖了，就不会触发 [effect]{.mark} 重新执行。 另外，为了更容易帮助小伙伴们理解上述的流程，我也精心制作了一个动画演示上述流程和过程： 注意，当 [effectTrackDepth]{.mark} 大于 [30]{.mark} 时，会调用 [cleanup]{.mark} 来清理依赖，其实 [cleanup]{.mark} 的原理就是依赖收集前全部删除所有的 [dep]{.mark}，依赖收集时再一个个加进来，这个性能其实是比较差的，所以 [Vue3.2]{.mark} 改成了通过二进制标记位的方式来选择性删除和添加，提升了性能。关于这部分更多的细节，可以参考[这个PR]{.mark}。 总结 到这里，我们基本上讲完了 [Vue3]{.mark} 的响应式原理基础，如果有小伙伴了解 [Vue2]{.mark} 的响应式原理，应该清楚 [Vue2]{.mark} 的响应式原理可以理解成如下一幅图： 在 [Vue2]{.mark} 中，[Watcher]{.mark} 就是依赖，有专门针对组件渲染的 [renderwatcher]{.mark}。 依赖收集：组件在 render 的时候会访问模板中的数据，触发 getter 把 watcher 作为依赖收集。 触发渲染：当修改数据时，会触发 setter，通知 watcher 更新，进而触发了组件的重新渲染。 相应地，在 [Vue 3]{.mark} 中的响应式流程如下： 可以看到，[Vue 3]{.mark} 相对于 [Vue2]{.mark} 的响应式差别不大，主要就是劫持数据的方式改成用 [Proxy]{.mark} 实现，以及收集的依赖由 [watcher]{.mark} 实例变成了组件副作用函数 [effect]{.mark}。另外，值得一提的是 [Vue3]{.mark} 在响应式设计上又多考虑了层级嵌套的依赖收集问题和不必要的依赖清理问题。","link":"/posts/91e84f90/"},{"title":"响应式原理：Vue 3 的 nextTick ？","text":"了解了对于 [Vue3]{.mark} 中的响应式原理：我们通过对 [state]{.mark} 数据的响应式拦截，当触发 [proxysetter]{.mark} 的时候，执行对应状态的 [effect]{.mark} 函数。接下来看一个经典的例子 前言 了解了对于 [Vue3]{.mark} 中的响应式原理：我们通过对 [state]{.mark} 数据的响应式拦截，当触发 [proxysetter]{.mark} 的时候，执行对应状态的 [effect]{.mark} 函数。接下来看一个经典的例子： &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;click&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue'; export default { setup() { const number = ref(0) function handleClick() { for (let i = 0; i &lt; 1000; i++) { number.value ++; } } return { number, handleClick } } } &lt;/script&gt; 当我们按下 [click]{.mark} 按钮的时候，[number]{.mark} 会被循环增加 [1000]{.mark} 次。那么 [Vue]{.mark} 的视图会在点击按钮的时候，从 [1-&gt; 1000]{.mark} 刷新 [1000]{.mark} 次吗？这一小节，我们将一起探探究竟。 queueJob 我们小册第四节介绍关于”组件更新策略”的时候，提到了 [setupRenderEffect]{.mark} 函数： const setupRenderEffect = (instance, initialVNode, container,anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { if (!instance.isMounted) { // 初始化组件 } else { // 更新组件 } } // 创建响应式的副作用渲染函数 instance.update = effect(componentUpdateFn, prodEffectOptions) } 当时这里为了方便介绍组件的更新策略，我们简写了 [instance.update]{.mark} 的函数创建过程，现在我们来详细看一下 [instance.update]{.mark} 这个函数的创建： const setupRenderEffect = (instance, initialVNode, container,anchor, parentSuspense, isSVG, optimized) =&gt; { function componentUpdateFn() { // ... } // 创建响应式的副作用渲染函数 const effect = (instance.effect = new ReactiveEffect( componentUpdateFn, () =&gt; queueJob(update), instance.scope )) // 生成 instance.update 函数 const update = (instance.update = () =&gt; effect.run()) update.id = instance.uid // 组件允许递归更新 toggleRecurse(instance, true) // 执行更新 update() } 可以看到在创建 [effect]{.mark} 副作用函数的时候，会给 [ReactiveEffect]{.mark} 传入一个 [scheduler]{.mark} 调度函数，这样生成的 [effect]{.mark} 中就包含了 [scheduler]{.mark} 属性。同时为组件实例生成了一个 [update]{.mark} 属性，该属性的值就是执行 [effect.run]{.mark} 的函数，另外需要注意的一点是 [update]{.mark} 中包含了一个 [id]{.mark} 信息，该值是一个初始值为 [0]{.mark} 的自增数字，下文我们再详细介绍其作用。 当我们触发 [proxysetter]{.mark} 的时候，触发执行了 [triggerEffect]{.mark} 函数，这次，我们补全 [triggerEffect]{.mark} 函数的实现： function triggerEffect(effect, debuggerEventExtraInfo) { if (effect !== activeEffect || effect.allowRecurse) { // effect 上存在 scheduler if (effect.scheduler) { effect.scheduler() } else { effect.run() } } } 可以看到，如果 [effect]{.mark} 上有 [scheduler]{.mark} 属性时，执行的是 [effect.scheduler]{.mark} 函数，否则执行 [effect.run]{.mark} 进行视图更新。而这里显然我们需要先执行调度函数 [scheduler]{.mark}。通过上面的信息，我们也清楚地知道 [scheduler]{.mark} 函数的本质就是执行了 [queueJob(update)]{.mark} 函数，一起来看一下 [queueJob]{.mark} 的实现： export function queueJob(job) { // 去重判断 if ( !queue.length || !queue.includes( job, isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex ) ) { // 添加到队列尾部 if (job.id == null) { queue.push(job) } else { // 按照 job id 自增的顺序添加 queue.splice(findInsertionIndex(job.id), 0, job) } queueFlush() } } [queueJob]{.mark} 就是维护了一个 [queue]{.mark} 队列，目的是向 [queue]{.mark} 队列中添加 [job]{.mark} 对象，这里的 [job]{.mark} 就是我们前面的 [update]{.mark} 对象。 这里有几点需要说明一下。 第一个是该函数会有一个 [isFlushing &amp;&amp;job.allowRecurse]{.mark} 判断，这个作用是啥呢？简单点说就是当队列正处于更新状态中（[isFlushing= true]{.mark}） 且允许递归调用（ [job.allowRecurse =true]{.mark}）时，将搜索起始位置加一，无法搜索到自身，也就是允许递归调用了。什么情况下会出现递归调用？ &lt;!-- 父组件 --&gt; &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;Child /&gt; &lt;/template&gt; &lt;script&gt; import { ref, provide } from 'vue'; import Child from './components/Child.vue'; export default { setup() { const msg = ref(&quot;initial&quot;); provide(&quot;CONTEXT&quot;, { msg }); return { msg }; }, components: { Child } } &lt;/script&gt; &lt;!-- 子组件 Child --&gt; &lt;template&gt; &lt;div&gt;child&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { inject } from 'vue'; export default { setup() { const ctx = inject(&quot;CONTEXT&quot;); ctx.msg.value = &quot;updated&quot;; } } &lt;/script&gt; 对于这种情况，首先是父组件进入 [job]{.mark} 然后渲染父组件，接着进入子组件渲染，但是子组件内部修改了父组件的状态 [msg]{.mark}。此时父组件需要支持递归渲染，也就是递归更新。 注意，这里的更新已经不属于单选数据流了，如果过多地打破单向数据流，会导致多次递归执行更新，可能会导致性能下降。 第二个是，[queueJob]{.mark} 函数向 [queue]{.mark} 队列中添加的 [job]{.mark} 是按照 [id]{.mark} 排序的，[id]{.mark} 小的 [Job]{.mark} 先被推入 [queue]{.mark} 中执行，这保证了，父组件永远比子组件先更新（因为先创建父组件，再创建子组件，子组件可能依赖父组件的数据）。 再回到函数的本身来说，当我们执行 [for]{.mark} 循环 [1000]{.mark} 次 [setter]{.mark} 的时候，因为在第一步进行了去重判断，所以 [update]{.mark} 函数只会被添加一次到 [queue]{.mark} 中。这里的 [update]{.mark} 函数就是组件的渲染函数。所以无论这里执行多少次循环，渲染更新函数只会被执行一次。 queueFlush 上面说到了无论循环多少次 [setter]{.mark}，这里相同 [id]{.mark} 的 [update]{.mark} 只会被添加一次到 [queue]{.mark} 中。 细心的小伙伴可能会有这样的疑问：那么为什么视图不是从 [0 -&gt;1]{.mark} 而是直接从 [0 -&gt; 1000]{.mark} 了呢？ 要回答上面的问题，就得了解一下 [queue]{.mark} 的执行更新相关的内容了，也就是 [queueJob]{.mark} 的最后一步 [queueFlush]{.mark}： function queueFlush() { // 是否正处于刷新状态 if (!isFlushing &amp;&amp; !isFlushPending) { isFlushPending = true currentFlushPromise = resolvedPromise.then(flushJobs) } } 可以看到这里，[vue3]{.mark} 完全抛弃了除了 [promise]{.mark} 之外的异步方案，不再支持[vue2]{.mark} 的 [Promise &gt; MutationObserver &gt; setImmediate &gt;setTimeout]{.mark} 其他三种异步操作了。 所以这里，[vue3]{.mark} 直接通过 [promise]{.mark} 创建了一个微任务 [flushJobs]{.mark} 进行异步调度更新，只要在浏览器当前 [tick]{.mark} 内的所有更新任务都会被推入 [queue]{.mark} 中，然后在下一个 [tick]{.mark} 中统一执行更新。 function flushJobs(seen) { // 是否正在等待执行 isFlushPending = false // 正在执行 isFlushing = true // 在更新前，重新排序好更新队列 queue 的顺序 // 这确保了: // 1.组件都是从父组件向子组件进行更新的。（因为父组件都在子组件之前创建的 // 所以子组件的渲染的 effect 的优先级比较低） // 2. 如果父组件在更新前卸载了组件，这次更新将会被跳过。 queue.sort(comparator) try { // 遍历主任务队列，批量执行更新任务 for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) { const job = queue[flushIndex] if (job &amp;&amp; job.active !== false) { callWithErrorHandling(job, null, ErrorCodes.SCHEDULER) } } } finally { // 队列任务执行完，重置队列索引 flushIndex = 0 // 清空队列 queue.length = 0 // 执行后置队列任务 flushPostFlushCbs(seen) // 重置队列执行状态 isFlushing = false // 重置当前微任务为 Null currentFlushPromise = null // 如果主任务队列、后置任务队列还有没被清空，就继续递归执行 if (queue.length || pendingPostFlushCbs.length) { flushJobs(seen) } } } 在详细介绍 [flushJobs]{.mark} 之前，我想先简单介绍一下 [Vue]{.mark} 的更新任务执行机制中的一个重要概念：更新时机。 [Vue]{.mark} 整个更新过程分成了三个部分： 更新前，称之为 pre 阶段； 更新中，也就是 flushing 中，执行 update 更新； 更新后，称之为 flushPost 阶段。 更新前 什么是 [pre]{.mark} 阶段呢？拿组件更新举例，就是在 [Vue]{.mark} 组件更新之前被调用执行的阶段。默认情况下，[Vue]{.mark} 的 [watch]{.mark} 和 [watchEffect]{.mark} 函数中的 [callback]{.mark} 函数都是在这个阶段被执行的，我们简单看一下 [watch]{.mark} 中的源码实现： function watch(surce, cb, {immediate, deep, flush, onTrack,onTrigger} = {}) { // ... if (flush === 'sync') { scheduler = job } else if (flush === 'post') { scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp;instance.suspense) } else { // 默认会给 job 打上 pre 的标记 job.pre = true if (instance) job.id = instance.uid scheduler = () =&gt; queueJob(job) } } 可以看到 [watch]{.mark} 的 [job]{.mark} 会被默认打上 [pre]{.mark} 的标签。而带 [pre]{.mark} 标签的 [job]{.mark} 则会在渲染前被执行： const updateComponent = () =&gt; { // ... 省略 n 行代码 updateComponentPreRender(instance, n2, optimized) } function updateComponentPreRender() { // ... 省略 n 行代码 flushPreFlushCbs() } export function flushPreFlushCbs(seen, i = isFlushing ? flushIndex + 1 :0) { for (; i &lt; queue.length; i++) { const cb = queue[i] if (cb &amp;&amp; cb.pre) { queue.splice(i, 1) i-- cb() } } } 可以看到，在执行 [updateComponent]{.mark} 更新组件之前，会调用 [flushPreFlushCbs]{.mark} 函数，执行所有带上 [pre]{.mark} 标签的 [job]{.mark}。 更新中 更新中的过程就是 [flushJobs]{.mark} 函数体前面的部分，首先会通过一个 [comparator]{.mark} 函数对 [queue]{.mark} 队列进行排序，这里排序的目的主要是保证父组件优先于子组件执行，另外在执行后续循环执行 [job]{.mark} 任务的时候，通过判断 [job.active!==false]{.mark} 来剔除被 [unmount]{.mark} 卸载的组件，卸载的组件会有 [active= false]{.mark} 的标记。 最后即通过 [callWithErrorHandling]{.mark} 函数执行 [queue]{.mark} 队列中的每一个 [job]{.mark}: export function callWithErrorHandling(fn, instance, type,args) { let res try { res = args ? fn(...args) : fn() } catch (err) { handleError(err, instance, type) } return res } 更新后 当页面更新后，需要执行的一些回调函数都存储在 [pendingPostFlushCbs]{.mark} 中，通过 [flushPostFlushCbs]{.mark} 函数来进行回调执行： export function flushPostFlushCbs(seen) { // 存在 job 才执行 if (pendingPostFlushCbs.length) { // 去重 const deduped = [...new Set(pendingPostFlushCbs)] pendingPostFlushCbs.length = 0 // #1947 already has active queue, nested flushPostFlushCbs call // 已经存在activePostFlushCbs，嵌套flushPostFlushCbs调用，直接return if (activePostFlushCbs) { activePostFlushCbs.push(...deduped) return } activePostFlushCbs = deduped // 按job.id升序 activePostFlushCbs.sort((a, b) =&gt; getId(a) - getId(b)) // 循环执行job for ( postFlushIndex = 0; postFlushIndex &lt; activePostFlushCbs.length; postFlushIndex++ ) { activePostFlushCbs[postFlushIndex]() } activePostFlushCbs = null postFlushIndex = 0 } } 一些需要渲染完成后再执行的钩子函数都会在这个阶段执行，比如 [mountedhook]{.mark} 等等。 总结 通过上面的一些介绍，我们可以了解到本小节开头的示例中，[number]{.mark} 的更新函数只会被同步地添加一次到更新队列 [queue]{.mark} 中，但更新是异步的，会在 [nextTick]{.mark} 也就是 [Promise.then]{.mark} 的微任务中执行 [update]{.mark}，所以更新会直接从 [0-&gt; 1000]{.mark}。 另外，需要注意的是一个组件内的相同 [update]{.mark} 只会有一个被推入 [queue]{.mark} 中。比如下面的例子： &lt;template&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;click&lt;/button&gt; &lt;/template&gt; &lt;script&gt; import { ref } from 'vue' export default { setup() { const number = ref(0) const msg = ref('init') function handleClick() { for (let i = 0; i &lt; 1000; i++) { number.value ++; } msg.value = 'hello world' } return { number, msg, handleClick } } } &lt;/script&gt; 当点击按钮时，因为 [update]{.mark} 内部执行的是当前组件的同一个 [componentUpdateFn]{.mark} 函数，状态 [msg]{.mark} 和 [number]{.mark} 的 [update]{.mark} 的 [id]{.mark} 是一致的，所以 [queue]{.mark} 中，只有一个 [update]{.mark} 函数，只会进行一次统一的更新。","link":"/posts/39441e6f/"},{"title":"每日进步：大整数相加","text":"背景在当今的前端开发行业中，随着技术的不断更新和发展，也有越来越多的人进入了这个行业，但同时也带来了更加激烈的竞争。至5月12日裸辞距今也有一个月，现在找工作也有大半个月了，boss上投了也沟通了不下200家公司，但是大部分都是已读不回，面试邀约只有寥寥3家，技术面过了两家，但可能由于自己的问题最后都不了了之。在继续投简历的空闲时间，琢磨着记录前端知识点。 腾讯面试题接下来我们来看一道面试题，这道面试题呢，整体难度不大。 1234567891011/** * 腾讯面试题 * 两个超过整数存储范围的最大整数之和 * @description * @author Leon9916 * @param {String} a * @param {String} b */function sum(a, b) {} 这道题再说什么？就是说让咱写一个函数来计算2个大整数之和。这里，首先给大家科普一下，为什么要写个函数来求和，直接加不就完了吗？ 浏览器数字上限浏览器数字上限通常是指浏览器在 JavaScript 中表示数字时的最大值。由于 JavaScript 中的数字是以 IEEE 754 标准规范表现的，因此在 JavaScript 中，数字类型是使用 64 位浮点数来表示。这意味着 JavaScript 中最大安全整数（Maximum safe integer）为 2^53-1，也就是 9007199254740991，如果大于这个数就会精度出现错误。 我们可以浏览器控制台打印 1Number.MAX_SAFE_INTEGER // 9007199254740991 当我们超过这个值的话再进行运算，他就有可能不精确比如我们给他加个1 1Number.MAX_SAFE_INTEGER + 1 // 9007199254740992 我们再给他的值加给2 1Number.MAX_SAFE_INTEGER + 2 // 9007199254740992 但是值还是992，这个时候精度就出现问题了 回到问题本身上面是问题是需要我们写一个函数来手动的完成大精度数字的相加。 11131123121323223121312321323121321312 // 1.1311231213232232e+36 上图打印一个超出精度许多的数字，虽然有返回，但是中间许多信息都被省略了所以，这个函数要接受的2个大于精度的参数，那就只能是字符串，不能写数字了，当然返回结果也只能是字符串了。 接下来就需要一些小学数学知识了比如我199+20，按照小学体育老师教的方法，从个位开始，加到十位，加到百位 …，依次往前面加,所以说这是一个什么反向的循环。但是我们循环之前，需要把这些数字对其，不能直接就开始反向循环。 数字对其首先要做的第一件事就是把这个数字对齐，不足的位数前面补零。因此，首先要拿到2个字符串的最大长度,然后将小的一方的前面用0补齐。 12345function sum(a, b) { const len = Math.max(a.length, b.length); // 获取字符串中的最大长度 a = a.padStart(len, '0') // padStart：往字符串前面添加'0',直到字符串长度为len b = b.padStart(len, '0') // 同上，因为要保持字符串长度一致，参考小学数学加法} 上下计算过程中，两个数字相加可能会大于10，所以就需要进位。 123456789function sum(a, b) { const len = Math.max(a.length, b.length); // 获取字符串中的最大长度 a = a.padStart(len, '0') // padStart：往字符串前面添加'0',直到字符串长度为len b = b.padStart(len, '0') // 同上，因为要保持字符串长度一致，参考小学数学加法 let carry = 0; // 进位数 for (let i = len - 1; i &gt;= 0; i--) { }} 然后从最后开始往前面加,字符串转换成数字并加上进位数，默认最开始加的进位数是0 1const sum = +a[i] + +b[i] + carry 由于两数相加再加上进位可能会大于9，这时就要向前进一位，并且sum在赋值的时候只用保留个位 123456789101112131415161718function sum(a, b) { const len = Math.max(a.length, b.length); // 获取字符串中的最大长度 a = a.padStart(len, '0') // padStart：往字符串前面添加'0',直到字符串长度为len b = b.padStart(len, '0') // 同上，因为要保持字符串长度一致，参考小学数学加法 let carry = 0; // 进位数 let result = ''; // 返回结果 for (let i = len - 1; i &gt;= 0; i--) { // 反向循环 const sum = +a[i] + +b[i] + carry result = (sum % 10) + result; // 取余，并加上上次的result carry = Math.floor(sum / 10); // 判断是否需要进位，向下取整，0.9取0, 1.9取1 // if(sum &gt; 9) { // carry = 1 // } else { // carry = 0 // } // 向下取整，0.9取0,1.9取1，同上，只是上面的简洁一点 } return result} 是不是以为到这就结束了？这个时候还需要判断最后一次计算的时候是不是还需要进位 12345678910111213141516171819202122function sum(a, b) { const len = Math.max(a.length, b.length); // 获取字符串中的最大长度 a = a.padStart(len, '0') // padStart：往字符串前面添加'0',直到字符串长度为len b = b.padStart(len, '0') // 同上，因为要保持字符串长度一致，参考小学数学加法 let carry = 0; // 进位数 let result = ''; // 返回结果 for (let i = len - 1; i &gt;= 0; i--) { // 反向循环 const sum = +a[i] + +b[i] + carry result = (sum % 10) + result; // 取余，并加上上次的result carry = Math.floor(sum / 10); // 向下取整，0.9取0,1.9取1 // if(sum &gt; 9) { // carry = 1 // } else { // carry = 0 // } // 向下取整，0.9取0,1.9取1，同上，只是上面的简洁一点 } // 循环结束需要判断最后一次是否还存在进位，例子99+99，两位数加上两位数，结果是三位数198，这时如果按照上图的方法就会返回98 if(carry) { result = carry + result } return result} 控制台打印 12sum('111111222222223333333333333399','22222222222223333333333333399')// '133333444444446666666666666798'","link":"/posts/f7d6e6fb/"}],"tags":[{"name":"法律","slug":"法律","link":"/tags/%E6%B3%95%E5%BE%8B/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"工具教程","slug":"工具教程","link":"/tags/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"icarus主题配置","slug":"icarus主题配置","link":"/tags/icarus%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"name":"hexo主题","slug":"hexo主题","link":"/tags/hexo%E4%B8%BB%E9%A2%98/"},{"name":"加密文章","slug":"加密文章","link":"/tags/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0/"}],"categories":[{"name":"法律","slug":"法律","link":"/categories/%E6%B3%95%E5%BE%8B/"},{"name":"文章加密","slug":"文章加密","link":"/categories/%E6%96%87%E7%AB%A0%E5%8A%A0%E5%AF%86/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"深入Vue3原理","slug":"前端/深入Vue3原理","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E5%85%A5Vue3%E5%8E%9F%E7%90%86/"},{"name":"深入浅出Vite","slug":"前端/深入浅出Vite","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAVite/"},{"name":"工具教程","slug":"工具教程","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/"},{"name":"主题工具","slug":"工具教程/主题工具","link":"/categories/%E5%B7%A5%E5%85%B7%E6%95%99%E7%A8%8B/%E4%B8%BB%E9%A2%98%E5%B7%A5%E5%85%B7/"},{"name":"每日进步","slug":"前端/每日进步","link":"/categories/%E5%89%8D%E7%AB%AF/%E6%AF%8F%E6%97%A5%E8%BF%9B%E6%AD%A5/"}]}